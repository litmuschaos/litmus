{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ROADMAP/","title":"Roadmap","text":""},{"location":"ROADMAP/#litmus-roadmap","title":"LITMUS ROADMAP","text":"<p>This document captures only the high level roadmap items. For the detailed backlog, see issues list. </p>"},{"location":"ROADMAP/#completed","title":"Completed","text":"<ul> <li>Declarative Chaos Intent via custom resources</li> <li>Chaos Operator to orchestrate chaos experiments</li> <li>Off the shelf / ready chaos experiments for general Kubernetes chaos </li> <li>Self sufficient, Centralized Hub for chaos experiments</li> <li>Per-experiment minimal RBAC permissions definition</li> <li>Creation of 'scenarios' involving multiple faults via Argo-based Chaos Workflows (with examples for microservices apps like podtato-head and sock-shop)</li> <li>Cross-Cloud Control Plane (Litmus Portal) to perform chaos against remote clusters</li> <li>Helm charts for LitmusChaos control plane  </li> <li>Helm Chart for LitmusChaos execution Plane</li> <li>Support for admin mode (centralized chaos management) as well as namespaced mode (multi-tenant clusters)</li> <li>Continuous chaos via flexible schedules, with support to halt/resume or (manual/conditional) abort experiments</li> <li>Provide complete workflow termination/abort capability </li> <li>Generation of observability data via Prometheus metrics and Kubernetes chaos events for experiments</li> <li>Steady-State hypothesis validation before, during and after chaos injection via different probe types</li> <li>Support for Docker, Containerd &amp; CRI-O runtime</li> <li>Support for scheduling policies (nodeSelector, tolerations) and resource definitions for chaos pods</li> <li>ChaosHub refactor for 2.x user flow </li> <li>Support for ARM64 nodes</li> <li>Minimized role permissions for Chaos Service Accounts</li> <li>Scaffolding scripts (SDK) to help bootstrap a new chaos experiment in Go, Python, Ansible</li> <li>Support orchestration of non-native chaos libraries via the BYOC (Bring-Your-Own-Chaos) model</li> <li>Support for OpenShift platform </li> <li>Workflow YAML linter addition</li> <li>Integration tests &amp; e2e framework creation for control plane components and chaos experiments</li> <li>Documentation (usage guide for chaos operator, resources &amp; developer guide for new experiment creation)</li> <li>Improved documentation and tutorials for Litmus Portal based execution flow </li> <li>Add architecture details &amp; design resources </li> <li>Define community sync up cadence and structure  </li> </ul>"},{"location":"ROADMAP/#in-progress-under-design-or-active-development","title":"In-Progress (Under Design OR Active Development)","text":"<ul> <li>Native Chaos Workflows with redesigned subscriber to improve resource delegation, enabling seamless and efficient execution of chaos workflows within Kubernetes clusters.</li> <li>Introduce transient runners to improve resource efficiency during chaos experiments by dynamically creating and cleaning up chaos runner instances.</li> <li>Implement Kubernetes connectors to enable streamlined integration with Kubernetes clusters, providing simplified authentication and configuration management.</li> <li>Integrate with tools like K8sGPT to generate insightful reports that identify potential weaknesses in your Kubernetes environment before executing chaos experiments.</li> <li>Add Terraform support for defining and executing chaos experiments on infrastructure components, enabling infrastructure-as-code-based chaos engineering.</li> <li>Add SDK support for Python and Java, with potential extensions to other programming languages based on community interest.</li> <li>Include in-product documentation, such as tooltips, to improve user experience and ease of adoption.</li> <li>Implement the litmus-java-sdk with a targeted v1.0.0 release by Q1.</li> <li>Integrate distributed tracing by adding attributes or events to spans, and create an OpenTelemetry demo showcasing chaos engineering observability.</li> <li>Enhance the exporter to function as an OpenTelemetry collector, providing compatibility with existing observability pipelines.</li> <li>Add support for DocumentDB by replacing certain MongoDB operations, improving flexibility for database chaos.</li> <li>Upgrade Kubernetes SDK from version 1.21 to 1.26 to stay aligned with the latest Kubernetes features and enhancements.</li> <li>Refactor the chaos charts to:</li> <li>Replace latest tags with specific, versioned image tags.</li> <li>Consolidate multiple images into a single optimized image.</li> <li>Update GraphQL and authentication API documentation for improved clarity and user guidance.</li> <li>Add comprehensive unit and fuzz tests to enhance code reliability and robustness.</li> <li>Implement out-of-the-box Slack integration for better collaboration and monitoring during chaos experiments.</li> </ul>"},{"location":"ROADMAP/#backlog","title":"Backlog","text":"<ul> <li>Validation support for all ChaosEngine schema elements within workflow wizard </li> <li>Chaos-center users account to chaosService account map</li> <li>Cross-hub experiment support within a Chaos Workflow </li> <li>Enhanced CRD schema for ChaosEngine to support advanced CommandProbe configuration</li> <li>Support for S3 artifact sink (helps performance/benchmark runs)</li> <li>Chaos experiments against virtual machines and cloud infrastructure (AWS, GCP, Azure, VMWare, Baremetal)</li> <li>Off the shelf chaos-integrated monitoring dashboards for application chaos categories </li> <li>Support for user defined chaos experiment result definition </li> <li>Increased fault injection types (IOChaos, HTTPChaos, JVMChaos) </li> <li>Special Interest Groups (SIGs) around specific areas in the project to take the roadmap forward</li> </ul>"},{"location":"experiments/api/contents/","title":"Litmus API Documentation","text":"Name Description References AUTH Server Contains AUTH Server API documentation AUTH Server GraphQL Server Contains GraphQL Server API documentation GraphQL Server"},{"location":"experiments/categories/contents/","title":"Experiments","text":"<p>The experiment execution is triggered upon creation of the ChaosEngine resource (various examples of which are provided under the respective experiments). Typically, these chaosengines are embedded within the 'steps' of a Litmus Chaos Workflow here. However, one may also create the chaos engines directly by hand, and the chaos-operator reconciles this resource and triggers the experiment execution.</p> <p>Provided below are tables with links to the individual experiment docs for easy navigation</p>"},{"location":"experiments/categories/contents/#kubernetes-experiments","title":"Kubernetes Experiments","text":"<p>It contains chaos experiments which apply on the resources, which are running on the kubernetes cluster. It contains <code>Generic</code> experiments.</p> <p>Following Kubernetes Chaos experiments are available:</p>"},{"location":"experiments/categories/contents/#generic","title":"Generic","text":"<p>Chaos actions that apply to generic Kubernetes resources are classified into this category. Following chaos experiments are supported under Generic Chaos Chart</p>"},{"location":"experiments/categories/contents/#pod-chaos","title":"Pod Chaos","text":"Experiment Name Description User Guide Container Kill Kills the container in the application pod container-kill Disk Fill Fillup Ephemeral Storage of a Resourced disk-fill Pod Autoscaler Scales the application replicas and test the node autoscaling on cluster pod-autoscaler Pod CPU Hog Exec Consumes CPU resources on the application container by invoking a utility within the app container base image pod-cpu-hog-exec Pod CPU Hog Consumes CPU resources on the application container pod-cpu-hog Pod Delete Deletes the application pod  pod-delete Pod DNS Error Disrupt dns resolution in kubernetes po pod-dns-error Pod DNS Spoof Spoof dns resolution in kubernetes pod pod-dns-spoof Pod IO Stress Injects IO stress resources on the application container pod-io-stress Pod Memory Hog Exec Consumes Memory resources on the application container by invoking a utility within the app container base image pod-memory-hog-exec Pod Memory Hog Consumes Memory resources on the application container pod-memory-hog Pod Network Corruption Injects Network Packet Corruption into Application Pod pod-network-corruption Pod Network Duplication Injects Network Packet Duplication into Application Pod pod-network-duplication Pod Network Latency Injects Network latency into Application Pod pod-network-latency Pod Network Loss Injects Network loss into Application Pod pod-network-loss Pod HTTP Latency Injects HTTP latency into Application Pod pod-http-latency Pod HTTP Reset Peer Injects HTTP reset peer into Application Pod pod-http-reset-peer Pod HTTP Status Code Injects HTTP status code chaos into Application Pod pod-http-status-code Pod HTTP Modify Body Injects HTTP modify body into Application Pod pod-http-modify-body Pod HTTP Modify Header Injects HTTP Modify Header into Application Pod pod-http-modify-header"},{"location":"experiments/categories/contents/#node-chaos","title":"Node Chaos","text":"Experiment Name Description User Guide Docker Service Kill Kills the docker service on the application node docker-service-kill Kubelet Service Kill Kills the kubelet service on the application node kubelet-service-kill Node CPU Hog Exhaust CPU resources on the Kubernetes Node node-cpu-hog Node Drain Drains the target node node-drain Node IO Stress Injects IO stress resources on the application node node-io-stress Node Memory Hog Exhaust Memory resources on the Kubernetes Node node-memory-hog Node Restart  Restarts the target node node-restart Node Taint Taints the target node node-taint"},{"location":"experiments/categories/contents/#application-chaos","title":"Application Chaos","text":"<p>While Chaos Experiments under the Generic category offer the ability to induce chaos into Kubernetes resources, it is difficult to analyze and conclude if the chaos induced found a weakness in a given application. The application specific chaos experiments are built with some checks on pre-conditions and some expected outcomes after the chaos injection. The result of the chaos experiment is determined by matching the outcome with the expected outcome. </p> Experiment Name Description User Guide Spring Boot App Kill Kill the spring boot application spring-boot-app-kill Spring Boot CPU Stress Stress the CPU of the spring boot application spring-boot-cpu-stress Spring Boot Memory Stress Stress the memory of the spring boot application spring-boot-memory-stress Spring Boot Latency  Inject latency to the spring boot application network spring-boot-latency Spring Boot Exception Raise exceptions to the spring boot application spring-boot-exceptions Spring Boot Faults It injects the multiple spring boot faults simultaneously on the target pods spring-boot-faults"},{"location":"experiments/categories/contents/#load-chaos","title":"Load Chaos","text":"<p>Load chaos contains different chaos experiments to test the app/platform service availability. It will install all the experiments which can be used to inject load into the services like VMs, Pods and so on.</p> Experiment Name Description User Guide k6 Load Generator Generate load using single js script k6-loadgen"},{"location":"experiments/categories/contents/#cloud-infrastructure","title":"Cloud Infrastructure","text":"<p>Chaos experiments that inject chaos into the platform resources of Kubernetes are classified into this category. Management of platform resources vary significantly from each other, Chaos Charts may be maintained separately for each platform (For example, AWS, GCP, Azure, etc)</p> <p>Following Platform Chaos experiments are available:</p>"},{"location":"experiments/categories/contents/#aws","title":"AWS","text":"Experiment Name Description User Guide EC2 Stop By ID Stop the EC2 instance matched by instance id ec2-stop-by-id EC2 Stop By Tag Stop the EC2 instance matched by instance tag ec2-stop-by-tag EBS Loss By ID Detach the EBS volume matched by volume id ebs-loss-by-id EBS Loss By Tag Detach the EBS volume matched by volume tag ebs-loss-by-tag"},{"location":"experiments/categories/contents/#gcp","title":"GCP","text":"Experiment Name Description User Guide GCP VM Instance Stop Stop the gcp vm instance gcp-vm-instance-stop GCP VM Disk Loss Detach the gcp disk gcp-vm-disk-loss"},{"location":"experiments/categories/contents/#azure","title":"Azure","text":"Experiment Name Description User Guide Azure Instance Stop Stop the azure instance azure-instance-stop Azure Disk Loss Detach azure disk from instance azure-disk-loss"},{"location":"experiments/categories/contents/#vmware","title":"VMWare","text":"Experiment Name Description User Guide VM Poweroff Poweroff the vmware VM vm-poweroff"},{"location":"experiments/categories/aws/AWS-experiments-tunables/","title":"AWS experiments tunables","text":"<p>It contains the AWS specific experiment tunables.</p>"},{"location":"experiments/categories/aws/AWS-experiments-tunables/#managed-nodegroup","title":"Managed Nodegroup","text":"<p>It specifies whether aws instances are part of managed nodeGroups. If instances belong to the managed nodeGroups then provide <code>MANAGED_NODEGROUP</code> as <code>enable</code> else provide it as <code>disable</code>. The default value is <code>disabled</code>.</p> <p>Use the following example to tune this:</p> <pre><code># it provided as enable if instances are part of self managed groups\n# it is applicable for [ec2-terminate-by-id, ec2-terminate-by-tag]\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ec2-terminate-by-tag-sa\n  experiments:\n  - name: ec2-terminate-by-tag\n    spec:\n      components:\n        env:\n        # if instance is part of a managed node-group\n        # supports enable and disable values, default value: disable\n        - name: MANAGED_NODEGROUP\n          value: 'enable'\n        # region for the ec2 instance\n        - name: REGION\n          value: '&lt;region for instances&gt;'\n        # tag of the ec2 instance\n        - name: EC2_INSTANCE_TAG\n          value: 'key:value'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws/AWS-experiments-tunables/#mutiple-iterations-of-chaos","title":"Mutiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ec2-terminate-by-tag-sa\n  experiments:\n  - name: ec2-terminate-by-tag\n    spec:\n      components:\n        env:\n         # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '15'\n        # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n        - name: REGION\n          value: '&lt;region for instances&gt;'\n        - name: EC2_INSTANCE_TAG\n          value: 'key:value'\n</code></pre>"},{"location":"experiments/categories/aws/ebs-loss-by-id/","title":"EBS Loss By ID","text":""},{"location":"experiments/categories/aws/ebs-loss-by-id/#introduction","title":"Introduction","text":"<ul> <li>It causes chaos to disrupt state of ebs volume by detaching it from the node/ec2 instance for a certain chaos duration using volume id.</li> <li>In case of EBS persistent volumes, the volumes can get self-attached and experiment skips the re-attachment step. Tests deployment sanity (replica availability &amp; uninterrupted service) and recovery workflows of the application pod.</li> </ul> <p>Scenario: Detach EBS Volume</p> <p></p>"},{"location":"experiments/categories/aws/ebs-loss-by-id/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/aws/ebs-loss-by-id/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>ebs-loss-by-id</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient AWS access to attach or detach an ebs volume for the instance. </li> <li> <p>Ensure to create a Kubernetes secret having the AWS access configuration(key) in the <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  cloud_config.yml: |-\n    # Add the cloud AWS credentials respectively\n    [default]\n    aws_access_key_id = XXXXXXXXXXXXXXXXXXX\n    aws_secret_access_key = XXXXXXXXXXXXXXX\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>cloud_config.yml</code>) please also update the <code>AWS_SHARED_CREDENTIALS_FILE</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/aws/ebs-loss-by-id/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>EBS volume is attached to the instance.</li> </ul>"},{"location":"experiments/categories/aws/ebs-loss-by-id/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ebs-loss-by-id-sa\n  namespace: default\n  labels:\n    name: ebs-loss-by-id-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: ebs-loss-by-id-sa\n  labels:\n    name: ebs-loss-by-id-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: ebs-loss-by-id-sa\n  labels:\n    name: ebs-loss-by-id-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: ebs-loss-by-id-sa\nsubjects:\n- kind: ServiceAccount\n  name: ebs-loss-by-id-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/aws/ebs-loss-by-id/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   EBS_VOLUME_ID   Comma separated list of volume IDs subjected to ebs detach chaos  REGION   The region name for the target volumes </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The time duration between the attachment and detachment of the volumes (sec)   Defaults to 30s   SEQUENCE   It defines sequence of chaos execution for multiple volumes  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/aws/ebs-loss-by-id/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/aws/ebs-loss-by-id/#common-and-aws-specific-tunables","title":"Common and AWS specific tunables","text":"<p>Refer the common attributes and AWS specific tunable to tune the common tunables for all experiments and aws specific tunables.  </p>"},{"location":"experiments/categories/aws/ebs-loss-by-id/#detach-volumes-by-id","title":"Detach Volumes By ID","text":"<p>It contains comma separated list of volume IDs subjected to ebs detach chaos. It can be tuned via <code>EBS_VOLUME_ID</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># contains ebs volume id \napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ebs-loss-by-id-sa\n  experiments:\n  - name: ebs-loss-by-id\n    spec:\n      components:\n        env:\n        # id of the ebs volume\n        - name: EBS_VOLUME_ID\n          value: 'ebs-vol-1'\n        # region for the ebs volume\n        - name: REGION\n          value: '&lt;region for EBS_VOLUME_ID&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/","title":"EBS Loss By Tag","text":""},{"location":"experiments/categories/aws/ebs-loss-by-tag/#introduction","title":"Introduction","text":"<ul> <li>It causes chaos to disrupt state of ebs volume by detaching it from the node/ec2 instance for a certain chaos duration using volume tags.</li> <li>In case of EBS persistent volumes, the volumes can get self-attached and experiment skips the re-attachment step. Tests deployment sanity (replica availability &amp; uninterrupted service) and recovery workflows of the application pod.</li> </ul> <p>Scenario: Detach EBS Volume</p> <p></p>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>ebs-loss-by-tag</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient AWS access to attach or detach an ebs volume for the instance. </li> <li> <p>Ensure to create a Kubernetes secret having the AWS access configuration(key) in the <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  cloud_config.yml: |-\n    # Add the cloud AWS credentials respectively\n    [default]\n    aws_access_key_id = XXXXXXXXXXXXXXXXXXX\n    aws_secret_access_key = XXXXXXXXXXXXXXX\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>cloud_config.yml</code>) please also update the <code>AWS_SHARED_CREDENTIALS_FILE</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>EBS volume is attached to the instance.</li> </ul>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ebs-loss-by-tag-sa\n  namespace: default\n  labels:\n    name: ebs-loss-by-tag-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: ebs-loss-by-tag-sa\n  labels:\n    name: ebs-loss-by-tag-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: ebs-loss-by-tag-sa\n  labels:\n    name: ebs-loss-by-tag-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: ebs-loss-by-tag-sa\nsubjects:\n- kind: ServiceAccount\n  name: ebs-loss-by-tag-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   EBS_VOLUME_TAG   Provide the common tag for target volumes. It'll be in form of <code>key:value</code> (Ex: 'team:devops')  REGION   The region name for the target volumes </p> <p></p> <p>  Variables   Description   Notes   VOLUME_AFFECTED_PERC   The Percentage of total ebs volumes to target   Defaults to 0 (corresponds to 1 volume), provide numeric value only   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The time duration between the attachment and detachment of the volumes (sec)   Defaults to 30s   SEQUENCE   It defines sequence of chaos execution for multiple volumes  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/aws/ebs-loss-by-tag/#common-and-aws-specific-tunables","title":"Common and AWS specific tunables","text":"<p>Refer the common attributes and AWS specific tunable to tune the common tunables for all experiments and aws specific tunables.  </p>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#target-single-volume","title":"Target single volume","text":"<p>It will detach a random single ebs volume with the given <code>EBS_VOLUME_TAG</code> tag and <code>REGION</code> region.</p> <p>Use the following example to tune this:</p> <pre><code># contains the tags for the ebs volumes \napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ebs-loss-by-tag-sa\n  experiments:\n  - name: ebs-loss-by-tag\n    spec:\n      components:\n        env:\n        # tag of the ebs volume\n        - name: EBS_VOLUME_TAG\n          value: 'key:value'\n        # region for the ebs volume\n        - name: REGION\n          value: '&lt;region for EBS_VOLUME_TAG&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws/ebs-loss-by-tag/#target-percent-of-volumes","title":"Target Percent of volumes","text":"<p>It will detach the <code>VOLUME_AFFECTED_PERC</code> percentage of ebs volumes with the given <code>EBS_VOLUME_TAG</code> tag and <code>REGION</code> region.</p> <p>Use the following example to tune this:</p> <pre><code># target percentage of the ebs volumes with the provided tag\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ebs-loss-by-tag-sa\n  experiments:\n  - name: ebs-loss-by-tag\n    spec:\n      components:\n        env:\n        # percentage of ebs volumes filter by tag\n        - name: VOLUME_AFFECTED_PERC\n          value: '100'\n        # tag of the ebs volume\n        - name: EBS_VOLUME_TAG\n          value: 'key:value'\n        # region for the ebs volume\n        - name: REGION\n          value: '&lt;region for EBS_VOLUME_TAG&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws/ec2-stop-by-id/","title":"EC2 Stop By ID","text":""},{"location":"experiments/categories/aws/ec2-stop-by-id/#introduction","title":"Introduction","text":"<ul> <li>It causes stopping of an EC2 instance by instance ID or list of instance IDs before bringing it back to running state after the specified chaos duration.</li> <li>It helps to check the performance of the application/process running on the ec2 instance. When the MANAGED_NODEGROUP is enable then the experiment will not try to start the instance post chaos instead it will check of the addition of the new node instance to the cluster.</li> </ul> <p>Scenario: Stop EC2 Instance</p> <p></p>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>ec2-stop-by-id</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient AWS access to stop and start an ec2 instance. </li> <li> <p>Ensure to create a Kubernetes secret having the AWS access configuration(key) in the <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  cloud_config.yml: |-\n    # Add the cloud AWS credentials respectively\n    [default]\n    aws_access_key_id = XXXXXXXXXXXXXXXXXXX\n    aws_secret_access_key = XXXXXXXXXXXXXXX\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>cloud_config.yml</code>) please also update the <code>AWS_SHARED_CREDENTIALS_FILE</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#warning","title":"WARNING","text":"<p>If the target EC2 instance is a part of a self-managed nodegroup: Make sure to drain the target node if any application is running on it and also ensure to cordon the target node before running the experiment so that the experiment pods do not schedule on it. </p>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>EC2 instance should be in healthy state.</li> </ul>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ec2-stop-by-id-sa\n  namespace: default\n  labels:\n    name: ec2-stop-by-id-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: ec2-stop-by-id-sa\n  labels:\n    name: ec2-stop-by-id-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: ec2-stop-by-id-sa\n  labels:\n    name: ec2-stop-by-id-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: ec2-stop-by-id-sa\nsubjects:\n- kind: ServiceAccount\n  name: ec2-stop-by-id-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   EC2_INSTANCE_ID   Instance ID of the target ec2 instance. Multiple IDs can also be provided as a comma(,) separated values  Multiple IDs can be provided as <code>id1,id2</code>  REGION   The region name of the target instace </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive instance stop.  Defaults to 30s   MANAGED_NODEGROUP   Set to <code>enable</code> if the target instance is the part of self-managed nodegroups   Defaults to <code>disable</code>  SEQUENCE   It defines sequence of chaos execution for multiple instance  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/aws/ec2-stop-by-id/#common-and-aws-specific-tunables","title":"Common and AWS specific tunables","text":"<p>Refer the common attributes and AWS specific tunable to tune the common tunables for all experiments and aws specific tunables.  </p>"},{"location":"experiments/categories/aws/ec2-stop-by-id/#stop-instances-by-id","title":"Stop Instances By ID","text":"<p>It contains comma separated list of instances IDs subjected to ec2 stop chaos. It can be tuned via <code>EC2_INSTANCE_ID</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># contains the instance id to be stopped\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ec2-stop-by-id-sa\n  experiments:\n  - name: ec2-stop-by-id\n    spec:\n      components:\n        env:\n        # id of the ec2 instance\n        - name: EC2_INSTANCE_ID\n          value: 'instance-1'\n        # region for the ec2 instance\n        - name: REGION\n          value: '&lt;region for EC2_INSTANCE_ID&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/","title":"EC2 Stop By Tag","text":""},{"location":"experiments/categories/aws/ec2-stop-by-tag/#introduction","title":"Introduction","text":"<ul> <li>It causes stopping of an EC2 instance by tag before bringing it back to running state after the specified chaos duration.</li> <li>It helps to check the performance of the application/process running on the ec2 instance. When the MANAGED_NODEGROUP is enable then the experiment will not try to start the instance post chaos instead it will check of the addition of the new node instance to the cluster.</li> </ul> <p>Scenario: Stop EC2 Instance</p> <p></p>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>ec2-stop-by-tag</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient AWS access to stop and start an ec2 instance. </li> <li> <p>Ensure to create a Kubernetes secret having the AWS access configuration(key) in the <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  cloud_config.yml: |-\n    # Add the cloud AWS credentials respectively\n    [default]\n    aws_access_key_id = XXXXXXXXXXXXXXXXXXX\n    aws_secret_access_key = XXXXXXXXXXXXXXX\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>cloud_config.yml</code>) please also update the <code>AWS_SHARED_CREDENTIALS_FILE</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#warning","title":"WARNING","text":"<p>If the target EC2 instance is a part of a self-managed nodegroup: Make sure to drain the target node if any application is running on it and also ensure to cordon the target node before running the experiment so that the experiment pods do not schedule on it. </p>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>EC2 instance should be in healthy state.</li> </ul>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ec2-stop-by-tag-sa\n  namespace: default\n  labels:\n    name: ec2-stop-by-tag-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: ec2-stop-by-tag-sa\n  labels:\n    name: ec2-stop-by-tag-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: ec2-stop-by-tag-sa\n  labels:\n    name: ec2-stop-by-tag-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: ec2-stop-by-tag-sa\nsubjects:\n- kind: ServiceAccount\n  name: ec2-stop-by-tag-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   EC2_INSTANCE_TAG   Instance Tag to filter the target ec2 instance.  The <code>EC2_INSTANCE_TAG</code> should be provided as <code>key:value</code> ex: <code>team:devops</code>  REGION   The region name of the target instace </p> <p></p> <p>  Variables   Description   Notes   INSTANCE_AFFECTED_PERC   The Percentage of total ec2 instance to target   Defaults to 0 (corresponds to 1 instance), provide numeric value only   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive instance termination.  Defaults to 30s   MANAGED_NODEGROUP   Set to <code>enable</code> if the target instance is the part of self-managed nodegroups   Defaults to <code>disable</code>  SEQUENCE   It defines sequence of chaos execution for multiple instance  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/aws/ec2-stop-by-tag/#common-and-aws-specific-tunables","title":"Common and AWS specific tunables","text":"<p>Refer the common attributes and AWS specific tunable to tune the common tunables for all experiments and aws specific tunables.  </p>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#target-single-instance","title":"Target single instance","text":"<p>It will stop a random single ec2 instance with the given <code>EC2_INSTANCE_TAG</code> tag and the <code>REGION</code> region.</p> <p>Use the following example to tune this:</p> <pre><code># target the ec2 instances with matching tag\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ec2-terminate-by-tag-sa\n  experiments:\n  - name: ec2-stop-by-tag\n    spec:\n      components:\n        env:\n        # tag of the ec2 instance\n        - name: EC2_INSTANCE_TAG\n          value: 'key:value'\n        # region for the ec2 instance\n        - name: REGION\n          value: '&lt;region for instance&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws/ec2-stop-by-tag/#target-percent-of-instances","title":"Target Percent of instances","text":"<p>It will stop the <code>INSTANCE_AFFECTED_PERC</code> percentage of ec2 instances with the given <code>EC2_INSTANCE_TAG</code> tag and <code>REGION</code> region.</p> <p>Use the following example to tune this:</p> <pre><code># percentage of ec2 instances, needs to terminate with provided tags\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: ec2-stop-by-tag-sa\n  experiments:\n  - name: ec2-stop-by-tag\n    spec:\n      components:\n        env:\n        # percentage of ec2 instance filterd by tags \n        - name: INSTANCE_AFFECTED_PERC\n          value: '100'\n        # tag of the ec2 instance\n        - name: EC2_INSTANCE_TAG\n          value: 'key:value'\n        # region for the ec2 instance\n        - name: REGION\n          value: '&lt;region for instance&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/AWS-SSM-experiments-tunables/","title":"AWS SSM experiments tunables","text":"<p>It contains the aws-ssm specific experiment tunables.</p>"},{"location":"experiments/categories/aws-ssm/AWS-SSM-experiments-tunables/#cpu-cores","title":"CPU Cores","text":"<p>It stressed the <code>CPU_CORE</code> cpu cores of the <code>EC2_INSTANCE_ID</code> ec2 instance and <code>REGION</code> region for the <code>TOTAL_CHAOS_DURATION</code> duration.</p> <p>Use the following example to tune this:</p> <pre><code># provide the cpu cores to stress the ec2 instance\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-id-sa\n  experiments:\n  - name: aws-ssm-chaos-by-id\n    spec:\n      components:\n        env:\n        # cpu cores for the stress\n        - name: CPU_CORE\n          value: '1'\n        # id of the ec2 instance\n        - name: EC2_INSTANCE_ID\n          value: 'instance-01'\n        # region of the ec2 instance\n        - name: REGION\n          value: '&lt;region of the EC2_INSTANCE_ID&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/AWS-SSM-experiments-tunables/#memory-percentage","title":"Memory Percentage","text":"<p>It stressed the <code>MEMORY_PERCENTAGE</code> percentage of free space of the <code>EC2_INSTANCE_ID</code> ec2 instance and <code>REGION</code> region for the <code>TOTAL_CHAOS_DURATION</code> duration.</p> <p>Use the following example to tune this:</p> <pre><code># provide the memory pecentage to stress the instance memory\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-id-sa\n  experiments:\n  - name: aws-ssm-chaos-by-id\n    specEC2_INSTANCE_ID:\n      components:\n        env:\n        # memory percentage for the stress\n        - name: MEMORY_PERCENTAGE\n          value: '80'\n        # id of the ec2 instance\n        - name: EC2_INSTANCE_ID\n          value: 'instance-01'\n        # region of the ec2 instance\n        - name: REGION\n          value: '&lt;region of the EC2_INSTANCE_ID&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/AWS-SSM-experiments-tunables/#ssm-docs","title":"SSM Docs","text":"<p>It contains the details of the SSM docs i.e, <code>name, type, the format of ssm-docs</code>.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the details of the ssm document details\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-id-sa\n  experiments:\n  - name: aws-ssm-chaos-by-id\n    spec:\n      components:\n        env:\n        # name of the ssm docs\n        - name: DOCUMENT_NAME\n          value: 'AWS-SSM-Doc'\n        # format of the ssm docs\n        - name: DOCUMENT_FORMAT\n          value: 'YAML'\n        # type of the ssm docs\n        - name: DOCUMENT_TYPE\n          value: 'command'\n        # path of the ssm docs\n        - name: DOCUMENT_PATH\n          value: ''\n        # id of the ec2 instance\n        - name: EC2_INSTANCE_ID\n          value: 'instance-01'\n        # region of the ec2 instance\n        - name: REGION\n          value: '&lt;region of the EC2_INSTANCE_ID&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/AWS-SSM-experiments-tunables/#workers-count","title":"Workers Count","text":"<p>It contains the <code>NUMBER_OF_WORKERS</code> workers for the stress. </p> <p>Use the following example to tune this:</p> <pre><code># workers details used to stress the instance\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-id-sa\n  experiments:\n  - name: aws-ssm-chaos-by-id\n    specEC2_INSTANCE_ID:\n      components:\n        env:\n        # number of workers used for stress\n        - name: NUMBER_OF_WORKERS\n          value: '1'\n        # id of the ec2 instance\n        - name: EC2_INSTANCE_ID\n          value: 'instance-01'\n        # region of the ec2 instance\n        - name: REGION\n          value: '&lt;region of the EC2_INSTANCE_ID&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/AWS-SSM-experiments-tunables/#mutiple-iterations-of-chaos","title":"Mutiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-id-sa\n  experiments:\n  - name: aws-ssm-chaos-by-id\n    specEC2_INSTANCE_ID:\n      components:\n        env:\n        # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '15'\n        # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n        - name: CPU_CORE\n          value: '1'\n        - name: EC2_INSTANCE_ID\n          value: 'instance-01'\n        - name: REGION\n          value: '&lt;region of the EC2_INSTANCE_ID&gt;'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/","title":"AWS SSM Chaos By ID","text":""},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#introduction","title":"Introduction","text":"<ul> <li>AWS SSM Chaos By ID contains chaos to disrupt the state of infra resources. The experiment can induce chaos on AWS EC2 instance using Amazon SSM Run Command This is carried out by using SSM Docs that defines the actions performed by Systems Manager on your managed instances (having SSM agent installed) which let us perform chaos experiments on the instances.</li> <li>It causes chaos (like stress, network, disk or IO) on AWS EC2 instances with given instance ID(s) using SSM docs for a certain chaos duration.</li> <li>For the default execution the experiment uses SSM docs for stress-chaos while you can add your own SSM docs using configMap (.spec.definition.configMaps) in chaosexperiment CR.</li> <li>It tests deployment sanity (replica availability &amp; uninterrupted service) and recovery workflows of the target application pod(if provided).</li> </ul> <p>Scenario: AWS SSM Chaos</p> <p></p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>aws-ssm-chaos-by-id</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have the required AWS access and your target EC2 instances have attached an IAM instance profile. To know more checkout Systems Manager Docs.</li> <li> <p>Ensure to create a Kubernetes secret having the AWS access configuration(key) in the <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  cloud_config.yml: |-\n    # Add the cloud AWS credentials respectively\n    [default]\n    aws_access_key_id = XXXXXXXXXXXXXXXXXXX\n    aws_secret_access_key = XXXXXXXXXXXXXXX\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>cloud_config.yml</code>) please also update the <code>AWS_SHARED_CREDENTIALS_FILE</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>EC2 instance should be in healthy state.</li> </ul>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: aws-ssm-chaos-by-id-sa\n  namespace: default\n  labels:\n    name: aws-ssm-chaos-by-id-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: aws-ssm-chaos-by-id-sa\n  labels:\n    name: aws-ssm-chaos-by-id-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n# Create and monitor the experiment &amp; helper pods\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n# Performs CRUD operations on the events inside chaosengine and chaosresult\n- apiGroups: [\"\"]\n  resources: [\"events\"]\n  verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n# Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n- apiGroups: [\"\"]\n  resources: [\"secrets\",\"configmaps\"]\n  verbs: [\"get\",\"list\",]\n# Track and get the runner, experiment, and helper pods log \n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\",\"list\",\"watch\"]  \n# for creating and managing to execute comands inside target container\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"get\",\"list\",\"create\"]\n# for configuring and monitor the experiment job by the chaos-runner pod\n- apiGroups: [\"batch\"]\n  resources: [\"jobs\"]\n  verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n# for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n- apiGroups: [\"litmuschaos.io\"]\n  resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n  verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: aws-ssm-chaos-by-id-sa\n  labels:\n    name: aws-ssm-chaos-by-id-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: aws-ssm-chaos-by-id-sa\nsubjects:\n- kind: ServiceAccount\n  name: aws-ssm-chaos-by-id-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   EC2_INSTANCE_ID   Instance ID of the target ec2 instance. Multiple IDs can also be provided as a comma(,) separated values  Multiple IDs can be provided as <code>id1,id2</code>  REGION   The region name of the target instace </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive chaos injection  Defaults to 60s   AWS_SHARED_CREDENTIALS_FILE   Provide the path for aws secret credentials  Defaults to <code>/tmp/cloud_config.yml</code>  DOCUMENT_NAME   Provide the name of addded ssm docs (if not using the default docs)  Default to LitmusChaos-AWS-SSM-Doc  DOCUMENT_FORMAT   Provide the format of the ssm docs. It can be YAML or JSON  Defaults to <code>YAML</code>  DOCUMENT_TYPE   Provide the document type of added ssm docs (if not using the default docs)  Defaults to <code>Command</code>  DOCUMENT_PATH   Provide the document path if added using configmaps  Defaults to the litmus ssm docs path   INSTALL_DEPENDENCIES   Select to install dependencies used to run stress-ng with default docs. It can be either True or False  Defaults to True   NUMBER_OF_WORKERS   Provide the number of workers to run stress-chaos with default ssm docs  Defaults to 1   MEMORY_PERCENTAGE   Provide the memory consumption in percentage on the instance for default ssm docs  Defaults to 80   CPU_CORE   Provide the number of cpu cores to run stress-chaos on EC2 with default ssm docs  Defaults to 0. It means it'll consume all the available cpu cores on the instance   SEQUENCE   It defines sequence of chaos execution for multiple instance  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#common-and-aws-ssm-specific-tunables","title":"Common and AWS-SSM specific tunables","text":"<p>Refer the common attributes and AWS-SSM specific tunable to tune the common tunables for all experiments and aws-ssm specific tunables.  </p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-id/#stress-instances-by-id","title":"Stress Instances By ID","text":"<p>It contains comma separated list of instances IDs subjected to ec2 stop chaos. It can be tuned via <code>EC2_INSTANCE_ID</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-id-sa\n  experiments:\n  - name: aws-ssm-chaos-by-id\n    spec:\n      components:\n        env:\n        # comma separated list of ec2 instance id(s)\n        # all instances should belongs to the same region(REGION)\n        - name: EC2_INSTANCE_ID\n          value: 'instance-01,instance-02'\n        # region of the ec2 instance\n        - name: REGION\n          value: '&lt;region of the EC2_INSTANCE_ID&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/","title":"AWS SSM Chaos By Tag","text":""},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#introduction","title":"Introduction","text":"<ul> <li>AWS SSM Chaos By Tag contains chaos to disrupt the state of infra resources. The experiment can induce chaos on AWS EC2 instance using Amazon SSM Run Command This is carried out by using SSM Docs that defines the actions performed by Systems Manager on your managed instances (having SSM agent installed) which let you perform chaos experiments on the instances.</li> <li>It causes chaos (like stress, network, disk or IO) on AWS EC2 instances with given instance Tag using SSM docs for a certain chaos duration.</li> <li>For the default execution the experiment uses SSM docs for stress-chaos while you can add your own SSM docs using configMap (.spec.definition.configMaps) in ChaosExperiment CR.</li> <li>It tests deployment sanity (replica availability &amp; uninterrupted service) and recovery workflows of the target application pod(if provided).</li> </ul> <p>Scenario: AWS SSM Chaos</p> <p></p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>aws-ssm-chaos-by-tag</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have the required AWS access and your target EC2 instances have attached an IAM instance profile. To know more checkout Systems Manager Docs.</li> <li> <p>Ensure to create a Kubernetes secret having the AWS access configuration(key) in the <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  cloud_config.yml: |-\n    # Add the cloud AWS credentials respectively\n    [default]\n    aws_access_key_id = XXXXXXXXXXXXXXXXXXX\n    aws_secret_access_key = XXXXXXXXXXXXXXX\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>cloud_config.yml</code>) please also update the <code>AWS_SHARED_CREDENTIALS_FILE</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>EC2 instance should be in healthy state.</li> </ul>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: aws-ssm-chaos-by-tag-sa\n  namespace: default\n  labels:\n    name: aws-ssm-chaos-by-tag-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: aws-ssm-chaos-by-tag-sa\n  labels:\n    name: aws-ssm-chaos-by-tag-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n# Create and monitor the experiment &amp; helper pods\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n# Performs CRUD operations on the events inside chaosengine and chaosresult\n- apiGroups: [\"\"]\n  resources: [\"events\"]\n  verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n# Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n- apiGroups: [\"\"]\n  resources: [\"secrets\",\"configmaps\"]\n  verbs: [\"get\",\"list\",]\n# Track and get the runner, experiment, and helper pods log \n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\",\"list\",\"watch\"]  \n# for creating and managing to execute comands inside target container\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"get\",\"list\",\"create\"]\n# for configuring and monitor the experiment job by the chaos-runner pod\n- apiGroups: [\"batch\"]\n  resources: [\"jobs\"]\n  verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n# for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n- apiGroups: [\"litmuschaos.io\"]\n  resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n  verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: aws-ssm-chaos-by-tag-sa\n  labels:\n    name: aws-ssm-chaos-by-tag-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: aws-ssm-chaos-by-tag-sa\nsubjects:\n- kind: ServiceAccount\n  name: aws-ssm-chaos-by-tag-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   EC2_INSTANCE_TAG   Instance Tag to filter the target ec2 instance  The EC2_INSTANCE_TAG should be provided as <code>key:value</code> ex: <code>chaos:ssm</code>  REGION   The region name of the target instace </p> <p></p> <p>  Variables   Description   Notes   INSTANCE_AFFECTED_PERC   The Percentage of total ec2 instance to target   Defaults to 0 (corresponds to 1 instance), provide numeric value only   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive chaos injection  Defaults to 60s   AWS_SHARED_CREDENTIALS_FILE   Provide the path for aws secret credentials  Defaults to <code>/tmp/cloud_config.yml</code>  DOCUMENT_NAME   Provide the name of addded ssm docs (if not using the default docs)  Default to LitmusChaos-AWS-SSM-Doc  DOCUMENT_FORMAT   Provide the format of the ssm docs. It can be YAML or JSON  Defaults to <code>YAML</code>  DOCUMENT_TYPE   Provide the document type of added ssm docs (if not using the default docs)  Defaults to <code>Command</code>  DOCUMENT_PATH   Provide the document path if added using configmaps  Defaults to the litmus ssm docs path   INSTALL_DEPENDENCIES   Select to install dependencies used to run stress-ng with default docs. It can be either True or False  Defaults to True   NUMBER_OF_WORKERS   Provide the number of workers to run stress-chaos with default ssm docs  Defaults to 1   MEMORY_PERCENTAGE   Provide the memory consumption in percentage on the instance for default ssm docs  Defaults to 80   CPU_CORE   Provide the number of cpu cores to run stress-chaos on EC2 with default ssm docs  Defaults to 0. It means it'll consume all the available cpu cores on the instance   SEQUENCE   It defines sequence of chaos execution for multiple instance  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#common-and-aws-ssm-specific-tunables","title":"Common and AWS-SSM specific tunables","text":"<p>Refer the common attributes and AWS-SSM specific tunable to tune the common tunables for all experiments and aws-ssm specific tunables.  </p>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#target-single-instance","title":"Target single instance","text":"<p>It will stress a random single ec2 instance with the given <code>EC2_INSTANCE_TAG</code> tag and <code>REGION</code> region.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-tag-sa\n  experiments:\n  - name: aws-ssm-chaos-by-tag\n    spec:\n      components:\n        env:\n        # tag of the ec2 instances\n        - name: EC2_INSTANCE_TAG\n          value: 'key:value'\n        # region of the ec2 instance\n        - name: REGION\n          value: '&lt;region of the ec2 instances&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/aws-ssm/aws-ssm-chaos-by-tag/#target-percent-of-instances","title":"Target Percent of instances","text":"<p>It will stress the <code>INSTANCE_AFFECTED_PERC</code> percentage of ec2 instances with the given <code>EC2_INSTANCE_TAG</code> tag and <code>REGION</code> region.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: aws-ssm-chaos-by-tag-sa\n  experiments:\n  - name: aws-ssm-chaos-by-tag\n    spec:\n      components:\n        env:\n        # percentage of the ec2 instances filtered by tags\n        - name: INSTANCE_AFFECTED_PERC\n          value: '100'\n        # tag of the ec2 instances\n        - name: EC2_INSTANCE_TAG\n          value: 'key:value'\n        # region of the ec2 instance\n        - name: REGION\n          value: '&lt;region of the ec2 instances&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/azure/azure-disk-loss/","title":"Azure Disk Loss","text":""},{"location":"experiments/categories/azure/azure-disk-loss/#introduction","title":"Introduction","text":"<ul> <li>It causes detachment of virtual disk from an Azure instance before re-attaching it back to the instance after the specified chaos duration.</li> <li>It helps to check the performance of the application/process running on the instance.</li> </ul> <p>Scenario: Detach the virtual disk from instance</p> <p></p>"},{"location":"experiments/categories/azure/azure-disk-loss/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/azure/azure-disk-loss/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>azure-disk-loss</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient Azure access to detach and attach a disk. </li> <li>We will use azure  file-based authentication  to connect with the instance using azure GO SDK in the experiment. For generating auth file run <code>az ad sp create-for-rbac --sdk-auth &gt; azure.auth</code> Azure CLI command.</li> <li> <p>Ensure to create a Kubernetes secret having the auth file created in the step in <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  azure.auth: |-\n    {\n      \"clientId\": \"XXXXXXXXX\",\n      \"clientSecret\": \"XXXXXXXXX\",\n      \"subscriptionId\": \"XXXXXXXXX\",\n      \"tenantId\": \"XXXXXXXXX\",\n      \"activeDirectoryEndpointUrl\": \"XXXXXXXXX\",\n      \"resourceManagerEndpointUrl\": \"XXXXXXXXX\",\n      \"activeDirectoryGraphResourceId\": \"XXXXXXXXX\",\n      \"sqlManagementEndpointUrl\": \"XXXXXXXXX\",\n      \"galleryEndpointUrl\": \"XXXXXXXXX\",\n      \"managementEndpointUrl\": \"XXXXXXXXX\"\n    }\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>azure.auth</code>) please also update the <code>AZURE_AUTH_LOCATION</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/azure/azure-disk-loss/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Azure Disk should be connected to an instance.</li> </ul>"},{"location":"experiments/categories/azure/azure-disk-loss/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: azure-disk-loss-sa\n  namespace: default\n  labels:\n    name: azure-disk-loss-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: azure-disk-loss-sa\n  namespace: default\n  labels:\n    name: azure-disk-loss-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/azure/azure-disk-loss/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   VIRTUAL_DISK_NAMES   Name of virtual disks to target.  Provide comma separated names for multiple disks  RESOURCE_GROUP   The resource group of the target disk(s) </p> <p></p> <p>  Variables   Description   Notes   SCALE_SET   Whether disk is connected to Scale set instance  Accepts \"enable\"/\"disable\". Default is \"disable\"  TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive instance poweroff.  Defaults to 30s   SEQUENCE   It defines sequence of chaos execution for multiple instance  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/azure/azure-disk-loss/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/azure/azure-disk-loss/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the experiments.</p>"},{"location":"experiments/categories/azure/azure-disk-loss/#detach-virtual-disks-by-name","title":"Detach Virtual Disks By Name","text":"<p>It contains comma separated list of disk names subjected to disk loss chaos. It can be tuned via <code>VIRTUAL_DISK_NAMES</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># detach multiple azure disks by their names \napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: azure-disk-loss-sa\n  experiments:\n  - name: azure-disk-loss\n    spec:\n      components:\n        env:\n        # comma separated names of the azure disks attached to VMs\n        - name: VIRTUAL_DISK_NAMES\n          value: 'disk-01,disk-02'\n        # name of the resource group\n        - name: RESOURCE_GROUP\n          value: '&lt;resource group of VIRTUAL_DISK_NAMES&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/azure/azure-disk-loss/#detach-virtual-disks-attached-to-scale-set-instances-by-name","title":"Detach Virtual Disks Attached to Scale Set Instances By Name","text":"<p>It contains comma separated list of disk names attached to scale set instances subjected to disk loss chaos. It can be tuned via <code>VIRTUAL_DISK_NAMES</code> and <code>SCALE_SET</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># detach multiple azure disks attached to scale set VMs by their names\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: azure-disk-loss-sa\n  experiments:\n  - name: azure-disk-loss\n    spec:\n      components:\n        env:\n        # comma separated names of the azure disks attached to scaleset VMs\n        - name: VIRTUAL_DISK_NAMES\n          value: 'disk-01,disk-02'\n        # name of the resource group\n        - name: RESOURCE_GROUP\n          value: '&lt;resource group of VIRTUAL_DISK_NAMES&gt;'\n        # VM belongs to scaleset or not\n        - name: SCALE_SET\n          value: 'enable'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/azure/azure-disk-loss/#multiple-iterations-of-chaos","title":"Multiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: azure-disk-loss-sa\n  experiments:\n  - name: azure-disk-loss\n    spec:\n      components:\n        env:\n        # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '10'\n         # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n        - name: VIRTUAL_DISK_NAMES\n          value: 'disk-01,disk-02'\n        - name: RESOURCE_GROUP\n          value: '&lt;resource group of VIRTUAL_DISK_NAMES&gt;'\n</code></pre>"},{"location":"experiments/categories/azure/azure-instance-stop/","title":"Azure Instance Stop","text":""},{"location":"experiments/categories/azure/azure-instance-stop/#introduction","title":"Introduction","text":"<ul> <li>It causes PowerOff an Azure instance before bringing it back to running state after the specified chaos duration.</li> <li>It helps to check the performance of the application/process running on the instance.</li> </ul> <p>Scenario: Stop the azure instance</p> <p></p>"},{"location":"experiments/categories/azure/azure-instance-stop/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/azure/azure-instance-stop/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>azure-instance-stop</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient Azure access to stop and start the an instance. </li> <li>We will use azure  file-based authentication  to connect with the instance using azure GO SDK in the experiment. For generating auth file run <code>az ad sp create-for-rbac --sdk-auth &gt; azure.auth</code> Azure CLI command.</li> <li> <p>Ensure to create a Kubernetes secret having the auth file created in the step in <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  azure.auth: |-\n    {\n      \"clientId\": \"XXXXXXXXX\",\n      \"clientSecret\": \"XXXXXXXXX\",\n      \"subscriptionId\": \"XXXXXXXXX\",\n      \"tenantId\": \"XXXXXXXXX\",\n      \"activeDirectoryEndpointUrl\": \"XXXXXXXXX\",\n      \"resourceManagerEndpointUrl\": \"XXXXXXXXX\",\n      \"activeDirectoryGraphResourceId\": \"XXXXXXXXX\",\n      \"sqlManagementEndpointUrl\": \"XXXXXXXXX\",\n      \"galleryEndpointUrl\": \"XXXXXXXXX\",\n      \"managementEndpointUrl\": \"XXXXXXXXX\"\n    }\n</code></pre> </li> <li> <p>If you change the secret key name (from <code>azure.auth</code>) please also update the <code>AZURE_AUTH_LOCATION</code>  ENV value on <code>experiment.yaml</code>with the same name.</p> </li> </ul>"},{"location":"experiments/categories/azure/azure-instance-stop/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Azure instance should be in healthy state.</li> </ul>"},{"location":"experiments/categories/azure/azure-instance-stop/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: azure-instance-stop-sa\n  namespace: default\n  labels:\n    name: azure-instance-stop-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: azure-instance-stop-sa\n  labels:\n    name: azure-instance-stop-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: azure-instance-stop-sa\n  labels:\n    name: azure-instance-stop-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: azure-instance-stop-sa\nsubjects:\n- kind: ServiceAccount\n  name: azure-instance-stop-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/azure/azure-instance-stop/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   AZURE_INSTANCE_NAMES   Instance name of the target azure instance  For AKS nodes, the instance name is from the scale set section in Azure and not the node name from AKS node pool   RESOURCE_GROUP   The resource group of the target instance </p> <p></p> <p>  Variables   Description   Notes   SCALE_SET   Whether instance is part of Scale set  Accepts \"enable\"/\"disable\". Default is \"disable\"  TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive instance power off.  Defaults to 30s   SEQUENCE   It defines sequence of chaos execution for multiple instance  Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/azure/azure-instance-stop/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/azure/azure-instance-stop/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the experiments.</p>"},{"location":"experiments/categories/azure/azure-instance-stop/#stop-instances-by-name","title":"Stop Instances By Name","text":"<p>It contains comma separated list of instance names subjected to instance stop chaos. It can be tuned via <code>AZURE_INSTANCE_NAME</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## contains the azure instance details\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: azure-instance-stop-sa\n  experiments:\n  - name: azure-instance-stop\n    spec:\n      components:\n        env:\n        # comma separated list of azure instance names\n        - name: AZURE_INSTANCE_NAMES\n          value: 'instance-01,instance-02'\n        # name of the resource group\n        - name: RESOURCE_GROUP\n          value: '&lt;resource group of AZURE_INSTANCE_NAME&gt;'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/azure/azure-instance-stop/#stop-scale-set-instances","title":"Stop Scale Set Instances","text":"<p>It contains comma separated list of instance names subjected to instance stop chaos belonging to Scale Set or AKS. It can be tuned via <code>SCALE_SET</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## contains the azure instance details for scale set instances or AKS nodes\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: azure-instance-stop-sa\n  experiments:\n  - name: azure-instance-stop\n    spec:\n      components:\n        env:\n        # comma separated list of azure instance names\n        - name: AZURE_INSTANCE_NAMES\n          value: 'instance-01,instance-02'\n        # name of the resource group\n        - name: RESOURCE_GROUP\n          value: '&lt;resource group of Scale set&gt;'\n        # accepts enable/disable value. default is disable\n        - name: SCALE_SET\n          value: 'enable'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/azure/azure-instance-stop/#multiple-iterations-of-chaos","title":"Multiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: azure-instance-stop-sa\n  experiments:\n  - name: azure-instance-stop\n    spec:\n      components:\n        env:\n        # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '10'\n         # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n        - name: AZURE_INSTANCE_NAMES\n          value: 'instance-01,instance-02'\n        - name: RESOURCE_GROUP\n          value: '&lt;resource group of AZURE_INSTANCE_NAME&gt;'\n</code></pre>"},{"location":"experiments/categories/common/common-tunables-for-all-experiments/","title":"Common tunables for all experiments","text":"<p>It contains tunables, which are common for all the experiments. These tunables can be provided at <code>.spec.experiment[*].spec.components.env</code> in chaosengine.</p>"},{"location":"experiments/categories/common/common-tunables-for-all-experiments/#duration-of-the-chaos","title":"Duration of the chaos","text":"<p>It defines the total time duration of the chaos injection. It can be tuned with the <code>TOTAL_CHAOS_DURATION</code> ENV. It is provided in a unit of seconds.</p> <p>Use the following example to tune this:</p> <pre><code># define the total chaos duration\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/common/common-tunables-for-all-experiments/#ramp-time","title":"Ramp Time","text":"<p>It defines the period to wait before and after the injection of chaos. It can be tuned with the <code>RAMP_TIME</code> ENV. It is provided in a unit of seconds.</p> <p>Use the following example to tune this:</p> <pre><code># waits for the ramp time before and after injection of chaos \napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # waits for the time interval before and after injection of chaos\n        - name: RAMP_TIME\n          value: '10' # in seconds\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/common/common-tunables-for-all-experiments/#sequence-of-chaos-execution","title":"Sequence of chaos execution","text":"<p>It defines the sequence of the chaos execution in the case of multiple targets. It can be tuned with the <code>SEQUENCE</code> ENV. It supports the following modes:</p> <ul> <li><code>parallel</code>: The chaos is injected in all the targets at once.</li> <li><code>serial</code>: The chaos is injected in all the targets one by one. The default value of <code>SEQUENCE</code> is <code>parallel</code>.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># define the order of execution of chaos in case of multiple targets\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # define the sequence of execution of chaos in case of mutiple targets\n        # supports: serial, parallel. default: parallel\n        - name: SEQUENCE\n          value: 'parallel'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/common/common-tunables-for-all-experiments/#name-of-chaos-library","title":"Name of chaos library","text":"<p>It defines the name of the chaos library used for the chaos injection. It can be tuned with the <code>LIB</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># lib for the chaos injection\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # defines the name of the chaoslib used for the experiment\n        - name: LIB\n          value: 'litmus'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/common/common-tunables-for-all-experiments/#instance-id","title":"Instance ID","text":"<p>It defines a user-defined string that holds metadata/info about the current run/instance of chaos. Ex: 04-05-2020-9-00. This string is appended as a suffix in the chaosresult CR name. It can be tuned with <code>INSTANCE_ID</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># provide to append user-defined suffix in the end of chaosresult name\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # user-defined string appended as suffix in the chaosresult name\n        - name: INSTANCE_ID\n          value: '123'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/common/common-tunables-for-all-experiments/#image-used-by-the-helper-pod","title":"Image used by the helper pod","text":"<p>It defines the image, which is used to launch the helper pod, if applicable. It can be tuned with the <code>LIB_IMAGE</code> ENV. It is supported by [container-kill, network-experiments, stress-experiments, dns-experiments, disk-fill, kubelet-service-kill, docker-service-kill, node-restart] experiments.</p> <p>Use the following example to tune this:</p> <pre><code># it contains the lib image used for the helper pod\n# it support [container-kill, network-experiments, stress-experiments, dns-experiments, disk-fill,\n# kubelet-service-kill, docker-service-kill, node-restart] experiments\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: container-kill-sa\n  experiments:\n  - name: container-kill\n    spec:\n      components:\n        env:\n        # nane of the lib image\n        - name: LIB_IMAGE\n          value: 'litmuschaos/go-runner:latest'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/","title":"GCP VM Disk Loss By Label","text":""},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#introduction","title":"Introduction","text":"<ul> <li>It causes chaos to disrupt the state of GCP persistent disk volume filtered using a label by detaching it from its VM instance for a certain chaos duration.</li> </ul> <p>Scenario: detach the gcp disk</p> <p></p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.17</li> <li>Ensure that the Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>gcp-vm-disk-loss-by-label</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that your service account has an editor access or owner access for the GCP project.</li> <li>Ensure that the target disk volume is not a boot disk of any VM instance.</li> <li> <p>Ensure to create a Kubernetes secret having the GCP service account credentials in the default namespace. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  type: \n  project_id: \n  private_key_id: \n  private_key: \n  client_email: \n  client_id: \n  auth_uri: \n  token_uri: \n  auth_provider_x509_cert_url: \n  client_x509_cert_url: \n</code></pre> </li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>All the disk volumes having the target label are attached to their respective instances</li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: gcp-vm-disk-loss-by-label-sa\n  namespace: default\n  labels:\n    name: gcp-vm-disk-loss-by-label-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: gcp-vm-disk-loss-by-label-sa\n  labels:\n    name: gcp-vm-disk-loss-by-label-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: gcp-vm-disk-loss-by-label-sa\n  labels:\n    name: gcp-vm-disk-loss-by-label-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: gcp-vm-disk-loss-by-label-sa\nsubjects:\n- kind: ServiceAccount\n  name: gcp-vm-disk-loss-by-label-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   GCP_PROJECT_ID   The ID of the GCP Project of which the disk volumes are a part of   All the target disk volumes should belong to a single GCP Project   DISK_VOLUME_LABEL  Label of the targeted non-boot persistent disk volume  The <code>DISK_VOLUME_LABEL</code> should be provided as <code>key:value</code> or <code>key</code> if the corresponding value is empty ex: <code>disk:target-disk</code>  ZONES   The zone of target disk volumes   Only one zone can be provided i.e. all target disks should lie in the same zone  </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between the successive chaos iterations (sec)   Defaults to 30s   DISK_AFFECTED_PERC   The percentage of total disks filtered using the label to target   Defaults to 0 (corresponds to 1 disk), provide numeric value only   SEQUENCE   It defines sequence of chaos execution for multiple disks   Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the experiments.</p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#detach-volumes-by-label","title":"Detach Volumes By Label","text":"<p>It contains the label of disk volumes to be subjected to disk loss chaos. It will detach all the disks with the label <code>DISK_VOLUME_LABEL</code> in zone <code>ZONES</code> within the <code>GCP_PROJECT_ID</code> project.  It re-attaches the disk volume after waiting for the specified <code>TOTAL_CHAOS_DURATION</code> duration.</p> <p><code>NOTE:</code> The <code>DISK_VOLUME_LABEL</code> accepts only one label and <code>ZONES</code> also accepts only one zone name. Therefore, all the disks must lie in the same zone.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-disk-loss-by-label-sa\n  experiments:\n  - name: gcp-vm-disk-loss-by-label\n    spec:\n      components:\n        env:\n        - name: DISK_VOLUME_LABEL\n          value: 'disk:target-disk'\n\n        - name: ZONES\n          value: 'us-east1-b'\n\n        - name: GCP_PROJECT_ID\n          value: 'my-project-4513'\n\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss-by-label/#mutiple-iterations-of-chaos","title":"Mutiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-disk-loss-by-label-sa\n  experiments:\n  - name: gcp-vm-disk-loss-by-label\n    spec:\n      components:\n        env:\n        - name: CHAOS_INTERVAL\n          value: '15'\n\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n\n        - name: DISK_VOLUME_LABEL\n          value: 'disk:target-disk'\n\n        - name: ZONES\n          value: 'us-east1-b'\n\n        - name: GCP_PROJECT_ID\n          value: 'my-project-4513'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/","title":"GCP VM Disk Loss","text":""},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#introduction","title":"Introduction","text":"<ul> <li>It causes chaos to disrupt state of GCP persistent disk volume by detaching it from its VM instance for a certain chaos duration using the disk name.</li> </ul> <p>Scenario: detach the gcp disk</p> <p></p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>gcp-vm-disk-loss</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that your service account has an editor access or owner access for the GCP project.</li> <li>Ensure that the target disk volume is not a boot disk of any VM instance.</li> <li> <p>Ensure to create a Kubernetes secret having the GCP service account credentials in the default namespace. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  type: \n  project_id: \n  private_key_id: \n  private_key: \n  client_email: \n  client_id: \n  auth_uri: \n  token_uri: \n  auth_provider_x509_cert_url: \n  client_x509_cert_url: \n</code></pre> </li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Disk volumes are attached to their respective instances</li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: gcp-vm-disk-loss-sa\n  namespace: default\n  labels:\n    name: gcp-vm-disk-loss-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: gcp-vm-disk-loss-sa\n  labels:\n    name: gcp-vm-disk-loss-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: gcp-vm-disk-loss-sa\n  labels:\n    name: gcp-vm-disk-loss-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: gcp-vm-disk-loss-sa\nsubjects:\n- kind: ServiceAccount\n  name: gcp-vm-disk-loss-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   GCP_PROJECT_ID   The ID of the GCP Project of which the disk volumes are a part of   All the target disk volumes should belong to a single GCP Project   DISK_VOLUME_NAMES   Target non-boot persistent disk volume names  Multiple disk volume names can be provided as disk1,disk2,...   ZONES   The zones of respective target disk volumes   Provide the zone for every target disk name as zone1,zone2... in the respective order of <code>DISK_VOLUME_NAMES</code>  DEVICE_NAMES   The device names of respective target disk volumes   Provide the device name for every target disk name as deviceName1,deviceName2... in the respective order of <code>DISK_VOLUME_NAMES</code> </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between the successive chaos iterations (sec)   Defaults to 30s   SEQUENCE   It defines sequence of chaos execution for multiple disks   Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the experiments.</p>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#detach-volumes-by-names","title":"Detach Volumes By Names","text":"<p>It contains comma separated list of volume names subjected to disk loss chaos. It will detach all the disks with the given <code>DISK_VOLUME_NAMES</code> disk names and corresponding <code>ZONES</code> zone names and the <code>DEVICE_NAMES</code> device names in <code>GCP_PROJECT_ID</code> project.  It reattached the volume after waiting for the specified <code>TOTAL_CHAOS_DURATION</code> duration.</p> <p><code>NOTE:</code> The <code>DISK_VOLUME_NAMES</code> contains multiple comma-separated disk names. The comma-separated zone names should be provided in the same order as disk names.</p> <p>Use the following example to tune this:</p> <pre><code>## details of the gcp disk\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-disk-loss-sa\n  experiments:\n  - name: gcp-vm-disk-loss\n    spec:\n      components:\n        env:\n        # comma separated list of disk volume names\n        - name: DISK_VOLUME_NAMES\n          value: 'disk-01,disk-02'\n        # comma separated list of zone names corresponds to the DISK_VOLUME_NAMES\n        # it should be provided in same order of DISK_VOLUME_NAMES\n        - name: ZONES\n          value: 'zone-01,zone-02'\n        # comma separated list of device names corresponds to the DISK_VOLUME_NAMES\n        # it should be provided in same order of DISK_VOLUME_NAMES\n        - name: DEVICE_NAMES\n          value: 'device-01,device-02'\n        # gcp project id to which disk volume belongs\n        - name: GCP_PROJECT_ID\n          value: 'project-id'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-disk-loss/#mutiple-iterations-of-chaos","title":"Mutiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-disk-loss-sa\n  experiments:\n  - name: gcp-vm-disk-loss\n    spec:\n      components:\n        env:\n        # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '15'\n        # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n        - name: DISK_VOLUME_NAMES\n          value: 'disk-01,disk-02'\n        - name: ZONES\n          value: 'zone-01,zone-02'\n        - name: DEVICE_NAMES\n          value: 'device-01,device-02'\n        - name: GCP_PROJECT_ID\n          value: 'project-id'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/","title":"GCP VM Instance Stop By Label","text":""},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#introduction","title":"Introduction","text":"<ul> <li>It causes power-off of GCP VM instances filtered by a label before bringing it back to the running state after the specified chaos duration.</li> <li>It helps to check the performance of the application/process running on the VM instance.</li> <li>When the <code>MANAGED_INSTANCE_GROUP</code> is <code>enable</code> then the experiment will not try to start the instances post chaos, instead it will check the addition of new instances to the instance group.</li> </ul> <p>Scenario: stop the gcp vm</p> <p></p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>gcp-vm-instance-stop-by-label</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient GCP permissions to stop and start the GCP VM instances. </li> <li> <p>Ensure to create a Kubernetes secret having the GCP service account credentials in the default namespace. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  type: \n  project_id: \n  private_key_id: \n  private_key: \n  client_email: \n  client_id: \n  auth_uri: \n  token_uri: \n  auth_provider_x509_cert_url: \n  client_x509_cert_url: \n</code></pre> </li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>All the VM instances having the target label are in a healthy state</li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: gcp-vm-instance-stop-by-label-sa\n  namespace: default\n  labels:\n    name: gcp-vm-instance-stop-by-label-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: gcp-vm-instance-stop-by-label-sa\n  labels:\n    name: gcp-vm-instance-stop-by-label-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: gcp-vm-instance-stop-by-label-sa\n  labels:\n    name: gcp-vm-instance-stop-by-label-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: gcp-vm-instance-stop-by-label-sa\nsubjects:\n- kind: ServiceAccount\n  name: gcp-vm-instance-stop-by-label-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   GCP_PROJECT_ID   GCP project ID to which the VM instances belong   All the VM instances must belong to a single GCP project   INSTANCE_LABEL   Name of target VM instances   The <code>INSTANCE_LABEL</code> should be provided as <code>key:value</code> or <code>key</code> if the corresponding value is empty ex: <code>vm:target-vm</code>  ZONES   The zone of the target VM instances   Only one zone can be provided i.e. all target instances should lie in the same zone  </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive instance termination   Defaults to 30s   MANAGED_INSTANCE_GROUP   Set to <code>enable</code> if the target instance is the part of a managed instance group   Defaults to <code>disable</code>  INSTANCE_AFFECTED_PERC   The percentage of total VMs filtered using the label to target   Defaults to 0 (corresponds to 1 instance), provide numeric value only   SEQUENCE   It defines sequence of chaos execution for multiple instance   Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the experiments.</p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#target-gcp-instances","title":"Target GCP Instances","text":"<p>It will stop all the instances with filtered by the label <code>INSTANCE_LABEL</code> and corresponding <code>ZONES</code> zone in <code>GCP_PROJECT_ID</code> project. </p> <p><code>NOTE:</code> The <code>INSTANCE_LABEL</code> accepts only one label and <code>ZONES</code> also accepts only one zone name. Therefore, all the instances must lie in the same zone.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-instance-stop-by-label-sa\n  experiments:\n  - name: gcp-vm-instance-stop-by-label\n    spec:\n      components:\n        env:\n        - name: INSTANCE_LABEL\n          value: 'vm:target-vm'\n\n        - name: ZONES\n          value: 'us-east1-b'\n\n        - name: GCP_PROJECT_ID\n          value: 'my-project-4513'\n\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#manged-instance-group","title":"Manged Instance Group","text":"<p>If vm instances belong to a managed instance group then provide the <code>MANAGED_INSTANCE_GROUP</code> as <code>enable</code> else provided it as <code>disable</code>, which is the default value. </p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-instance-stop-by-label-sa\n  experiments:\n  - name: gcp-vm-instance-stop-by-label\n    spec:\n      components:\n        env:\n        - name: MANAGED_INSTANCE_GROUP\n          value: 'enable'\n\n        - name: INSTANCE_LABEL\n          value: 'vm:target-vm'\n\n        - name: ZONES\n          value: 'us-east1-b'\n\n        - name: GCP_PROJECT_ID\n          value: 'my-project-4513'\n\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop-by-label/#mutiple-iterations-of-chaos","title":"Mutiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-instance-stop-by-label-sa\n  experiments:\n  - name: gcp-vm-instance-stop-by-label\n    spec:\n      components:\n        env:\n        - name: CHAOS_INTERVAL\n          value: '15'\n\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n\n        - name: INSTANCE_LABEL\n          value: 'vm:target-vm'\n\n        - name: ZONES\n          value: 'us-east1-b'\n\n        - name: GCP_PROJECT_ID\n          value: 'my-project-4513'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/","title":"GCP VM Instance Stop","text":""},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#introduction","title":"Introduction","text":"<ul> <li>It causes power-off of a GCP VM instance by instance name or list of instance names before bringing it back to the running state after the specified chaos duration.</li> <li>It helps to check the performance of the application/process running on the VM instance.</li> <li>When the <code>MANAGED_INSTANCE_GROUP</code> is <code>enable</code> then the experiment will not try to start the instances post chaos, instead it will check the addition of new instances to the instance group.</li> </ul> <p>Scenario: stop the gcp vm</p> <p></p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>gcp-vm-instance-stop</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient GCP permissions to stop and start the GCP VM instances. </li> <li> <p>Ensure to create a Kubernetes secret having the GCP service account credentials in the default namespace. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  type: \n  project_id: \n  private_key_id: \n  private_key: \n  client_email: \n  client_id: \n  auth_uri: \n  token_uri: \n  auth_provider_x509_cert_url: \n  client_x509_cert_url: \n</code></pre> </li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>VM instance should be in healthy state.</li> </ul>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: gcp-vm-instance-stop-sa\n  namespace: default\n  labels:\n    name: gcp-vm-instance-stop-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: gcp-vm-instance-stop-sa\n  labels:\n    name: gcp-vm-instance-stop-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: gcp-vm-instance-stop-sa\n  labels:\n    name: gcp-vm-instance-stop-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: gcp-vm-instance-stop-sa\nsubjects:\n- kind: ServiceAccount\n  name: gcp-vm-instance-stop-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   GCP_PROJECT_ID   GCP project ID to which the VM instances belong   All the VM instances must belong to a single GCP project   VM_INSTANCE_NAMES   Name of target VM instances   Multiple instance names can be provided as instance1,instance2,...   ZONES   The zones of the target VM instances   Zone for every instance name has to be provided as zone1,zone2,... in the same order of <code>VM_INSTANCE_NAMES</code> </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive instance termination   Defaults to 30s   MANAGED_INSTANCE_GROUP   Set to <code>enable</code> if the target instance is the part of a managed instance group   Defaults to <code>disable</code>  SEQUENCE   It defines sequence of chaos execution for multiple instance   Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the experiments.</p>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#target-gcp-instances","title":"Target GCP Instances","text":"<p>It will stop all the instances with the given <code>VM_INSTANCE_NAMES</code> instance names and corresponding <code>ZONES</code> zone names in <code>GCP_PROJECT_ID</code> project. </p> <p><code>NOTE:</code> The <code>VM_INSTANCE_NAMES</code> contains multiple comma-separated vm instances. The comma-separated zone names should be provided in the same order as instance names.</p> <p>Use the following example to tune this:</p> <pre><code>## details of the gcp instance\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-instance-stop-sa\n  experiments:\n  - name: gcp-vm-instance-stop\n    spec:\n      components:\n        env:\n        # comma separated list of vm instance names\n        - name: VM_INSTANCE_NAMES\n          value: 'instance-01,instance-02'\n        # comma separated list of zone names corresponds to the VM_INSTANCE_NAMES\n        # it should be provided in same order of VM_INSTANCE_NAMES\n        - name: ZONES\n          value: 'zone-01,zone-02'\n        # gcp project id to which vm instance belongs\n        - name: GCP_PROJECT_ID\n          value: 'project-id'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#managed-instance-group","title":"Managed Instance Group","text":"<p>If vm instances belong to a managed instance group then provide the <code>MANAGED_INSTANCE_GROUP</code> as <code>enable</code> else provided it as <code>disable</code>, which is the default value. </p> <p>Use the following example to tune this:</p> <pre><code>## scale up and down to maintain the available instance counts\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-instance-stop-sa\n  experiments:\n  - name: gcp-vm-instance-stop\n    spec:\n      components:\n        env:\n        # tells if instances are part of managed instance group\n        # supports: enable, disable. default: disable\n        - name: MANAGED_INSTANCE_GROUP\n          value: 'enable'\n        # comma separated list of vm instance names\n        - name: VM_INSTANCE_NAMES\n          value: 'instance-01,instance-02'\n        # comma separated list of zone names corresponds to the VM_INSTANCE_NAMES\n        # it should be provided in same order of VM_INSTANCE_NAMES\n        - name: ZONES\n          value: 'zone-01,zone-02'\n        # gcp project id to which vm instance belongs\n        - name: GCP_PROJECT_ID\n          value: 'project-id'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/gcp/gcp-vm-instance-stop/#mutiple-iterations-of-chaos","title":"Mutiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: gcp-vm-instance-stop-sa\n  experiments:\n  - name: gcp-vm-instance-stop\n    spec:\n      components:\n        env:\n        # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '15'\n        # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n        - name: VM_INSTANCE_NAMES\n          value: 'instance-01,instance-02'\n        - name: ZONES\n          value: 'zone-01,zone-02'\n        - name: GCP_PROJECT_ID\n          value: 'project-id'\n</code></pre>"},{"location":"experiments/categories/load/k6-loadgen/","title":"k6 Load Generator","text":""},{"location":"experiments/categories/load/k6-loadgen/#introduction","title":"Introduction","text":"<p>k6 loadgen fault simulates load generation on the target hosts for a specific chaos duration. This fault: - Slows down or makes the target host unavailable due to heavy load. - Checks the performance of the application or process running on the instance. Support various types of load testing (ex. spike, smoke, stress)</p> <p>Scenario: Load generating with k6</p> <p></p>"},{"location":"experiments/categories/load/k6-loadgen/#uses","title":"Uses","text":"View the uses of the experiment <p>Introduction to k6 Load Chaos in LitmusChaos</p>"},{"location":"experiments/categories/load/k6-loadgen/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>). If not, install from here</li> <li>Ensure to create a Kubernetes secret having the JS script file in the <code>Chaos Infrastructure</code>'s namespace (<code>litmus</code> by default). The simplest way to create a secret object looks like this:         <pre><code>kubectl create secret generic k6-script \\\n    --from-file=&lt;&lt;script-path&gt;&gt; -n &lt;&lt;chaos_infrastructure_namespace&gt;&gt;\n</code></pre></li> </ul>"},{"location":"experiments/categories/load/k6-loadgen/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: k6-loadgen-sa\nnamespace: default\nlabels:\nname: k6-loadgen-sa\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: k6-loadgen-sa\nnamespace: default\nlabels:\nname: k6-loadgen-sa\nrules:\n- apiGroups: [\"\",\"litmuschaos.io\",\"batch\",\"apps\"]\n  resources: [\"pods\",\"configmaps\",\"jobs\",\"pods/exec\",\"pods/log\",\"events\",\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n  verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\",\"deletecollection\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: k6-loadgen-sa\nnamespace: default\nlabels:\nname: k6-loadgen-sa\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: k6-loadgen-sa\nsubjects:\n- kind: ServiceAccount\n  name: k6-loadgen-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/load/k6-loadgen/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description    Notes   TOTAL_CHAOS_DURATION    The time duration for chaos injection (seconds)   Defaults to 20s   CHAOS_INTERVAL    Time interval b/w two successive k6-loadgen (in sec)   If the CHAOS_INTERVAL is not provided it will take the default value of 10s   RAMP_TIME   Period to wait before injection of chaos in sec   LIB_IMAGE    LIB Image used to excute k6 engine   Defaults to <code>ghcr.io/grafana/k6-operator:latest-runner</code>  LIB_IMAGE_PULL_POLICY    LIB Image pull policy   Defaults to <code>Always</code>  SCRIPT_SECRET_NAME   Provide the k8s secret name of the JS script to run k6.   Default value: k6-script   SCRIPT_SECRET_KEY   Provide the key of the k8s secret named SCRIPT_SECRET_NAME   Default value: script.js  </p>"},{"location":"experiments/categories/load/k6-loadgen/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/load/k6-loadgen/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.  </p>"},{"location":"experiments/categories/load/k6-loadgen/#custom-k6-configuration","title":"Custom k6 configuration","text":"<p>You can add k6 options(ex hosts, thresholds) in the script <code>options</code> object. More details can be found here</p>"},{"location":"experiments/categories/load/k6-loadgen/#custom-secret-name-and-secret-key","title":"Custom Secret Name and Secret Key","text":"<p>You can provide the secret name and secret key of the JS script to be used for k6-loadgen. The secret should be created in the same namespace where the <code>chaos infrastructure</code> is created. For example, if the chaos infrastructure is created in the <code>litmus</code> namespace, then the secret should also be created in the <code>litmus</code> namespace. </p> <p>You can write a JS script like below. If you want to know more about the script, checkout this documentation.</p> <pre><code>import http from 'k6/http';\nimport { sleep } from 'k6';\nexport const options = {\n    vus: 100,\n    duration: '30s',\n};\nexport default function () {\n    http.get('http://&lt;&lt;target_domain_name&gt;&gt;/');\n    sleep(1);\n}\n</code></pre> <p>Then create a secret with the above script.</p> <pre><code>kubectl create secret generic custom-k6-script \\\n  --from-file=custom-script.js -n &lt;&lt;chaos_infrastructure_namespace&gt;&gt;\n</code></pre> <p>And If we want to use <code>custom-k6-script</code> secret and <code>custom-script.js</code> as the secret key, then the experiment tunable will look like this:</p> <pre><code>---\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: nginx-chaos\n  namespace: default\nspec:\n  engineState: 'active'\n  chaosServiceAccount: litmus-admin\n  experiments:\n    - name: k6-loadgen\n      spec:\n        components:\n          env:\n            # set chaos duration (in sec) as desired\n            - name: TOTAL_CHAOS_DURATION\n              value: \"30\"\n\n            # Interval between chaos injection in sec\n            - name: CHAOS_INTERVAL\n              value: \"30\"\n\n            # Period to wait before and after injection of chaos in sec\n            - name: RAMP_TIME\n              value: \"0\"\n\n            # Provide the secret name of the JS script\n            - name: SCRIPT_SECRET_NAME\n              value: \"custom-k6-script\"\n\n            # Provide the secret key of the JS script\n            - name: SCRIPT_SECRET_KEY\n              value: \"custom-script.js\"\n\n            # Provide the image name of the helper pod\n            - name: LIB_IMAGE\n              value: \"ghcr.io/grafana/k6-operator:latest-runner\"\n\n            # Provide the image pull policy of the helper pod\n            - name: LIB_IMAGE_PULL_POLICY\n              value: \"Always\"\n</code></pre>"},{"location":"experiments/categories/nodes/common-tunables-for-node-experiments/","title":"Common tunables for node experiments","text":"<p>It contains tunables, which are common for all the node experiments. These tunables can be provided at <code>.spec.experiment[*].spec.components.env</code> in chaosengine.</p>"},{"location":"experiments/categories/nodes/common-tunables-for-node-experiments/#target-single-node","title":"Target Single Node","text":"<p>It defines the name of the target node subjected to chaos. The target node can be tuned via <code>TARGET_NODE</code> ENV. It contains only a single node name. <code>NOTE</code>: It is supported by [node-drain, node-taint, node-restart, kubelet-service-kill, docker-service-kill] experiments. </p> <p>Use the following example to tune this:</p> <pre><code>## provide the target node name\n## it is applicable for the [node-drain, node-taint, node-restart, kubelet-service-kill, docker-service-kill]\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-drain-sa\n  experiments:\n  - name: node-drain\n    spec:\n      components:\n        env:\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/common-tunables-for-node-experiments/#target-multiple-nodes","title":"Target Multiple Nodes","text":"<p>It defines the comma-separated name of the target nodes subjected to chaos. The target nodes can be tuned via <code>TARGET_NODES</code> ENV. <code>NOTE</code>: It is supported by [node-cpu-hog, node-memory-hog, node-io-stress] experiments</p> <p>Use the following example to tune this:</p> <pre><code>## provide the comma separated target node names\n## it is applicable for the [node-cpu-hog, node-memory-hog, node-io-stress]\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-cpu-hog-sa\n  experiments:\n  - name: node-cpu-hog\n    spec:\n      components:\n        env:\n        # comma separated target node names\n        - name: TARGET_NODES\n          value: 'node01,node02'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/common-tunables-for-node-experiments/#target-nodes-with-labels","title":"Target Nodes With Labels","text":"<p>It defines the labels of the targeted node(s) subjected to chaos. The node labels can be tuned via <code>NODE_LABEL</code> ENV.  It is mutually exclusive with the <code>TARGET_NODE(S)</code> ENV. If <code>TARGET_NODE(S)</code> ENV is set then it will use the nodes provided inside it otherwise, it will derive the node name(s) with matching node labels.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the labels of the targeted nodes\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-cpu-hog-sa\n  experiments:\n  - name: node-cpu-hog\n    spec:\n      components:\n        env:\n        # labels of the targeted node\n        # it will derive the target nodes if TARGET_NODE(S) ENV is not set\n        - name: NODE_LABEL\n          value: 'key=value'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/common-tunables-for-node-experiments/#node-affected-percentage","title":"Node Affected Percentage","text":"<p>It defines the percentage of nodes subjected to chaos with matching node labels. It can be tuned with <code>NODES_AFFECTED_PERC</code> ENV. If <code>NODES_AFFECTED_PERC</code> is provided as <code>empty</code> or <code>0</code> then it will target a minimum of one node. It is supported by [node-cpu-hog, node-memory-hog, node-io-stress] experiments. The rest of the experiment selects only a single node for the chaos.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the percentage of nodes to be targeted with matching labels\n## it is applicable for the [node-cpu-hog, node-memory-hog, node-io-stress]\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-cpu-hog-sa\n  experiments:\n  - name: node-cpu-hog\n    spec:\n      components:\n        env:\n        # percentage of nodes to be targeted with matching node labels\n        - name: NODES_AFFECTED_PERC\n          value: '100'\n        # labels of the targeted node\n        # it will derive the target nodes if TARGET_NODE(S) ENV is not set\n        - name: NODE_LABEL\n          value: 'key=value'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/docker-service-kill/","title":"Docker Service Kill","text":""},{"location":"experiments/categories/nodes/docker-service-kill/#introduction","title":"Introduction","text":"<ul> <li>This experiment Causes the application to become unreachable on account of node turning unschedulable (NotReady) due to docker service kill</li> <li>The docker service has been stopped/killed on a node to make it unschedulable for a certain duration i.e TOTAL_CHAOS_DURATION. The application node should be healthy after the chaos injection and the services should be reaccessable.</li> <li>The application implies services. Can be reframed as: Test application resiliency upon replica getting unreachable caused due to docker service down.</li> </ul> <p>Scenario: Kill the docker service of the node</p> <p></p>"},{"location":"experiments/categories/nodes/docker-service-kill/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/docker-service-kill/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>docker-service-kill</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that the node specified in the experiment ENV variable <code>TARGET_NODE</code> (the node for which docker service need to be killed) should be cordoned before execution of the chaos experiment (before applying the chaosengine manifest) to ensure that the litmus experiment runner pods are not scheduled on it / subjected to eviction. This can be achieved with the following steps:<ul> <li>Get node names against the applications pods: <code>kubectl get pods -o wide</code></li> <li>Cordon the node <code>kubectl cordon &lt;nodename&gt;</code></li> </ul> </li> </ul>"},{"location":"experiments/categories/nodes/docker-service-kill/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/docker-service-kill/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: docker-service-kill-sa\n  namespace: default\n  labels:\n    name: docker-service-kill-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: docker-service-kill-sa\n  labels:\n    name: docker-service-kill-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: docker-service-kill-sa\n  labels:\n    name: docker-service-kill-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: docker-service-kill-sa\nsubjects:\n- kind: ServiceAccount\n  name: docker-service-kill-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/docker-service-kill/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODE   Name of the target node  NODE_LABEL   It contains node label, which will be used to filter the target node if TARGET_NODE ENV is not set  It is mutually exclusive with the TARGET_NODE ENV. If both are provided then it will use the TARGET_NODE </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Defaults to 60s   LIB    The chaos lib used to inject the chaos   Defaults to <code>litmus</code>  RAMP_TIME   Period to wait before injection of chaos in sec  </p>"},{"location":"experiments/categories/nodes/docker-service-kill/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/docker-service-kill/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/docker-service-kill/#kill-docker-service","title":"Kill Docker Service","text":"<p>It contains name of target node subjected to the chaos. It can be tuned via <code>TARGET_NODE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># kill the docker service of the target node\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: docker-service-kill-sa\n  experiments:\n  - name: docker-service-kill\n    spec:\n      components:\n        env:\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/kubelet-service-kill/","title":"Kubelet Service Kill","text":""},{"location":"experiments/categories/nodes/kubelet-service-kill/#introduction","title":"Introduction","text":"<ul> <li>This experiment Causes the application to become unreachable on account of node turning unschedulable (NotReady) due to kubelet service kill.</li> <li>The kubelet service has been stopped/killed on a node to make it unschedulable for a certain duration i.e TOTAL_CHAOS_DURATION. The application node should be healthy after the chaos injection and the services should be reaccessable.</li> <li>The application implies services. Can be reframed as: Test application resiliency upon replica getting unreachable caused due to kubelet service down.</li> </ul> <p>Scenario: Kill the kubelet service of the node</p> <p></p>"},{"location":"experiments/categories/nodes/kubelet-service-kill/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/kubelet-service-kill/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>kubelet-service-kill</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that the node specified in the experiment ENV variable <code>TARGET_NODE</code> (the node for which kubelet service need to be killed) should be cordoned before execution of the chaos experiment (before applying the chaosengine manifest) to ensure that the litmus experiment runner pods are not scheduled on it / subjected to eviction. This can be achieved with the following steps:<ul> <li>Get node names against the applications pods: <code>kubectl get pods -o wide</code></li> <li>Cordon the node <code>kubectl cordon &lt;nodename&gt;</code></li> </ul> </li> </ul>"},{"location":"experiments/categories/nodes/kubelet-service-kill/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/kubelet-service-kill/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: kubelet-service-kill-sa\n  namespace: default\n  labels:\n    name: kubelet-service-kill-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: kubelet-service-kill-sa\n  labels:\n    name: kubelet-service-kill-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: kubelet-service-kill-sa\n  labels:\n    name: kubelet-service-kill-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: kubelet-service-kill-sa\nsubjects:\n- kind: ServiceAccount\n  name: kubelet-service-kill-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/kubelet-service-kill/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODE   Name of the target node  NODE_LABEL   It contains node label, which will be used to filter the target node if TARGET_NODE ENV is not set  It is mutually exclusive with the TARGET_NODE ENV. If both are provided then it will use the TARGET_NODE </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Defaults to 60s   LIB    The chaos lib used to inject the chaos   Defaults to <code>litmus</code>  LIB_IMAGE    The lib image used to inject kubelet kill chaos the image should have systemd installed in it.   Defaults to <code>ubuntu:16.04</code>  RAMP_TIME   Period to wait before injection of chaos in sec  </p>"},{"location":"experiments/categories/nodes/kubelet-service-kill/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/kubelet-service-kill/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/kubelet-service-kill/#kill-kubelet-service","title":"Kill Kubelet Service","text":"<p>It contains name of target node subjected to the chaos. It can be tuned via <code>TARGET_NODE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># kill the kubelet service of the target node\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: kubelet-service-kill-sa\n  experiments:\n  - name: kubelet-service-kill\n    spec:\n      components:\n        env:\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-cpu-hog/","title":"Node CPU Hog","text":""},{"location":"experiments/categories/nodes/node-cpu-hog/#introduction","title":"Introduction","text":"<ul> <li>This experiment causes CPU resource exhaustion on the Kubernetes node. The experiment aims to verify resiliency of applications whose replicas may be evicted on account on nodes turning unschedulable (Not Ready) due to lack of CPU resources.</li> <li>The CPU chaos is injected using a helper pod running the linux stress tool (a workload generator). The chaos is effected for a period equalling the TOTAL_CHAOS_DURATION Application implies services. Can be reframed as: Tests application resiliency upon replica evictions caused due to lack of CPU resources</li> </ul> <p>Scenario: Stress the CPU of node</p> <p></p>"},{"location":"experiments/categories/nodes/node-cpu-hog/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/node-cpu-hog/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>node-cpu-hog</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/nodes/node-cpu-hog/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/node-cpu-hog/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: node-cpu-hog-sa\n  namespace: default\n  labels:\n    name: node-cpu-hog-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: node-cpu-hog-sa\n  labels:\n    name: node-cpu-hog-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: node-cpu-hog-sa\n  labels:\n    name: node-cpu-hog-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: node-cpu-hog-sa\nsubjects:\n- kind: ServiceAccount\n  name: node-cpu-hog-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/node-cpu-hog/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODES   Comma separated list of nodes, subjected to node cpu hog chaos  NODE_LABEL   It contains node label, which will be used to filter the target nodes if TARGET_NODES ENV is not set  It is mutually exclusive with the TARGET_NODES ENV. If both are provided then it will use the TARGET_NODES </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Defaults to 60   LIB    The chaos lib used to inject the chaos   Defaults to <code>litmus</code>  LIB_IMAGE    Image used to run the stress command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before &amp; after injection of chaos in sec   Optional    NODE_CPU_CORE   Number of cores of node CPU to be consumed    Defaults to <code>2</code>  NODES_AFFECTED_PERC   The Percentage of total nodes to target    Defaults to 0 (corresponds to 1 node), provide numeric value only   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/nodes/node-cpu-hog/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/node-cpu-hog/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/node-cpu-hog/#node-cpu-cores","title":"Node CPU Cores","text":"<p>It contains number of cores of node CPU to be consumed. It can be tuned via <code>NODE_CPU_CORE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># stress the cpu of the targeted nodes\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-cpu-hog-sa\n  experiments:\n  - name: node-cpu-hog\n    spec:\n      components:\n        env:\n        # number of cpu cores to be stressed\n        - name: NODE_CPU_CORE\n          value: '2'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-cpu-hog/#node-cpu-load","title":"Node CPU Load","text":"<p>It contains percentage of node CPU to be consumed. It can be tuned via <code>CPU_LOAD</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># stress the cpu of the targeted nodes by load percentage\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-cpu-hog-sa\n  experiments:\n  - name: node-cpu-hog\n    spec:\n      components:\n        env:\n        # percentage of cpu to be stressed\n        - name: CPU_LOAD\n          value: \"100\"\n        # node cpu core should be provided as 0 for cpu load\n        # to work otherwise it will take cpu core as priority\n        - name: NODE_CPU_CORE\n          value: '0'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-drain/","title":"Node Drain","text":""},{"location":"experiments/categories/nodes/node-drain/#introduction","title":"Introduction","text":"<ul> <li>It drain the node. The resources which are running on the target node should be reschedule on the other nodes.</li> </ul> <p>Scenario: Drain the node</p> <p></p>"},{"location":"experiments/categories/nodes/node-drain/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/node-drain/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>node-drain</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that the node specified in the experiment ENV variable <code>TARGET_NODE</code> (the node which will be drained) should be cordoned before execution of the chaos experiment (before applying the chaosengine manifest) to ensure that the litmus experiment runner pods are not scheduled on it / subjected to eviction. This can be achieved with the following steps:<ul> <li>Get node names against the applications pods: <code>kubectl get pods -o wide</code></li> <li>Cordon the node <code>kubectl cordon &lt;nodename&gt;</code></li> </ul> </li> </ul>"},{"location":"experiments/categories/nodes/node-drain/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/node-drain/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: node-drain-sa\n  namespace: default\n  labels:\n    name: node-drain-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: node-drain-sa\n  labels:\n    name: node-drain-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n# Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\",\"pods/eviction\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # ignore daemonsets while draining the node\n  - apiGroups: [\"apps\"]\n    resources: [\"daemonsets\"]\n    verbs: [\"list\",\"get\",\"delete\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\",\"patch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: node-drain-sa\n  labels:\n    name: node-drain-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: node-drain-sa\nsubjects:\n- kind: ServiceAccount\n  name: node-drain-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/node-drain/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODE   Name of the node to be tainted  NODE_LABEL   It contains node label, which will be used to filter the target node if TARGET_NODE ENV is not set  It is mutually exclusive with the TARGET_NODE ENV. If both are provided then it will use the TARGET_NODE </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Defaults to 60s   LIB    The chaos lib used to inject the chaos   Defaults to <code>litmus</code>  RAMP_TIME   Period to wait before injection of chaos in sec  </p>"},{"location":"experiments/categories/nodes/node-drain/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/node-drain/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/node-drain/#drain-node","title":"Drain Node","text":"<p>It contains name of target node subjected to the chaos. It can be tuned via <code>TARGET_NODE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># drain the targeted node\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-drain-sa\n  experiments:\n  - name: node-drain\n    spec:\n      components:\n        env:\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-io-stress/","title":"Node IO Stress","text":""},{"location":"experiments/categories/nodes/node-io-stress/#introduction","title":"Introduction","text":"<ul> <li>This experiment causes io stress on the Kubernetes node. The experiment aims to verify the resiliency of applications that share this disk resource for ephemeral or persistent storage purposes.</li> <li>The amount of io stress can be either specifed as the size in percentage of the total free space on the file system or simply in Gigabytes(GB). When provided both it will execute with the utilization percentage specified and non of them are provided it will execute with default value of 10%.</li> <li>It tests application resiliency upon replica evictions caused due IO stress on the available Disk space.</li> </ul> <p>Scenario: Stress the IO of Node</p> <p></p>"},{"location":"experiments/categories/nodes/node-io-stress/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/node-io-stress/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>node-io-stress</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/nodes/node-io-stress/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/node-io-stress/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: node-io-stress-sa\n  namespace: default\n  labels:\n    name: node-io-stress-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: node-io-stress-sa\n  labels:\n    name: node-io-stress-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: node-io-stress-sa\n  labels:\n    name: node-io-stress-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: node-io-stress-sa\nsubjects:\n- kind: ServiceAccount\n  name: node-io-stress-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/node-io-stress/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODES   Comma separated list of nodes, subjected to node io stress chaos  NODE_LABEL   It contains node label, which will be used to filter the target nodes if TARGET_NODES ENV is not set  It is mutually exclusive with the TARGET_NODES ENV. If both are provided then it will use the TARGET_NODES </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos (seconds)   Default to 120   FILESYSTEM_UTILIZATION_PERCENTAGE   Specify the size as percentage of free space on the file system    Default to 10%  FILESYSTEM_UTILIZATION_BYTES   Specify the size in GigaBytes(GB).  <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> &amp; <code>FILESYSTEM_UTILIZATION_BYTES</code> are mutually exclusive. If both are provided, <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> is prioritized.   CPU   Number of core of CPU to be used   Default to 1   NUMBER_OF_WORKERS   It is the number of IO workers involved in IO disk stress   Default to 4   VM_WORKERS   It is the number vm workers involved in IO disk stress   Default to 1   LIB    The chaos lib used to inject the chaos   Default to <code>litmus</code>  LIB_IMAGE    Image used to run the stress command   Default to <code>litmuschaos/go-runner:latest<code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   NODES_AFFECTED_PERC   The Percentage of total nodes to target    Defaults to 0 (corresponds to 1 node), provide numeric value only   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel"},{"location":"experiments/categories/nodes/node-io-stress/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/node-io-stress/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/node-io-stress/#filesystem-utilization-percentage","title":"Filesystem Utilization Percentage","text":"<p>It stresses the <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> percentage of total free space available in the node. </p> <p>Use the following example to tune this:</p> <pre><code># stress the i/o of the targeted node with FILESYSTEM_UTILIZATION_PERCENTAGE of total free space \n# it is mutually exclusive with the FILESYSTEM_UTILIZATION_BYTES.\n# if both are provided then it will use FILESYSTEM_UTILIZATION_PERCENTAGE for stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-io-stress-sa\n  experiments:\n  - name: node-io-stress\n    spec:\n      components:\n        env:\n        # percentage of total free space of file system\n        - name: FILESYSTEM_UTILIZATION_PERCENTAGE\n          value: '10' # in percentage\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-io-stress/#filesystem-utilization-bytes","title":"Filesystem Utilization Bytes","text":"<p>It stresses the <code>FILESYSTEM_UTILIZATION_BYTES</code> GB of the i/o of the targeted node.  It is mutually exclusive with the <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> ENV. If <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> ENV is set then it will use the percentage for the stress otherwise, it will stress the i/o based on <code>FILESYSTEM_UTILIZATION_BYTES</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># stress the i/o of the targeted node with given FILESYSTEM_UTILIZATION_BYTES\n# it is mutually exclusive with the FILESYSTEM_UTILIZATION_PERCENTAGE.\n# if both are provided then it will use FILESYSTEM_UTILIZATION_PERCENTAGE for stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-io-stress-sa\n  experiments:\n  - name: node-io-stress\n    spec:\n      components:\n        env:\n        # file system to be stress in GB\n        - name: FILESYSTEM_UTILIZATION_BYTES\n          value: '500' # in GB\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-io-stress/#limit-cpu-utilization","title":"Limit CPU Utilization","text":"<p>The CPU usage can be limit to <code>CPU</code> cpu while performing io stress. It can be tuned via <code>CPU</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># limit the cpu uses to the provided value while performing io stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-io-stress-sa\n  experiments:\n  - name: node-io-stress\n    spec:\n      components:\n        env:\n        # number of cpu cores to be stressed\n        - name: CPU\n          value: '1' \n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-io-stress/#workers-for-stress","title":"Workers For Stress","text":"<p>The i/o and VM workers count for the stress can be tuned with <code>NUMBER_OF_WORKERS</code> and <code>VM_WORKERS</code> ENV respectively. </p> <p>Use the following example to tune this:</p> <pre><code># define the workers count for the i/o and vm\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-io-stress-sa\n  experiments:\n  - name: node-io-stress\n    spec:\n      components:\n        env:\n        # total number of io workers involved in stress\n        - name: NUMBER_OF_WORKERS\n          value: '4' \n          # total number of vm workers involved in stress\n        - name: VM_WORKERS\n          value: '1'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-memory-hog/","title":"Node Memory Hog","text":""},{"location":"experiments/categories/nodes/node-memory-hog/#introduction","title":"Introduction","text":"<ul> <li>This experiment causes Memory resource exhaustion on the Kubernetes node. The experiment aims to verify resiliency of applications whose replicas may be evicted on account on nodes turning unschedulable (Not Ready) due to lack of Memory resources.</li> <li>The Memory chaos is injected using a helper pod running the linux stress-ng tool (a workload generator)- The chaos is effected for a period equalling the TOTAL_CHAOS_DURATION and upto MEMORY_CONSUMPTION_PERCENTAGE(out of 100) or MEMORY_CONSUMPTION_MEBIBYTES(in Mebibytes out of total available memory).</li> <li>Application implies services. Can be reframed as: Tests application resiliency upon replica evictions caused due to lack of Memory resources</li> </ul> <p>Scenario: Stress the memory of node</p> <p></p>"},{"location":"experiments/categories/nodes/node-memory-hog/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/node-memory-hog/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>node-memory-hog</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/nodes/node-memory-hog/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/node-memory-hog/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: node-memory-hog-sa\n  namespace: default\n  labels:\n    name: node-memory-hog-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: node-memory-hog-sa\n  labels:\n    name: node-memory-hog-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: node-memory-hog-sa\n  labels:\n    name: node-memory-hog-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: node-memory-hog-sa\nsubjects:\n- kind: ServiceAccount\n  name: node-memory-hog-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/node-memory-hog/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODES   Comma separated list of nodes, subjected to node memory hog chaos  NODE_LABEL   It contains node label, which will be used to filter the target nodes if TARGET_NODES ENV is not set  It is mutually exclusive with the TARGET_NODES ENV. If both are provided then it will use the TARGET_NODES </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (in seconds)   Optional   Defaults to 120   LIB    The chaos lib used to inject the chaos   Optional   Defaults to <code>litmus</code>  LIB_IMAGE    Image used to run the stress command   Optional    Defaults to <code>litmuschaos/go-runner:latest</code>  MEMORY_CONSUMPTION_PERCENTAGE   Percent of the total node memory capacity   Optional   Defaults to 30   MEMORY_CONSUMPTION_MEBIBYTES   The size in Mebibytes of total available memory. When using this we need to keep MEMORY_CONSUMPTION_PERCENTAGE empty as the percentage have more precedence  Optional   NUMBER_OF_WORKERS   It is the number of VM workers involved in IO disk stress   Optional    Default to 1   RAMP_TIME   Period to wait before and after injection of chaos in sec   Optional    NODES_AFFECTED_PERC   The Percentage of total nodes to target    Optional   Defaults to 0 (corresponds to 1 node), provide numeric value only   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/nodes/node-memory-hog/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/node-memory-hog/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/node-memory-hog/#memory-consumption-percentage","title":"Memory Consumption Percentage","text":"<p>It stresses the <code>MEMORY_CONSUMPTION_PERCENTAGE</code> percentage of total node capacity of the targeted node. </p> <p>Use the following example to tune this:</p> <pre><code># stress the memory of the targeted node with MEMORY_CONSUMPTION_PERCENTAGE of node capacity\n# it is mutually exclusive with the MEMORY_CONSUMPTION_MEBIBYTES.\n# if both are provided then it will use MEMORY_CONSUMPTION_PERCENTAGE for stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-memory-hog-sa\n  experiments:\n  - name: node-memory-hog\n    spec:\n      components:\n        env:\n        # percentage of total node capacity to be stressed\n        - name: MEMORY_CONSUMPTION_PERCENTAGE\n          value: '10' # in percentage\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-memory-hog/#memory-consumption-mebibytes","title":"Memory Consumption Mebibytes","text":"<p>It stresses the <code>MEMORY_CONSUMPTION_MEBIBYTES</code> MiBi of the memory of the targeted node.  It is mutually exclusive with the <code>MEMORY_CONSUMPTION_PERCENTAGE</code> ENV. If <code>MEMORY_CONSUMPTION_PERCENTAGE</code> ENV is set then it will use the percentage for the stress otherwise, it will stress the i/o based on <code>MEMORY_CONSUMPTION_MEBIBYTES</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># stress the memory of the targeted node with given MEMORY_CONSUMPTION_MEBIBYTES\n# it is mutually exclusive with the MEMORY_CONSUMPTION_PERCENTAGE.\n# if both are provided then it will use MEMORY_CONSUMPTION_PERCENTAGE for stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-memory-hog-sa\n  experiments:\n  - name: node-memory-hog\n    spec:\n      components:\n        env:\n        # node memory to be stressed\n        - name: MEMORY_CONSUMPTION_MEBIBYTES\n          value: '500' # in MiBi\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-memory-hog/#workers-for-stress","title":"Workers For Stress","text":"<p>The workers count for the stress can be tuned with <code>NUMBER_OF_WORKERS</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># provide for the workers count for the stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-memory-hog-sa\n  experiments:\n  - name: node-memory-hog\n    spec:\n      components:\n        env:\n        # total number of workers involved in stress\n        - name: NUMBER_OF_WORKERS\n          value: '1' \n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-restart/","title":"Node Restart","text":""},{"location":"experiments/categories/nodes/node-restart/#introduction","title":"Introduction","text":"<ul> <li>It causes chaos to disrupt state of node by restarting it.</li> <li>It tests deployment sanity (replica availability &amp; uninterrupted service) and recovery workflows of the application pod</li> </ul> <p>Scenario: Restart the node</p> <p></p>"},{"location":"experiments/categories/nodes/node-restart/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/node-restart/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>node-restart</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li> <p>Create a Kubernetes secret named <code>id-rsa</code> where the experiment will run, where its contents will be the private SSH key for <code>SSH_USER</code> used to connect to the node that hosts the target pod in the secret field <code>ssh-privatekey</code>. A sample secret is shown below:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: id-rsa\ntype: kubernetes.io/ssh-auth\nstringData:\n  ssh-privatekey: |-\n    # SSH private key for ssh contained here\n</code></pre> </li> </ul> <p>Creating the RSA key pair for remote SSH access should be a trivial exercise for those who are already familiar with an ssh client, which entails the following actions:</p> <ol> <li>Create a new key pair and store the keys in a file named <code>my-id-rsa-key</code> and <code>my-id-rsa-key.pub</code> for the private and public keys respectively:      <pre><code>ssh-keygen -f ~/my-id-rsa-key -t rsa -b 4096\n</code></pre></li> <li>For each node available, run this following command to copy the public key of <code>my-id-rsa-key</code>:     <pre><code>ssh-copy-id -i my-id-rsa-key user@node\n</code></pre></li> </ol> <p>For further details, please check this documentation. Once you have copied the public key to all nodes and created the secret described earlier, you are ready to start your experiment.</p>"},{"location":"experiments/categories/nodes/node-restart/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/node-restart/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: node-restart-sa\n  namespace: default\n  labels:\n    name: node-restart-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: node-restart-sa\n  labels:\n    name: node-restart-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\",\"secrets\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: node-restart-sa\n  labels:\n    name: node-restart-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: node-restart-sa\nsubjects:\n- kind: ServiceAccount\n  name: node-restart-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/node-restart/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODE   Name of target node, subjected to chaos. If not provided it will select the random node  NODE_LABEL   It contains node label, which will be used to filter the target node if TARGET_NODE ENV is not set  It is mutually exclusive with the TARGET_NODE ENV. If both are provided then it will use the TARGET_NODE </p> <p></p> <p>  Variables   Description   Notes   LIB_IMAGE    The image used to restart the node   Defaults to <code>litmuschaos/go-runner:latest</code>  SSH_USER    name of ssh user   Defaults to <code>root</code>  TARGET_NODE_IP   Internal IP of the target node, subjected to chaos. If not provided, the experiment will lookup the node IP of the <code>TARGET_NODE</code> node  Defaults to empty   REBOOT_COMMAND    Command used for reboot   Defaults to <code>sudo systemctl reboot</code>  TOTAL_CHAOS_DURATION   The time duration for chaos insertion (sec)   Defaults to 30s   RAMP_TIME   Period to wait before and after injection of chaos in sec   LIB    The chaos lib used to inject the chaos   Defaults to litmus supported litmus only  </p>"},{"location":"experiments/categories/nodes/node-restart/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/node-restart/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/node-restart/#reboot-command","title":"Reboot Command","text":"<p>It defines the command used to restart the targeted node. It can be tuned via <code>REBOOT_COMMAND</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># provide the reboot command\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-restart-sa\n  experiments:\n  - name: node-restart\n    spec:\n      components:\n        env:\n        # command used for the reboot\n        - name: REBOOT_COMMAND\n          value: 'sudo systemctl reboot'\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-restart/#ssh-user","title":"SSH User","text":"<p>It defines the name of the SSH user for the targeted node. It can be tuned via <code>SSH_USER</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># name of the ssh user used to ssh into targeted node\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-restart-sa\n  experiments:\n  - name: node-restart\n    spec:\n      components:\n        env:\n        # name of the ssh user\n        - name: SSH_USER\n          value: 'root'\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-restart/#target-node-internal-ip","title":"Target Node Internal IP","text":"<p>It defines the internal IP of the targeted node. It is an optional field, if internal IP is not provided then it will derive the internal IP of the targeted node. It can be tuned via <code>TARGET_NODE_IP</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># internal ip of the targeted node\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-restart-sa\n  experiments:\n  - name: node-restart\n    spec:\n      components:\n        env:\n        # internal ip of the targeted node\n        - name: TARGET_NODE_IP\n          value: '&lt;ip of node01&gt;'\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/nodes/node-taint/","title":"Node Taint","text":""},{"location":"experiments/categories/nodes/node-taint/#introduction","title":"Introduction","text":"<ul> <li>It taints the node to apply the desired effect. The resources which contains the correspoing tolerations can only bypass the taints.</li> </ul> <p>Scenario: Taint the node</p> <p></p>"},{"location":"experiments/categories/nodes/node-taint/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/nodes/node-taint/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>node-taint</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that the node specified in the experiment ENV variable <code>TARGET_NODE</code> (the node which will be tainted) should be cordoned before execution of the chaos experiment (before applying the chaosengine manifest) to ensure that the litmus experiment runner pods are not scheduled on it / subjected to eviction. This can be achieved with the following steps:<ul> <li>Get node names against the applications pods: <code>kubectl get pods -o wide</code></li> <li>Cordon the node <code>kubectl cordon &lt;nodename&gt;</code></li> </ul> </li> </ul>"},{"location":"experiments/categories/nodes/node-taint/#default-validations","title":"Default Validations","text":"View the default validations <p>The target nodes should be in ready state before and after chaos injection.</p>"},{"location":"experiments/categories/nodes/node-taint/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: node-taint-sa\n  namespace: default\n  labels:\n    name: node-taint-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: node-taint-sa\n  labels:\n    name: node-taint-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n# Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\",\"pods/eviction\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # ignore daemonsets while draining the node\n  - apiGroups: [\"apps\"]\n    resources: [\"daemonsets\"]\n    verbs: [\"list\",\"get\",\"delete\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n  # for experiment to perform node status checks\n  - apiGroups: [\"\"]\n    resources: [\"nodes\"]\n    verbs: [\"get\",\"list\",\"patch\",\"update\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: node-taint-sa\n  labels:\n    name: node-taint-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: node-taint-sa\nsubjects:\n- kind: ServiceAccount\n  name: node-taint-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/nodes/node-taint/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_NODE   Name of the node to be tainted  NODE_LABEL   It contains node label, which will be used to filter the target node if TARGET_NODE ENV is not set  It is mutually exclusive with the TARGET_NODE ENV. If both are provided then it will use the TARGET_NODE  TAINT_LABEL   Label and effect to be tainted on application node  </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Defaults to 60s   LIB    The chaos lib used to inject the chaos   Defaults to <code>litmus</code>  RAMP_TIME   Period to wait before injection of chaos in sec  </p>"},{"location":"experiments/categories/nodes/node-taint/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/nodes/node-taint/#common-and-node-specific-tunables","title":"Common and Node specific tunables","text":"<p>Refer the common attributes and Node specific tunable to tune the common tunables for all experiments and node specific tunables.  </p>"},{"location":"experiments/categories/nodes/node-taint/#taint-label","title":"Taint Label","text":"<p>It contains label and effect to be tainted on application node. It can be tuned via <code>TAINT_LABEL</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># node tainted with provided key and effect\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: node-taint-sa\n  experiments:\n  - name: node-taint\n    spec:\n      components:\n        env:\n        # label and effect to be tainted on the targeted node\n        - name: TAINT_LABEL\n          value: 'key=value:effect'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/common-tunables-for-pod-experiments/","title":"Common tunables for pod experiments","text":"<p>It contains tunables, which are common for all pod-level experiments. These tunables can be provided at <code>.spec.experiment[*].spec.components.env</code> in chaosengine.</p>"},{"location":"experiments/categories/pods/common-tunables-for-pod-experiments/#target-specific-pods","title":"Target Specific Pods","text":"<p>It defines the comma-separated name of the target pods subjected to chaos. The target pods can be tuned via <code>TARGET_PODS</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## it contains comma separated target pod names\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        ## comma separated target pod names\n        - name: TARGET_PODS\n          value: 'pod1,pod2'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/common-tunables-for-pod-experiments/#pod-affected-percentage","title":"Pod Affected Percentage","text":"<p>It defines the percentage of pods subjected to chaos with matching labels provided at <code>.spec.appinfo.applabel</code> inside chaosengine. It can be tuned with <code>PODS_AFFECTED_PERC</code> ENV. If <code>PODS_AFFECTED_PERC</code> is provided as <code>empty</code> or <code>0</code> then it will target a minimum of one pod.</p> <p>Use the following example to tune this:</p> <pre><code>## it contains percentage of application pods to be targeted with matching labels or names in the application namespace\n## supported for all pod-level experiment expect pod-autoscaler\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # percentage of application pods\n        - name: PODS_AFFECTED_PERC\n          value: '100'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/common-tunables-for-pod-experiments/#target-specific-container","title":"Target Specific Container","text":"<p>It defines the name of the targeted container subjected to chaos. It can be tuned via <code>TARGET_CONTAINER</code> ENV. If <code>TARGET_CONTAINER</code> is provided as empty then it will use the first container of the targeted pod.</p> <p>Use the following example to tune this:</p> <pre><code>## name of the target container\n## it will use first container as target container if TARGET_CONTAINER is provided as empty\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # name of the target container\n        - name: TARGET_CONTAINER\n          value: 'nginx'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/common-tunables-for-pod-experiments/#default-application-health-check","title":"Default Application Health Check","text":"<p>It defines the default application status checks as a tunable. It is helpful for the scenarios where you don\u2019t want to validate the application status as a mandatory check during pre &amp; post chaos. It can be tuned via <code>DEFAULT_APP_HEALTH_CHECK</code> ENV. If <code>DEFAULT_APP_HEALTH_CHECK</code> is not provided by default it is set to <code>true</code>.</p> <p>Use the following example to tune this:</p> <pre><code>## application status check as tunable\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        - name: DEFAULT_APP_HEALTH_CHECK\n          value: 'false'\n</code></pre>"},{"location":"experiments/categories/pods/common-tunables-for-pod-experiments/#node-label-filter-for-selecting-the-target-pods","title":"Node Label Filter For Selecting The Target Pods","text":"<p>It defines the target application pod selection from a specific node. It is helpful for the scenarios where you want to select the pods scheduled on specific nodes as chaos candidates considering the pod affected percentage. It can be tuned via <code>NODE_LABEL</code> ENV.</p> <p>NOTE: This feature requires having node-level permission or clusterrole service account for filtering pods on a specific node.</p> APP_LABEL TARGET_PODS NODE_LABEL SELECTED PODS Provided Provided Provided The target pods that are filtered from applabel and resides on node containing the given node label and also provided in TARGET_PODS env is selected Provided Not Provided Provided The pods that are filtered from applabel and resides on node containing the given node label is selected  Not Provided Provided Provided The target pods are selected that resides on node with given node label  Not Provided Not Provided Provided Invalid Not Provided Not Provided Not Provided Invalid <p>Use the following example to tune this:</p> <pre><code>## node label to filter target pods\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        - name: NODE_LABEL\n          value: 'kubernetes.io/hostname=worker-01'\n</code></pre>"},{"location":"experiments/categories/pods/container-kill/","title":"Container Kill","text":""},{"location":"experiments/categories/pods/container-kill/#introduction","title":"Introduction","text":"<ul> <li>It Causes container failure of specific/random replicas of an application resources.</li> <li>It tests deployment sanity (replica availability &amp; uninterrupted service) and recovery workflow of the application</li> <li>Good for testing recovery of pods having side-car containers</li> </ul> <p>Scenario: Kill target container</p> <p></p>"},{"location":"experiments/categories/pods/container-kill/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/container-kill/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>container-kill</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/container-kill/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/container-kill/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: container-kill-sa\n  namespace: default\n  labels:\n    name: container-kill-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: container-kill-sa\n  namespace: default\n  labels:\n    name: container-kill-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)  \n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: container-kill-sa\n  namespace: default\n  labels:\n    name: container-kill-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: container-kill-sa\nsubjects:\n- kind: ServiceAccount\n  name: container-kill-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/container-kill/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description    Notes   TARGET_CONTAINER    The name of container to be killed inside the pod   If the TARGET_CONTAINER is not provided it will delete the first container   CHAOS_INTERVAL    Time interval b/w two successive container kill (in sec)   If the CHAOS_INTERVAL is not provided it will take the default value of 10s   TOTAL_CHAOS_DURATION    The time duration for chaos injection (seconds)   Defaults to 20s   PODS_AFFECTED_PERC   The Percentage of total pods to target   Defaults to 0 (corresponds to 1 replica), provide numeric value only   TARGET_PODS   Comma separated list of application pod name subjected to container kill chaos  If not provided, it will select target pods randomly based on provided appLabels  LIB_IMAGE    LIB Image used to kill the container   Defaults to <code>litmuschaos/go-runner:latest</code>  LIB    The category of lib use to inject chaos   Default value: litmus, supported values: pumba and litmus   RAMP_TIME   Period to wait before injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel   SIGNAL   It contains termination signal used for container kill   Default value: SIGKILL   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  CONTAINER_RUNTIME    container runtime interface for the cluster   Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB  </p>"},{"location":"experiments/categories/pods/container-kill/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/container-kill/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.  </p>"},{"location":"experiments/categories/pods/container-kill/#kill-specific-container","title":"Kill Specific Container","text":"<p>It defines the name of the targeted container subjected to chaos. It can be tuned via <code>TARGET_CONTAINER</code> ENV. If <code>TARGET_CONTAINER</code> is provided as empty then it will use the first container of the targeted pod.</p> <pre><code># kill the specific target container\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: container-kill-sa\n  experiments:\n  - name: container-kill\n    spec:\n      components:\n        env:\n        # name of the target container\n        - name: TARGET_CONTAINER\n          value: 'nginx'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/container-kill/#multiple-iterations-of-chaos","title":"Multiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: container-kill-sa\n  experiments:\n  - name: container-kill\n    spec:\n      components:\n        env:\n        # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '15'\n        # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/container-kill/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path:</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: container-kill-sa\n  experiments:\n  - name: container-kill\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/container-kill/#signal-for-kill","title":"Signal For Kill","text":"<p>It defines the Linux signal passed while killing the container. It can be tuned via <code>SIGNAL</code> ENV. It defaults to the <code>SIGTERM</code>.</p> <pre><code># specific linux signal passed while kiiling container\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: container-kill-sa\n  experiments:\n  - name: container-kill\n    spec:\n      components:\n        env:\n        # signal passed while killing container\n        # defaults to SIGTERM\n        - name: SIGNAL\n          value: 'SIGKILL'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/container-kill/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>.</p> <pre><code># pumba chaoslib used to kill the container\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: container-kill-sa\n  experiments:\n  - name: container-kill\n    spec:\n      components:\n        env:\n        # name of the lib\n        # supoorts pumba and litmus\n        - name: LIB\n          value: 'pumba'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/disk-fill/","title":"Disk Fill","text":""},{"location":"experiments/categories/pods/disk-fill/#introduction","title":"Introduction","text":"<ul> <li>It causes Disk Stress by filling up the ephemeral storage of the pod on any given node.</li> <li>It causes the application pod to get evicted if the capacity filled exceeds the pod's ephemeral storage limit.</li> <li>It tests the Ephemeral Storage Limits, to ensure those parameters are sufficient.</li> <li>It tests the application's resiliency to disk stress/replica evictions.</li> </ul> <p>Scenario: Fill ephemeral-storage</p> <p></p>"},{"location":"experiments/categories/pods/disk-fill/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/disk-fill/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>disk-fill</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Appropriate Ephemeral Storage Requests and Limits should be set for the application before running the experiment. An example specification is shown below: <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: frontend\nspec:\n  containers:\n  - name: db\n    image: mysql\n    env:\n    - name: MYSQL_ROOT_PASSWORD\n      value: \"password\"\n    resources:\n      requests:\n        ephemeral-storage: \"2Gi\"\n      limits:\n        ephemeral-storage: \"4Gi\"\n  - name: wp\n    image: wordpress\n    resources:\n      requests:\n        ephemeral-storage: \"2Gi\"\n      limits:\n        ephemeral-storage: \"4Gi\"\n</code></pre></li> </ul>"},{"location":"experiments/categories/pods/disk-fill/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/disk-fill/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: disk-fill-sa\n  namespace: default\n  labels:\n    name: disk-fill-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: disk-fill-sa\n  namespace: default\n  labels:\n    name: disk-fill-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: disk-fill-sa\n  namespace: default\n  labels:\n    name: disk-fill-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: disk-fill-sa\nsubjects:\n- kind: ServiceAccount\n  name: disk-fill-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/disk-fill/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   FILL_PERCENTAGE   Percentage to fill the Ephemeral storage limit   Can be set to more than 100 also, to force evict the pod. The ephemeral-storage limits must be set in targeted pod to use this ENV.  EPHEMERAL_STORAGE_MEBIBYTES   Ephemeral storage which need to fill (unit: MiBi) It is mutually exclusive with the <code>FILL_PERCENTAGE</code> ENV. If both are provided then it will use the <code>FILL_PERCENTAGE</code> </p> <p></p> <p>  Variables   Description   Notes   TARGET_CONTAINER   Name of container which is subjected to disk-fill   If not provided, the first container in the targeted pod will be subject to chaos   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The time duration for chaos insertion (sec)   Defaults to 60s   TARGET_PODS   Comma separated list of application pod name subjected to disk fill chaos  If not provided, it will select target pods randomly based on provided appLabels  DATA_BLOCK_SIZE   It contains data block size used to fill the disk(in KB)  Defaults to 256, it supports unit as KB only  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB    The chaos lib used to inject the chaos   Defaults to <code>litmus</code> supported litmus only   LIB_IMAGE    The image used to fill the disk   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/disk-fill/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/disk-fill/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/disk-fill/#disk-fill-percentage","title":"Disk Fill Percentage","text":"<p>It fills the <code>FILL_PERCENTAGE</code> percentage of the ephemeral-storage limit specified at <code>resource.limits.ephemeral-storage</code> inside the target application.</p> <p>Use the following example to tune this:</p> <pre><code>## percentage of ephemeral storage limit specified at `resource.limits.ephemeral-storage` inside target application\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: disk-fill-sa\n  experiments:\n  - name: disk-fill\n    spec:\n      components:\n        env:\n        ## percentage of ephemeral storage limit, which needs to be filled\n        - name: FILL_PERCENTAGE\n          value: '80' # in percentage\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/disk-fill/#disk-fill-mebibytes","title":"Disk Fill Mebibytes","text":"<p>It fills the <code>EPHEMERAL_STORAGE_MEBIBYTES</code> MiBi of ephemeral storage of the targeted pod. It is mutually exclusive with the <code>FILL_PERCENTAGE</code> ENV. If <code>FILL_PERCENTAGE</code> ENV is set then it will use the percentage for the fill otherwise, it will fill the ephemeral storage based on <code>EPHEMERAL_STORAGE_MEBIBYTES</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># ephemeral storage which needs to fill in will application\n# if ephemeral-storage limits is not specified inside target application\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: disk-fill-sa\n  experiments:\n  - name: disk-fill\n    spec:\n      components:\n        env:\n        ## ephemeral storage size, which needs to be filled\n        - name: EPHEMERAL_STORAGE_MEBIBYTES\n          value: '256' #in MiBi\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/disk-fill/#data-block-size","title":"Data Block Size","text":"<p>It defines the size of the data block used to fill the ephemeral storage of the targeted pod. It can be tuned via <code>DATA_BLOCK_SIZE</code> ENV. Its unit is <code>KB</code>. The default value of <code>DATA_BLOCK_SIZE</code> is <code>256</code>.</p> <p>Use the following example to tune this:</p> <pre><code># size of the data block used to fill the disk\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: disk-fill-sa\n  experiments:\n  - name: disk-fill\n    spec:\n      components:\n        env:\n        ## size of data block used to fill the disk\n        - name: DATA_BLOCK_SIZE\n          value: '256' #in KB\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/disk-fill/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>containerd</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of containerd socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># path inside node/vm where containers are present\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: disk-fill-sa\n  experiments:\n  - name: disk-fill\n    spec:\n      components:\n        env:\n        # provide the name of container runtime, it supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # provide the socket file path\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-autoscaler/","title":"Pod Autoscaler","text":""},{"location":"experiments/categories/pods/pod-autoscaler/#introduction","title":"Introduction","text":"<ul> <li> <p>The experiment aims to check the ability of nodes to accommodate the number of replicas a given application pod.</p> </li> <li> <p>This experiment can be used for other scenarios as well, such as for checking the Node auto-scaling feature. For example, check if the pods are successfully rescheduled within a specified period in cases where the existing nodes are already running at the specified limits.</p> </li> </ul> <p>Scenario: Scale the replicas</p> <p></p>"},{"location":"experiments/categories/pods/pod-autoscaler/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-autoscaler/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-autoscaler</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-autoscaler/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-autoscaler/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-autoscaler-sa\n  namespace: default\n  labels:\n    name: pod-autoscaler-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: pod-autoscaler-sa\n  labels:\n    name: pod-autoscaler-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # performs CRUD operations on the deployments and statefulsets\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\"]\n    verbs: [\"list\",\"get\",\"patch\",\"update\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: pod-autoscaler-sa\n  labels:\n    name: pod-autoscaler-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: pod-autoscaler-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-autoscaler-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-autoscaler/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   REPLICA_COUNT    Number of replicas upto which we want to scale  <code>nil</code> </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The timeout for the chaos experiment (in seconds)   Defaults to 60   LIB   The chaos lib used to inject the chaos   Defaults to <code>litmus</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/pods/pod-autoscaler/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-autoscaler/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-autoscaler/#replica-counts","title":"Replica counts","text":"<p>It defines the number of replicas, which should be present in the targeted application during the chaos. It can be tuned via <code>REPLICA_COUNT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># provide the number of replicas \napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-autoscaler-sa\n  experiments:\n  - name: pod-autoscaler\n    spec:\n      components:\n        env:\n        # number of replica, needs to scale\n        - name: REPLICA_COUNT\n          value: '3'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/","title":"Pod CPU Hog Exec","text":""},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#introduction","title":"Introduction","text":"<ul> <li> <p>This experiment consumes the CPU resources of the application container</p> </li> <li> <p>It simulates conditions where app pods experience CPU spikes either due to expected/undesired processes thereby testing how the overall application stack behaves when this occurs.</p> </li> </ul> <p>Scenario: Stress the CPU</p> <p></p>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#uses","title":"Uses","text":"View the uses of the experiment <p>Disk Pressure or CPU hogs is another very common and frequent scenario we find in kubernetes applications that can result in the eviction of the application replica and impact its delivery. Such scenarios that can still occur despite whatever availability aids K8s provides. These problems are generally referred to as \"Noisy Neighbour\"  problems.</p> <p>Injecting a rogue process into a target container, we starve the main microservice process (typically pid 1) of the resources allocated to it (where limits are defined) causing slowness in application traffic or in other cases unrestrained use can cause node to exhaust resources leading to eviction of all pods.So this category of chaos experiment helps to build the immunity on the application undergoing any such stress scenario</p>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-cpu-hog-exec</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-cpu-hog-exec-sa\n  namespace: default\n  labels:\n    name: pod-cpu-hog-exec-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-cpu-hog-exec-sa\n  namespace: default\n  labels:\n    name: pod-cpu-hog-exec-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)  \n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-cpu-hog-exec-sa\n  namespace: default\n  labels:\n    name: pod-cpu-hog-exec-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-cpu-hog-exec-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-cpu-hog-exec-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CPU_CORES   Number of the cpu cores subjected to CPU stress    Default to 1   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Default to 60s   LIB    The chaos lib used to inject the chaos. Available libs are <code>litmus</code>  Default to <code>litmus</code>  TARGET_PODS   Comma separated list of application pod name subjected to pod cpu hog chaos  If not provided, it will select target pods randomly based on provided appLabels  TARGET_CONTAINER   Name of the target container under chaos   If not provided, it will select the first container of the target pod   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   CHAOS_INJECT_COMMAND   The command to inject the cpu chaos    Default to <code>md5sum /dev/zero</code>  CHAOS_KILL_COMMAND   The command to kill the chaos process  Default to <code>kill $(find /proc -name exe -lname '*/md5sum' 2&gt;&amp;1 | grep -v 'Permission denied' | awk -F/ '{print $(NF-1)}')</code>. Another useful one that generally works (in case the default doesn't) is <code>kill -9 $(ps afx | grep \"[md5sum] /dev/zero\" | awk '{print $1}' | tr '\\n' ' ')</code>. In case neither works, please check whether the target pod's base image offers a shell. If yes, identify appropriate shell command to kill the chaos process   RAMP_TIME   Period to wait before injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#cpu-cores","title":"CPU Cores","text":"<p>It stresses the <code>CPU_CORE</code> cpu cores of the targeted pod for the <code>TOTAL_CHAOS_DURATION</code> duration.</p> <p>Use the following example to tune this:</p> <pre><code># cpu cores for the stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-cpu-hog-exec-sa\n  experiments:\n  - name: pod-cpu-hog-exec\n    spec:\n      components:\n        env:\n        # cpu cores for stress\n        - name: CPU_CORES\n          value: '1'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-cpu-hog-exec/#chaos-inject-and-kill-commands","title":"Chaos Inject and Kill Commands","text":"<p>It defines the <code>CHAOS_INJECT_COMMAND</code> and <code>CHAOS_KILL_COMMAND</code> ENV to set the chaos inject and chaos kill commands respectively. Default values of commands:</p> <ul> <li><code>CHAOS_INJECT_COMMAND</code>: \"md5sum /dev/zero\"</li> <li><code>CHAOS_KILL_COMMAND</code>: \"kill $(find /proc -name exe -lname '*/md5sum' 2&gt;&amp;1 | grep -v 'Permission denied' | awk -F/ '{print $(NF-1)}')\"</li> </ul> <p>Use the following example to tune this:</p> <pre><code># provide the chaos kill, used to kill the chaos process\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-cpu-hog-exec-sa\n  experiments:\n  - name: pod-cpu-hog-exec\n    spec:\n      components:\n        env:\n        # command to create the md5sum process to stress the cpu\n        - name: CHAOS_INJECT_COMMAND\n          value: 'md5sum /dev/zero'\n        # command to kill the md5sum process\n        # alternative command: \"kill -9 $(ps afx | grep \"[md5sum] /dev/zero\" | awk '{print $1}' | tr '\\n' ' ')\"\n        - name: CHAOS_KILL_COMMAND\n          value: \"kill $(find /proc -name exe -lname '*/md5sum' 2&gt;&amp;1 | grep -v 'Permission denied' | awk -F/ '{print $(NF-1)}')\"\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-cpu-hog/","title":"Pod CPU Hog","text":""},{"location":"experiments/categories/pods/pod-cpu-hog/#introduction","title":"Introduction","text":"<ul> <li>This experiment consumes the CPU resources of the application container</li> <li>It simulates conditions where app pods experience CPU spikes either due to expected/undesired processes thereby testing how the overall application stack behaves when this occurs.</li> <li>It can test the application's resilience to potential slowness/unavailability of some replicas due to high CPU load</li> </ul> <p>Scenario: Stress the CPU</p> <p></p>"},{"location":"experiments/categories/pods/pod-cpu-hog/#uses","title":"Uses","text":"View the uses of the experiment <p>Disk Pressure or CPU hogs is another very common and frequent scenario we find in kubernetes applications that can result in the eviction of the application replica and impact its delivery. Such scenarios that can still occur despite whatever availability aids K8s provides. These problems are generally referred to as \"Noisy Neighbour\" problems.</p> <p>Injecting a rogue process into a target container, we starve the main microservice process (typically pid 1) of the resources allocated to it (where limits are defined) causing slowness in application traffic or in other cases unrestrained use can cause node to exhaust resources leading to eviction of all pods.So this category of chaos experiment helps to build the immunity on the application undergoing any such stress scenario</p>"},{"location":"experiments/categories/pods/pod-cpu-hog/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-cpu-hog</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-cpu-hog/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-cpu-hog/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-cpu-hog-sa\n  namespace: default\n  labels:\n    name: pod-cpu-hog-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-cpu-hog-sa\n  namespace: default\n  labels:\n    name: pod-cpu-hog-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)  \n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-cpu-hog-sa\n  namespace: default\n  labels:\n    name: pod-cpu-hog-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-cpu-hog-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-cpu-hog-sa\n  namespace: default\n</code></pre> <p>Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-cpu-hog/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CPU_CORES   Number of the cpu cores subjected to CPU stress    Default to 1   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Default to 60s   LIB    The chaos lib used to inject the chaos. Available libs are <code>litmus</code> and <code>pumba</code>  Default to <code>litmus</code>  LIB_IMAGE    Image used to run the helper pod.   Defaults to <code>litmuschaos/go-runner:1.13.8<code>  STRESS_IMAGE    Container run on the node at runtime by the pumba lib to inject stressors. Only used in LIB <code>pumba</code>  Default to <code>alexeiled/stress-ng:latest-ubuntu</code>  TARGET_PODS   Comma separated list of application pod name subjected to pod cpu hog chaos  If not provided, it will select target pods randomly based on provided appLabels  TARGET_CONTAINER   Name of the target container under chaos   If not provided, it will select the first container of the target pod   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  RAMP_TIME   Period to wait before injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel"},{"location":"experiments/categories/pods/pod-cpu-hog/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-cpu-hog/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-cpu-hog/#cpu-cores","title":"CPU Cores","text":"<p>It stresses the <code>CPU_CORE</code> of the targeted pod for the <code>TOTAL_CHAOS_DURATION</code> duration.</p> <p>Use the following example to tune this:</p> <pre><code># cpu cores for the stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-cpu-hog-sa\n  experiments:\n  - name: pod-cpu-hog\n    spec:\n      components:\n        env:\n        # cpu cores for stress\n        - name: CPU_CORES\n          value: '1'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-cpu-hog/#cpu-load","title":"CPU Load","text":"<p>It contains percentage of pod CPU to be consumed. It can be tuned via <code>CPU_LOAD</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># cpu load for the stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-cpu-hog-sa\n  experiments:\n  - name: pod-cpu-hog\n    spec:\n      components:\n        env:\n        # cpu load in percentage for the stress\n        - name: CPU_LOAD\n          value: '100'\n        # cpu core should be provided as 0 for cpu load\n        # to work, otherwise it will take cpu core as priority\n        - name: CPU_CORES\n          value: '0'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-cpu-hog/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-cpu-hog-sa\n  experiments:\n  - name: pod-cpu-hog\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-cpu-hog/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>. Provide the stress image via <code>STRESS_IMAGE</code> ENV for the pumba library.</p> <p>Use the following example to tune this:</p> <pre><code># use pumba chaoslib for the stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-cpu-hog-sa\n  experiments:\n  - name: pod-cpu-hog\n    spec:\n      components:\n        env:\n        # name of chaos lib\n        # supports litmus and pumba\n        - name: LIB\n          value: 'pumba'\n        # stress image - applicable for pumba only\n        - name: STRESS_IMAGE\n          value: 'alexeiled/stress-ng:latest-ubuntu'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-delete/","title":"Pod Delete","text":""},{"location":"experiments/categories/pods/pod-delete/#introduction","title":"Introduction","text":"<ul> <li>It Causes (forced/graceful) pod failure of specific/random replicas of an application resources.</li> <li>It tests deployment sanity (replica availability &amp; uninterrupted service) and recovery workflow of the application</li> </ul> <p>Scenario: Deletes kubernetes pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-delete/#uses","title":"Uses","text":"View the uses of the experiment <p>In the distributed system like kubernetes it is very likely that your application replicas may not be sufficient to manage the traffic (indicated by SLIs) when some of the replicas are unavailable due to any failure (can be system or application) the application needs to meet the SLO(service level objectives) for this, we need to make sure that the applications have minimum number of available replicas. One of the common application failures is when the pressure on other replicas increases then to how the horizontal pod autoscaler scales based on observed resource utilization and also how much PV mount takes time upon rescheduling. The other important aspects to test are the MTTR for the application replica, re-elections of leader or follower like in kafka application the selection of broker leader, validating minimum quorum to run the application for example in applications like percona, resync/redistribution of data.</p> <p>This experiment helps to reproduce such a scenario with forced/graceful pod failure on specific or random replicas of an application resource and checks the deployment sanity (replica availability &amp; uninterrupted service) and recovery workflow of the application.</p>"},{"location":"experiments/categories/pods/pod-delete/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-delete</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-delete/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-delete/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-delete-sa\n  namespace: default\n  labels:\n    name: pod-delete-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-delete-sa\n  namespace: default\n  labels:\n    name: pod-delete-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)  \n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-delete-sa\n  namespace: default\n  labels:\n    name: pod-delete-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-delete-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-delete-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-delete/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (in sec)   Defaults to 15s, NOTE: Overall run duration of the experiment may exceed the TOTAL_CHAOS_DURATION by a few min   CHAOS_INTERVAL   Time interval b/w two successive pod failures (in sec)   Defaults to 5s   RANDOMNESS   Introduces randomness to pod deletions with a minimum period defined by CHAOS_INTERVAL   It supports true or false. Default value: false   FORCE    Application Pod deletion mode. <code>false</code> indicates graceful deletion with default termination period of 30s. <code>true</code> indicates an immediate forceful deletion with 0s grace period  Default to <code>true</code>, With <code>terminationGracePeriodSeconds=0</code>  TARGET_PODS   Comma separated list of application pod name subjected to pod delete chaos  If not provided, it will select target pods randomly based on provided appLabels  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-delete/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-delete/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-delete/#force-delete","title":"Force Delete","text":"<p>The targeted pod can be deleted <code>forcefully</code> or <code>gracefully</code>. It can be tuned with the <code>FORCE</code> env. It will delete the pod forcefully if <code>FORCE</code> is provided as <code>true</code> and it will delete the pod gracefully if <code>FORCE</code> is provided as <code>false</code>.</p> <p>Use the following example to tune this:</p> <pre><code># tune the deletion of target pods forcefully or gracefully\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # provided as true for the force deletion of pod\n        # supports true and false value\n        - name: FORCE\n          value: 'true'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-delete/#multiple-iterations-of-chaos","title":"Multiple Iterations Of Chaos","text":"<p>The multiple iterations of chaos can be tuned via setting <code>CHAOS_INTERVAL</code> ENV. Which defines the delay between each iteration of chaos.</p> <p>Use the following example to tune this:</p> <pre><code># defines delay between each successive iteration of the chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # delay between each iteration of chaos\n        - name: CHAOS_INTERVAL\n          value: '15'\n        # time duration for the chaos execution\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-delete/#random-interval","title":"Random Interval","text":"<p>The randomness in the chaos interval can be enabled via setting <code>RANDOMNESS</code> ENV to <code>true</code>. It supports boolean values. The default value is <code>false</code>. The chaos interval can be tuned via <code>CHAOS_INTERVAL</code> ENV. </p> <ul> <li>If <code>CHAOS_INTERVAL</code> is set in the form of <code>l-r</code> i.e, <code>5-10</code> then it will select a random interval between l &amp; r.</li> <li>If <code>CHAOS_INTERVAL</code> is set in the form of <code>value</code> i.e, <code>10</code> then it will select a random interval between 0 &amp; value.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains random chaos interval with lower and upper bound of range i.e [l,r]\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        env:\n        # randomness enables iterations at random time interval\n        # it supports true and false value\n        - name: RANDOMNESS\n          value: 'true'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n        # it will select a random interval within this range\n        # if only one value is provided then it will select a random interval within 0-CHAOS_INTERVAL range\n        - name: CHAOS_INTERVAL\n          value: '5-10' \n</code></pre>"},{"location":"experiments/categories/pods/pod-dns-error/","title":"Pod Dns Error","text":""},{"location":"experiments/categories/pods/pod-dns-error/#introduction","title":"Introduction","text":"<ul> <li>Pod-dns-error injects chaos to disrupt dns resolution in kubernetes pods.</li> <li>It causes loss of access to services by blocking dns resolution of hostnames/domains</li> </ul> <p>Scenario: DNS error for the target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-dns-error/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-dns-error/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-dns-error</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-dns-error/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-dns-error/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-dns-error-sa\n  namespace: default\n  labels:\n    name: pod-dns-error-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-dns-error-sa\n  namespace: default\n  labels:\n    name: pod-dns-error-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-dns-error-sa\n  namespace: default\n  labels:\n    name: pod-dns-error-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-dns-error-sa\nsubjects:\n  - kind: ServiceAccount\n    name: pod-dns-error-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-dns-error/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description    Notes   TARGET_CONTAINER    Name of container which is subjected to dns-error   None   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Default (60s)   TARGET_HOSTNAMES   List of the target hostnames or keywords eg. '[\"litmuschaos\"]'  If not provided, all hostnames/domains will be targeted  MATCH_SCHEME   Determines whether the dns query has to match exactly with one of the targets or can have any of the targets as substring. Can be either <code>exact</code> or <code>substring</code>  if not provided, it will be set as <code>exact</code>  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker  SOCKET_PATH   Path of the docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  LIB   The chaos lib used to inject the chaos   Default value: litmus, supported values: litmus   LIB_IMAGE    Image used to run the netem command   Defaults to litmuschaos/go-runner:latest  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-dns-error/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-dns-error/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-dns-error/#target-host-names","title":"Target Host Names","text":"<p>It defines the comma-separated name of the target hosts subjected to chaos. It can be tuned with the <code>TARGET_HOSTNAMES</code> ENV. If <code>TARGET_HOSTNAMES</code>not provided then all hostnames/domains will be targeted.</p> <p>Use the following example to tune this:</p> <pre><code># contains the target host names for the dns error\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-dns-error-sa\n  experiments:\n  - name: pod-dns-error\n    spec:\n      components:\n        env:\n        ## comma separated list of host names\n        ## if not provided, all hostnames/domains will be targeted\n        - name: TARGET_HOSTNAMES\n          value: '[\"litmuschaos\"]'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-dns-error/#match-scheme","title":"Match Scheme","text":"<p>It determines whether the DNS query has to match exactly with one of the targets or can have any of the targets as a substring. It can be tuned with <code>MATCH_SCHEME</code> ENV. It supports <code>exact</code> or <code>substring</code> values.</p> <p>Use the following example to tune this:</p> <pre><code># contains match scheme for the dns error\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-dns-error-sa\n  experiments:\n  - name: pod-dns-error\n    spec:\n      components:\n        env:\n        ## it supports 'exact' and 'substring' values\n        - name: MATCH_SCHEME\n          value: 'exact' \n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-dns-error/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code> runtime only.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>).</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-dns-error-sa\n  experiments:\n  - name: pod-dns-error\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-dns-spoof/","title":"Pod Dns Spoof","text":""},{"location":"experiments/categories/pods/pod-dns-spoof/#introduction","title":"Introduction","text":"<ul> <li>Pod-dns-spoof injects chaos to spoof dns resolution in kubernetes pods.</li> <li>It causes dns resolution of target hostnames/domains to wrong IPs as specified by SPOOF_MAP in the engine config.</li> </ul> <p>Scenario: DNS spoof for the target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-dns-spoof/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-dns-spoof/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-dns-spoof</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-dns-spoof/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-dns-spoof/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-dns-spoof-sa\n  namespace: default\n  labels:\n    name: pod-dns-spoof-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-dns-spoof-sa\n  namespace: default\n  labels:\n    name: pod-dns-spoof-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n    # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-dns-spoof-sa\n  namespace: default\n  labels:\n    name: pod-dns-spoof-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-dns-spoof-sa\nsubjects:\n  - kind: ServiceAccount\n    name: pod-dns-spoof-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-dns-spoof/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description    Notes   TARGET_CONTAINER    Name of container which is subjected to dns spoof   None   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Default (60s)   SPOOF_MAP   Map of the target hostnames eg. '{\"abc.com\":\"spoofabc.com\"}' where key is the hostname that needs to be spoofed and value is the hostname where it will be spoofed/redirected to.  If not provided, no hostnames/domains will be spoofed  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker  SOCKET_PATH   Path of the docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  LIB   The chaos lib used to inject the chaos   Default value: litmus, supported values: litmus   LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-dns-spoof/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-dns-spoof/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-dns-spoof/#spoof-map","title":"Spoof Map","text":"<p>It defines the map of the target hostnames eg. '{\"abc.com\":\"spoofabc.com\"}' where the key is the hostname that needs to be spoofed and value is the hostname where it will be spoofed/redirected to. It can be tuned via <code>SPOOF_MAP</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># contains the spoof map for the dns spoofing\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-dns-spoof-sa\n  experiments:\n  - name: pod-dns-spoof\n    spec:\n      components:\n        env:\n        # map of host names\n        - name: SPOOF_MAP\n          value: '{\"abc.com\":\"spoofabc.com\"}'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-dns-spoof/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code> runtime only.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>).</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-dns-spoof-sa\n  experiments:\n  - name: pod-dns-spoof\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        # map of host names\n        - name: SPOOF_MAP\n          value: '{\"abc.com\":\"spoofabc.com\"}'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-latency/","title":"Pod HTTP Latency","text":""},{"location":"experiments/categories/pods/pod-http-latency/#introduction","title":"Introduction","text":"<ul> <li>It injects http response latency on the service whose port is provided as <code>TARGET_SERVICE_PORT</code> by starting proxy server and then redirecting the traffic through the proxy server.</li> <li>It can test the application's resilience to lossy/flaky http responses.</li> </ul> <p>Scenario: Add latency to the HTTP request</p> <p></p>"},{"location":"experiments/categories/pods/pod-http-latency/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-http-latency/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.17</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-http-latency</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-http-latency/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-http-latency/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-http-latency-sa\n  namespace: default\n  labels:\n    name: pod-http-latency-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-http-latency-sa\n  namespace: default\n  labels:\n    name: pod-http-latency-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-http-latency-sa\n  namespace: default\n  labels:\n    name: pod-http-latency-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-http-latency-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-http-latency-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-http-latency/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_SERVICE_PORT   Port of the service to target Defaults to port 80   LATENCY    Latency value in ms to be added to requests  Defaults to 2000  </p> <p></p> <p>  Variables   Description   Notes   PROXY_PORT    Port where the proxy will be listening for requests  Defaults to 20000   NETWORK_INTERFACE    Network interface to be used for the proxy  Defaults to <code>eth0</code>  TOXICITY   Percentage of HTTP requests to be affected   Defaults to 100   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The duration of chaos injection (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod http latency chaos  If not provided, it will select target pods randomly based on provided appLabels  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-http-latency/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-http-latency/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-http-latency/#target-service-port","title":"Target Service Port","text":"<p>It defines the port of the targeted service that is being targeted. It can be tuned via <code>TARGET_SERVICE_PORT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port of the targeted service\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-latency-sa\n  experiments:\n  - name: pod-http-latency\n    spec:\n      components:\n        env:\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-latency/#proxy-port","title":"Proxy Port","text":"<p>It defines the port on which the proxy server will listen for requests. It can be tuned via <code>PROXY_PORT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># provide the port for proxy server\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-latency-sa\n  experiments:\n  - name: pod-http-latency\n    spec:\n      components:\n        env:\n        # provide the port for proxy server\n        - name: PROXY_PORT\n          value: '8080'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-latency/#latency","title":"Latency","text":"<p>It defines the latency value to be added to the http request. It can be tuned via <code>LATENCY</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the latency value\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-latency-sa\n  experiments:\n  - name: pod-http-latency\n    spec:\n      components:\n        env:\n        # provide the latency value\n        - name: LATENCY\n          value: '2000'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-latency/#toxicity","title":"Toxicity","text":"<p>It defines the toxicity value to be added to the http request. It can be tuned via <code>TOXICITY</code> ENV. Toxicity value defines the percentage of the total number of http requests to be affected.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the toxicity\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-latency-sa\n  experiments:\n  - name: pod-http-latency\n    spec:\n      components:\n        env:\n        # toxicity is the probability of the request to be affected\n        # provide the percentage value in the range of 0-100\n        # 0 means no request will be affected and 100 means all request will be affected\n        - name: TOXICITY\n          value: \"100\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-latency/#network-interface","title":"Network Interface","text":"<p>It defines the network interface to be used for the proxy. It can be tuned via <code>NETWORK_INTERFACE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the network interface for proxy\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-latency-sa\n  experiments:\n  - name: pod-http-latency\n    spec:\n      components:\n        env:\n        # provide the network interface for proxy\n        - name: NETWORK_INTERFACE\n          value: \"eth0\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: '80'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-latency/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-latency-sa\n  experiments:\n  - name: pod-http-latency\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-body/","title":"Pod HTTP Modify Body","text":""},{"location":"experiments/categories/pods/pod-http-modify-body/#introduction","title":"Introduction","text":"<ul> <li>It injects http modify body chaos on the service whose port is provided as <code>TARGET_SERVICE_PORT</code> by starting proxy server and then redirecting the traffic through the proxy server.</li> <li>Can be used to overwrite the http response body by providing the new body value as <code>RESPONSE_BODY</code>.</li> <li>It can test the application's resilience to error or incorrect http response body.</li> </ul> <p>Scenario: Modify Body of the HTTP response</p> <p></p>"},{"location":"experiments/categories/pods/pod-http-modify-body/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-http-modify-body/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.17</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-http-modify-body</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-http-modify-body/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-http-modify-body/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-http-modify-body-sa\n  namespace: default\n  labels:\n    name: pod-http-modify-body-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-http-modify-body-sa\n  namespace: default\n  labels:\n    name: pod-http-modify-body-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-http-modify-body-sa\n  namespace: default\n  labels:\n    name: pod-http-modify-body-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-http-modify-body-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-http-modify-body-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-http-modify-body/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_SERVICE_PORT   Port of the service to target Defaults to port 80   RESPONSE_BODY    Body string to overwrite the http response body  If no value is provided, response will be an empty body. Defaults to empty body  </p> <p></p> <p>  Variables   Description   Notes   CONTENT_ENCODING   Encoding type to compress/encodde the response body   Accepted values are: gzip, deflate, br, identity. Defaults to none (no encoding)   CONTENT_TYPE   Content type of the response body   Defaults to text/plain   PROXY_PORT    Port where the proxy will be listening for requests  Defaults to 20000   NETWORK_INTERFACE    Network interface to be used for the proxy  Defaults to <code>eth0</code>  TOXICITY   Percentage of HTTP requests to be affected   Defaults to 100   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The duration of chaos injection (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod http modify body chaos  If not provided, it will select target pods randomly based on provided appLabels  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel"},{"location":"experiments/categories/pods/pod-http-modify-body/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-http-modify-body/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-http-modify-body/#target-service-port","title":"Target Service Port","text":"<p>It defines the port of the targeted service that is being targeted. It can be tuned via <code>TARGET_SERVICE_PORT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port of the targeted service\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-body-sa\n  experiments:\n  - name: pod-http-modify-body\n    spec:\n      components:\n        env:\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # provide the body string to overwrite the response body\n        - name: RESPONSE_BODY\n          value: '2000'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-body/#proxy-port","title":"Proxy Port","text":"<p>It defines the port on which the proxy server will listen for requests. It can be tuned via <code>PROXY_PORT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port for proxy server\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-body-sa\n  experiments:\n  - name: pod-http-modify-body\n    spec:\n      components:\n        env:\n        # provide the port for proxy server\n        - name: PROXY_PORT\n          value: '8080'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-body/#response-body","title":"RESPONSE BODY","text":"<p>It defines the body string that will overwrite the http response body. It can be tuned via <code>RESPONSE_BODY</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the response body value\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-body-sa\n  experiments:\n  - name: pod-http-modify-body\n    spec:\n      components:\n        env:\n        # provide the body string to overwrite the response body\n        - name: RESPONSE_BODY\n          value: '2000'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-body/#toxicity","title":"Toxicity","text":"<p>It defines the toxicity value to be added to the http request. It can be tuned via <code>TOXICITY</code> ENV. Toxicity value defines the percentage of the total number of http requests to be affected.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the toxicity\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-body-sa\n  experiments:\n  - name: pod-http-modify-body\n    spec:\n      components:\n        env:\n        # toxicity is the probability of the request to be affected\n        # provide the percentage value in the range of 0-100\n        # 0 means no request will be affected and 100 means all request will be affected\n        - name: TOXICITY\n          value: \"100\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-body/#content-encoding-and-content-type","title":"Content Encoding and Content Type","text":"<p>It defines the content encoding and content type of the response body. It can be tuned via <code>CONTENT_ENCODING</code> and <code>CONTENT_TYPE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-body-sa\n  experiments:\n  - name: pod-http-modify-body\n    spec:\n      components:\n        env:\n        # provide the encoding type for the response body\n        # currently supported value are gzip, deflate\n        # if empty no encoding will be applied\n        - name: CONTENT_ENCODING\n          value: 'gzip'\n        # provide the content type for the response body\n        - name: CONTENT_TYPE\n          value: 'text/html'\n        # provide the body string to overwrite the response body\n        - name: RESPONSE_BODY\n          value: '2000'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-body/#network-interface","title":"Network Interface","text":"<p>It defines the network interface to be used for the proxy. It can be tuned via <code>NETWORK_INTERFACE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the network interface for proxy\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-body-sa\n  experiments:\n  - name: pod-http-modify-body\n    spec:\n      components:\n        env:\n        # provide the network interface for proxy\n        - name: NETWORK_INTERFACE\n          value: \"eth0\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: '80'\n        # provide the body string to overwrite the response body\n        - name: RESPONSE_BODY\n          value: '2000'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-body/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-body-sa\n  experiments:\n  - name: pod-http-modify-body\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # provide the body string to overwrite the response body\n        - name: RESPONSE_BODY\n          value: '2000'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-header/","title":"Pod HTTP Modify Header","text":""},{"location":"experiments/categories/pods/pod-http-modify-header/#introduction","title":"Introduction","text":"<ul> <li>It injects http modify header on the service whose port is provided as <code>TARGET_SERVICE_PORT</code> by starting proxy server and then redirecting the traffic through the proxy server.</li> <li>It can cause modification of headers of requests and responses of the service. This can be used to test service resilience towards incorrect or incomplete headers.</li> </ul> <p>Scenario: Modify Header of the HTTP request</p> <p></p>"},{"location":"experiments/categories/pods/pod-http-modify-header/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-http-modify-header/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.17</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-http-modify-header</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-http-modify-header/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-http-modify-header/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-http-modify-header-sa\n  namespace: default\n  labels:\n    name: pod-http-modify-header-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-http-modify-header-sa\n  namespace: default\n  labels:\n    name: pod-http-modify-header-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-http-modify-header-sa\n  namespace: default\n  labels:\n    name: pod-http-modify-header-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-http-modify-header-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-http-modify-header-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-http-modify-header/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_SERVICE_PORT   Port of the service to target Defaults to port 80   HEADERS_MAP    Map of headers to modify/add   Eg: {\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}.         To remove a header, just set the value to \"\"; Eg: {\"X-Litmus-Test-Header\": \"\"}  HEADER_MODE    Whether to modify response headers or request headers. Accepted values: request, response  Defaults to response  </p> <p></p> <p>  Variables   Description   Notes   PROXY_PORT    Port where the proxy will be listening for requests  Defaults to 20000   NETWORK_INTERFACE    Network interface to be used for the proxy  Defaults to <code>eth0</code>  TOXICITY   Percentage of HTTP requests to be affected   Defaults to 100   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The duration of chaos injection (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod http modify header chaos  If not provided, it will select target pods randomly based on provided appLabels  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-http-modify-header/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-http-modify-header/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-http-modify-header/#target-service-port","title":"Target Service Port","text":"<p>It defines the port of the targeted service that is being targeted. It can be tuned via <code>TARGET_SERVICE_PORT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port of the targeted service\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-chaos-sa\n  experiments:\n  - name: pod-http-chaos\n    spec:\n      components:\n        env:\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # map of headers to modify/add\n        - name: HEADERS_MAP\n          value: '{\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-header/#proxy-port","title":"Proxy Port","text":"<p>It defines the port on which the proxy server will listen for requests. It can be tuned via <code>PROXY_PORT</code></p> <p>Use the following example to tune this:</p> <pre><code>## provide the port for proxy server\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-chaos-sa\n  experiments:\n  - name: pod-http-chaos\n    spec:\n      components:\n        env:\n        # provide the port for proxy server\n        - name: PROXY_PORT\n          value: '8080'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # map of headers to modify/add\n        - name: HEADERS_MAP\n          value: '{\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-header/#headers-map","title":"Headers Map","text":"<p>It is the map of headers that are to be modified or added to the Http request/response. It can be tuned via <code>HEADERS_MAP</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the headers as a map\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-chaos-sa\n  experiments:\n  - name: pod-http-chaos\n    spec:\n      components:\n        env:\n        # map of headers to modify/add; Eg: {\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}\n        # to remove a header, just set the value to \"\"; Eg: {\"X-Litmus-Test-Header\": \"\"}\n        - name: HEADERS_MAP\n          value: '{\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-header/#header-mode","title":"Header Mode","text":"<p>It defined whether the request or the response header has to be modified. It can be tuned via <code>HEADER_MODE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the mode of the header modification; request/response\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-chaos-sa\n  experiments:\n  - name: pod-http-chaos\n    spec:\n      components:\n        env:\n        # whether to modify response headers or request headers. Accepted values: request, response\n        - name: HEADER_MODE\n          value: 'response'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # map of headers to modify/add\n        - name: HEADERS_MAP\n          value: '{\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-header/#toxicity","title":"Toxicity","text":"<p>It defines the toxicity value to be added to the http request. It can be tuned via <code>TOXICITY</code> ENV. Toxicity value defines the percentage of the total number of http requests to be affected.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the toxicity\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-modify-header-sa\n  experiments:\n  - name: pod-http-modify-header\n    spec:\n      components:\n        env:\n        # toxicity is the probability of the request to be affected\n        # provide the percentage value in the range of 0-100\n        # 0 means no request will be affected and 100 means all request will be affected\n        - name: TOXICITY\n          value: \"100\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-header/#network-interface","title":"Network Interface","text":"<p>It defines the network interface to be used for the proxy. It can be tuned via <code>NETWORK_INTERFACE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port for proxy server\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-chaos-sa\n  experiments:\n  - name: pod-http-chaos\n    spec:\n      components:\n        env:\n        # provide the network interface for proxy\n        - name: NETWORK_INTERFACE\n          value: \"eth0\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: '80'\n        # map of headers to modify/add\n        - name: HEADERS_MAP\n          value: '{\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-modify-header/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-chaos-sa\n  experiments:\n  - name: pod-http-chaos\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # map of headers to modify/add\n        - name: HEADERS_MAP\n          value: '{\"X-Litmus-Test-Header\": \"X-Litmus-Test-Value\"}'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-reset-peer/","title":"Pod HTTP Reset Peer","text":""},{"location":"experiments/categories/pods/pod-http-reset-peer/#introduction","title":"Introduction","text":"<ul> <li>It injects http reset on the service whose port is provided as <code>TARGET_SERVICE_PORT</code> which stops outgoing http requests by resetting the TCP connection by starting proxy server and then redirecting the traffic through the proxy server.</li> <li>It can test the application's resilience to lossy/flaky http connection.</li> </ul> <p>Scenario: Add reset peer to the HTTP request</p> <p></p>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.17</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-http-reset-peer</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-http-reset-peer-sa\n  namespace: default\n  labels:\n    name: pod-http-reset-peer-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-http-reset-peer-sa\n  namespace: default\n  labels:\n    name: pod-http-reset-peer-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-http-reset-peer-sa\n  namespace: default\n  labels:\n    name: pod-http-reset-peer-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-http-reset-peer-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-http-reset-peer-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_SERVICE_PORT   Port of the service to target Defaults to port 80   RESET_TIMEOUT    Reset Timeout specifies after how much duration to reset the connection  Defaults to 0  </p> <p></p> <p>  Variables   Description   Notes   PROXY_PORT    Port where the proxy will be listening for requests  Defaults to 20000   NETWORK_INTERFACE    Network interface to be used for the proxy  Defaults to <code>eth0</code>  TOXICITY   Percentage of HTTP requests to be affected   Defaults to 100   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The duration of chaos injection (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod http reset peer chaos  If not provided, it will select target pods randomly based on provided appLabels  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-http-reset-peer/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#target-service-port","title":"Target Service Port","text":"<p>It defines the port of the targeted service that is being targeted. It can be tuned via <code>TARGET_SERVICE_PORT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port of the targeted service\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-reset-peer-sa\n  experiments:\n  - name: pod-http-reset-peer\n    spec:\n      components:\n        env:\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#proxy-port","title":"Proxy Port","text":"<p>It defines the port on which the proxy server will listen for requests. It can be tuned via <code>PROXY_PORT</code> ENV. Use the following example to tune this:</p> <pre><code>## provide the port for proxy server\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-reset-peer-sa\n  experiments:\n  - name: pod-http-reset-peer\n    spec:\n      components:\n        env:\n        # provide the port for proxy server\n        - name: PROXY_PORT\n          value: '8080'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#reset-timeout","title":"RESET TIMEOUT","text":"<p>It defines the reset timeout value to be added to the http request. It can be tuned via <code>RESET_TIMEOUT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the reset timeout value\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-reset-peer-sa\n  experiments:\n  - name: pod-http-reset-peer\n    spec:\n      components:\n        env:\n        # reset timeout specifies after how much duration to reset the connection\n        - name: RESET_TIMEOUT #in ms\n          value: '2000'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#toxicity","title":"Toxicity","text":"<p>It defines the toxicity value to be added to the http request. It can be tuned via <code>TOXICITY</code> ENV. Toxicity value defines the percentage of the total number of http requests to be affected.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the toxicity\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-reset-peer-sa\n  experiments:\n  - name: pod-http-reset-peer\n    spec:\n      components:\n        env:\n        # toxicity is the probability of the request to be affected\n        # provide the percentage value in the range of 0-100\n        # 0 means no request will be affected and 100 means all request will be affected\n        - name: TOXICITY\n          value: \"100\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#network-interface","title":"Network Interface","text":"<p>It defines the network interface to be used for the proxy. It can be tuned via <code>NETWORK_INTERFACE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the network interface for proxy\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-reset-peer-sa\n  experiments:\n  - name: pod-http-reset-peer\n    spec:\n      components:\n        env:\n        # provide the network interface for proxy\n        - name: NETWORK_INTERFACE\n          value: \"eth0\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: '80'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-reset-peer/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-reset-peer-sa\n  experiments:\n  - name: pod-http-reset-peer\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/","title":"Pod HTTP Status Code","text":""},{"location":"experiments/categories/pods/pod-http-status-code/#introduction","title":"Introduction","text":"<ul> <li>It injects http status code chaos inside the pod which modifies the status code of the response from the provided application server to desired status code provided by user on the service whose port is provided as <code>TARGET_SERVICE_PORT</code> by starting proxy server and then redirecting the traffic through the proxy server.</li> <li>It can test the application's resilience to error code http responses from the provided application server.</li> </ul> <p>Scenario: Modify http response status code of the HTTP request</p> <p></p>"},{"location":"experiments/categories/pods/pod-http-status-code/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-http-status-code/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.17</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-http-status-code</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-http-status-code/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-http-status-code/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-http-status-code-sa\n  namespace: default\n  labels:\n    name: pod-http-status-code-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-http-status-code-sa\n  namespace: default\n  labels:\n    name: pod-http-status-code-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-http-status-code-sa\n  namespace: default\n  labels:\n    name: pod-http-status-code-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-http-status-code-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-http-status-code-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-http-status-code/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TARGET_SERVICE_PORT   Port of the service to target This should be the port on which the application container runs at the pod level, not at the service level. Defaults to port 80   STATUS_CODE    Modified status code for the HTTP response  If no value is provided, then a random value is selected from the list of supported values.     Multiple values can be provided as comma separated, a random value from the provided list will be selected     Supported values: [200, 201, 202, 204, 300, 301, 302, 304, 307, 400, 401, 403, 404, 500, 501, 502, 503, 504].     Defaults to random status code   MODIFY_RESPONSE_BODY    Whether to modify the body as per the status code provided.  If true, then the body is replaced by a default template for the status code. Defaults to true  </p> <p></p> <p>  Variables   Description   Notes   RESPONSE_BODY    Body string to overwrite the http response body  This will be used only if MODIFY_RESPONSE_BODY is set to true. If no value is provided, response will be an empty body. Defaults to empty body   CONTENT_ENCODING   Encoding type to compress/encodde the response body   Accepted values are: gzip, deflate, br, identity. Defaults to none (no encoding)   CONTENT_TYPE   Content type of the response body   Defaults to text/plain   PROXY_PORT    Port where the proxy will be listening for requests  Defaults to 20000   NETWORK_INTERFACE    Network interface to be used for the proxy  Defaults to <code>eth0</code>  TOXICITY   Percentage of HTTP requests to be affected   Defaults to 100   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The duration of chaos injection (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod http status code chaos  If not provided, it will select target pods randomly based on provided appLabels  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel"},{"location":"experiments/categories/pods/pod-http-status-code/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-http-status-code/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-http-status-code/#target-service-port","title":"Target Service Port","text":"<p>It defines the port of the targeted service that is being targeted. It can be tuned via <code>TARGET_SERVICE_PORT</code> ENV. This should be the port where the application runs at the pod level, not at the service level. This means if the application pod is running the service at port 8080 and we create a service exposing that at port 80, then the target service port should be 8080 and not 80, which is the port at pod-level.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port of the targeted service\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # modified status code for the http response\n        - name: STATUS_CODE\n          value: '500'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#proxy-port","title":"Proxy Port","text":"<p>It defines the port on which the proxy server will listen for requests. It can be tuned via <code>PROXY_PORT</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the port for proxy server\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # provide the port for proxy server\n        - name: PROXY_PORT\n          value: '8080'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # modified status code for the http response\n        - name: STATUS_CODE\n          value: '500'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#status-code","title":"Status Code","text":"<p>It defines the status code value for the http response. It can be tuned via <code>STATUS_CODE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## modified status code for the http response\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # modified status code for the http response\n        # if no value is provided, a random status code from the supported code list will selected\n        # if multiple comma separated values are provided, then a random value from the provided list will be selected\n        # if an invalid status code is provided, the experiment will fail\n        # supported status code list: [200, 201, 202, 204, 300, 301, 302, 304, 307, 400, 401, 403, 404, 500, 501, 502, 503, 504]\n        - name: STATUS_CODE\n          value: '500'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#modify-response-body","title":"Modify Response Body","text":"<p>It defines whether to modify the respone body with a pre-defined template to match with the status code value of the http response. It can be tuned via <code>MODIFY_RESPONSE_BODY</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>##  whether to modify the body as per the status code provided\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        #  whether to modify the body as per the status code provided\n        - name: \"MODIFY_RESPONSE_BODY\"\n          value: \"true\"\n        # modified status code for the http response\n        - name: STATUS_CODE\n          value: '500'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#toxicity","title":"Toxicity","text":"<p>It defines the toxicity value to be added to the http request. It can be tuned via <code>TOXICITY</code> ENV. Toxicity value defines the percentage of the total number of http requests to be affected.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the toxicity\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # toxicity is the probability of the request to be affected\n        # provide the percentage value in the range of 0-100\n        # 0 means no request will be affected and 100 means all request will be affected\n        - name: TOXICITY\n          value: \"100\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#response-body","title":"RESPONSE BODY","text":"<p>It defines the body string that will overwrite the http response body. It can be tuned via <code>RESPONSE_BODY</code> and <code>MODIFY_RESPONSE_BODY</code> ENV. The <code>MODIFY_RESPONSE_BODY</code> ENV should be set to <code>true</code> to enable this feature.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the response body value\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # provide the body string to overwrite the response body. This will be used only if MODIFY_RESPONSE_BODY is set to true\n        - name: RESPONSE_BODY\n          value: '&lt;h1&gt;Hello World&lt;/h1&gt;'\n        #  whether to modify the body as per the status code provided\n        - name: \"MODIFY_RESPONSE_BODY\"\n          value: \"true\"\n        # modified status code for the http response\n        - name: STATUS_CODE\n          value: '500'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#content-encoding-and-content-type","title":"Content Encoding and Content Type","text":"<p>It defines the content encoding and content type of the response body. It can be tuned via <code>CONTENT_ENCODING</code> and <code>CONTENT_TYPE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>##  whether to modify the body as per the status code provided\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # provide the encoding type for the response body\n        # currently supported value are gzip, deflate\n        # if empty no encoding will be applied\n        - name: CONTENT_ENCODING\n          value: 'gzip'\n        # provide the content type for the response body\n        - name: CONTENT_TYPE\n          value: 'text/html'\n        #  whether to modify the body as per the status code provided\n        - name: \"MODIFY_RESPONSE_BODY\"\n          value: \"true\"\n        # modified status code for the http response\n        - name: STATUS_CODE\n          value: '500'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#network-interface","title":"Network Interface","text":"<p>It defines the network interface to be used for the proxy. It can be tuned via <code>NETWORK_INTERFACE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code>## provide the network interface for proxy\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # provide the network interface for proxy\n        - name: NETWORK_INTERFACE\n          value: \"eth0\"\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: '80'\n        # modified status code for the http response\n        - name: STATUS_CODE\n          value: '500'\n</code></pre>"},{"location":"experiments/categories/pods/pod-http-status-code/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-http-status-code-sa\n  experiments:\n  - name: pod-http-status-code\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        # provide the port of the targeted service\n        - name: TARGET_SERVICE_PORT\n          value: \"80\"\n        # modified status code for the http response\n        - name: STATUS_CODE\n          value: '500'\n</code></pre>"},{"location":"experiments/categories/pods/pod-io-stress/","title":"Pod IO Stress","text":""},{"location":"experiments/categories/pods/pod-io-stress/#introduction","title":"Introduction","text":"<ul> <li>This experiment causes disk stress on the application pod. The experiment aims to verify the resiliency of applications that share this disk resource for ephemeral or persistent storage purposes</li> </ul> <p>Scenario: Stress the IO of the target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-io-stress/#uses","title":"Uses","text":"View the uses of the experiment <p>Disk Pressure or CPU hogs is another very common and frequent scenario we find in kubernetes applications that can result in the eviction of the application replica and impact its delivery. Such scenarios that can still occur despite whatever availability aids K8s provides. These problems are generally referred to as \"Noisy Neighbour\" problems</p> <p>Stressing the disk with continuous and heavy IO for example can cause degradation in reads written by other microservices that use this shared disk for example modern storage solutions for Kubernetes use the concept of storage pools out of which virtual volumes/devices are carved out. Another issue is the amount of scratch space eaten up on a node which leads to  the lack of space for newer containers to get scheduled (kubernetes too gives up by applying an \"eviction\" taint like \"disk-pressure\") and causes a wholesale movement of all pods to other nodes</p>"},{"location":"experiments/categories/pods/pod-io-stress/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-io-stress</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-io-stress/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-io-stress/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup..</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-io-stress-sa\n  namespace: default\n  labels:\n    name: pod-io-stress-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-io-stress-sa\n  namespace: default\n  labels:\n    name: pod-io-stress-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)  \n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-io-stress-sa\n  namespace: default\n  labels:\n    name: pod-io-stress-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-io-stress-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-io-stress-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-io-stress/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   FILESYSTEM_UTILIZATION_PERCENTAGE   Specify the size as percentage of free space on the file system    Default to 10%  FILESYSTEM_UTILIZATION_BYTES   Specify the size in GigaBytes(GB).  <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> &amp; <code>FILESYSTEM_UTILIZATION_BYTES</code> are mutually exclusive. If both are provided, <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> is prioritized.   NUMBER_OF_WORKERS   It is the number of IO workers involved in IO disk stress   Default to 4   TOTAL_CHAOS_DURATION   The time duration for chaos (seconds)    Default to 120s   VOLUME_MOUNT_PATH   Fill the given volume mount path  LIB    The chaos lib used to inject the chaos   Default to litmus<code>. Available litmus and pumba.   LIB_IMAGE    Image used to run the stress command   Default to <code>litmuschaos/go-runner:latest<code>  TARGET_PODS   Comma separated list of application pod name subjected to pod io stress chaos  If not provided, it will select target pods randomly based on provided appLabels  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to /run/containerd/containerd.sock  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel"},{"location":"experiments/categories/pods/pod-io-stress/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-io-stress/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-io-stress/#filesystem-utilization-percentage","title":"Filesystem Utilization Percentage","text":"<p>It stresses the <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> percentage of total free space available in the pod. </p> <p>Use the following example to tune this:</p> <pre><code># stress the i/o of the targeted pod with FILESYSTEM_UTILIZATION_PERCENTAGE of total free space \n# it is mutually exclusive with the FILESYSTEM_UTILIZATION_BYTES.\n# if both are provided then it will use FILESYSTEM_UTILIZATION_PERCENTAGE for stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-io-stress-sa\n  experiments:\n  - name: pod-io-stress\n    spec:\n      components:\n        env:\n        # percentage of free space of file system, need to be stressed\n        - name: FILESYSTEM_UTILIZATION_PERCENTAGE\n          value: '10' #in GB\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-io-stress/#filesystem-utilization-bytes","title":"Filesystem Utilization Bytes","text":"<p>It stresses the <code>FILESYSTEM_UTILIZATION_BYTES</code> GB of the i/o of the targeted pod.  It is mutually exclusive with the <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> ENV. If <code>FILESYSTEM_UTILIZATION_PERCENTAGE</code> ENV is set then it will use the percentage for the stress otherwise, it will stress the i/o based on <code>FILESYSTEM_UTILIZATION_BYTES</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># stress the i/o of the targeted pod with given FILESYSTEM_UTILIZATION_BYTES\n# it is mutually exclusive with the FILESYSTEM_UTILIZATION_PERCENTAGE.\n# if both are provided then it will use FILESYSTEM_UTILIZATION_PERCENTAGE for stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-io-stress-sa\n  experiments:\n  - name: pod-io-stress\n    spec:\n      components:\n        env:\n        # size of io to be stressed\n        - name: FILESYSTEM_UTILIZATION_BYTES\n          value: '1' #in GB\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-io-stress/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-io-stress-sa\n  experiments:\n  - name: pod-io-stress\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-io-stress/#mount-path","title":"Mount Path","text":"<p>The volume mount path, which needs to be filled. It can be tuned with <code>VOLUME_MOUNT_PATH</code> ENV. </p> <p>Use the following example to tune this:</p> <pre><code># provide the volume mount path, which needs to be filled\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-io-stress-sa\n  experiments:\n  - name: pod-io-stress\n    spec:\n      components:\n        env:\n        # path need to be stressed/filled\n        - name: VOLUME_MOUNT_PATH\n          value: '/some-dir-in-container'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-io-stress/#workers-for-stress","title":"Workers For Stress","text":"<p>The worker's count for the stress can be tuned with <code>NUMBER_OF_WORKERS</code> ENV. </p> <p>Use the following example to tune this:</p> <pre><code># number of workers for the stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-io-stress-sa\n  experiments:\n  - name: pod-io-stress\n    spec:\n      components:\n        env:\n        # number of io workers \n        - name: NUMBER_OF_WORKERS\n          value: '4'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-io-stress/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>.</p> <p>Use the following example to tune this:</p> <pre><code># use the pumba lib for io stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-io-stress-sa\n  experiments:\n  - name: pod-io-stress\n    spec:\n      components:\n        env:\n        # name of lib\n        # it supports litmus and pumba lib\n        - name: LIB\n          value: 'pumba'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/","title":"Pod Memory Hog Exec","text":""},{"location":"experiments/categories/pods/pod-memory-hog-exec/#introduction","title":"Introduction","text":"<ul> <li> <p>This experiment consumes the Memory resources on the application container on specified memory in megabytes.</p> </li> <li> <p>It simulates conditions where app pods experience Memory spikes either due to expected/undesired processes thereby testing how the overall application stack behaves when this occurs.</p> </li> </ul> <p>Scenario: Stress the Memory</p> <p></p>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#uses","title":"Uses","text":"View the uses of the experiment <p>Memory usage within containers is subject to various constraints in Kubernetes. If the limits are specified in their spec, exceeding them can cause termination of the container (due to OOMKill of the primary process, often pid 1) - the restart of the container by kubelet, subject to the policy specified. For containers with no limits placed, the memory usage is uninhibited until such time as the Node level OOM Behaviour takes over. In this case, containers on the node can be killed based on their oom_score and the QoS class a given pod belongs to (bestEffort ones are first to be targeted). This eval is extended to all pods running on the node - thereby causing a bigger blast radius. </p> <p>This experiment launches a stress process within the target container - which can cause either the primary process in the container to be resource constrained in cases where the limits are enforced OR eat up available system memory on the node in cases where the limits are not specified</p>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-memory-hog-exec</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-memory-hog-exec-sa\n  namespace: default\n  labels:\n    name: pod-memory-hog-exec-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-memory-hog-exec-sa\n  namespace: default\n  labels:\n    name: pod-memory-hog-exec-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)  \n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-memory-hog-exec-sa\n  namespace: default\n  labels:\n    name: pod-memory-hog-exec-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-memory-hog-exec-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-memory-hog-exec-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   MEMORY_CONSUMPTION    The amount of memory used of hogging a Kubernetes pod (megabytes)  Defaults to 500MB (Up to 2000MB)  TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Defaults to 60s   LIB    The chaos lib used to inject the chaos. Available libs are <code>litmus</code>  Defaults to <code>litmus</code>  TARGET_PODS   Comma separated list of application pod name subjected to pod memory hog chaos  If not provided, it will select target pods randomly based on provided appLabels  TARGET_CONTAINER   Name of the target container under chaos   If not provided, it will select the first container of the target pod   CHAOS_KILL_COMMAND   The command to kill the chaos process   Defaults to <code>kill $(find /proc -name exe -lname '*/dd' 2&gt;&amp;1 | grep -v 'Permission denied' | awk -F/ '{print $(NF-1)}' | head -n 1)</code>. Another useful one that generally works (in case the default doesn't) is <code>kill -9 $(ps afx | grep \"[dd] if=/dev/zero\" | awk '{print $1}' | tr '\\n' ' ')</code>. In case neither works, please check whether the target pod's base image offers a shell. If yes, identify appropriate shell command to kill the chaos process   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   RAMP_TIME   Period to wait before injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-memory-hog-exec/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#memory-consumption","title":"Memory Consumption","text":"<p>It stresses the <code>MEMORY_CONSUMPTION</code> MB memory of the targeted pod for the <code>TOTAL_CHAOS_DURATION</code> duration. The memory consumption limit is 2000MB</p> <p>Use the following example to tune this:</p> <pre><code># memory to be stressed in MB\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-memory-hog-sa\n  experiments:\n  - name: pod-memory-hog\n    spec:\n      components:\n        env:\n        # memory consuption value in MB\n        # it is limited to 2000MB\n        - name: MEMORY_CONSUMPTION\n          value: '500' #in MB\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-memory-hog-exec/#chaos-kill-commands","title":"Chaos Kill Commands","text":"<p>It defines the <code>CHAOS_KILL_COMMAND</code> ENV to set the chaos kill command. Default values of <code>CHAOS_KILL_COMMAND</code> command:</p> <ul> <li><code>CHAOS_KILL_COMMAND</code>: \"kill $(find /proc -name exe -lname '*/dd' 2&gt;&amp;1 | grep -v 'Permission denied' | awk -F/ '{print $(NF-1)}' | head -n 1)\"</li> </ul> <p>Use the following example to tune this:</p> <pre><code># provide the chaos kill command used to kill the chaos process\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-memory-hog-exec-sa\n  experiments:\n  - name: pod-memory-hog-exec\n    spec:\n      components:\n        env:\n        # command to kill the dd process\n        # alternative command: \"kill -9 $(ps afx | grep \"[dd] if=/dev/zero\" | awk '{print $1}' | tr '\\n' ' ')\"\n        - name: CHAOS_KILL_COMMAND\n          value: \"kill $(find /proc -name exe -lname '*/dd' 2&gt;&amp;1 | grep -v 'Permission denied' | awk -F/ '{print $(NF-1)}' | head -n 1)\"\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-memory-hog/","title":"Pod Memory Hog","text":""},{"location":"experiments/categories/pods/pod-memory-hog/#introduction","title":"Introduction","text":"<ul> <li>This experiment consumes the Memory resources on the application container on specified memory in megabytes.</li> <li>It simulates conditions where app pods experience Memory spikes either due to expected/undesired processes thereby testing how the overall application stack behaves when this occurs.</li> </ul> <p>Scenario: Stress the Memory</p> <p></p>"},{"location":"experiments/categories/pods/pod-memory-hog/#uses","title":"Uses","text":"View the uses of the experiment <p>Memory usage within containers is subject to various constraints in Kubernetes. If the limits are specified in their spec, exceeding them can cause termination of the container (due to OOMKill of the primary process, often pid 1) - the restart of the container by kubelet, subject to the policy specified. For containers with no limits placed, the memory usage is uninhibited until such time as the Node level OOM Behaviour takes over. In this case, containers on the node can be killed based on their oom_score and the QoS class a given pod belongs to (bestEffort ones are first to be targeted). This eval is extended to all pods running on the node - thereby causing a bigger blast radius. </p> <p>This experiment launches a stress process within the target container - which can cause either the primary process in the container to be resource constrained in cases where the limits are enforced OR eat up available system memory on the node in cases where the limits are not specified</p>"},{"location":"experiments/categories/pods/pod-memory-hog/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-memory-hog</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-memory-hog/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-memory-hog/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-memory-hog-sa\n  namespace: default\n  labels:\n    name: pod-memory-hog-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-memory-hog-sa\n  namespace: default\n  labels:\n    name: pod-memory-hog-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)  \n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-memory-hog-sa\n  namespace: default\n  labels:\n    name: pod-memory-hog-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-memory-hog-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-memory-hog-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-memory-hog/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   MEMORY_CONSUMPTION    The amount of memory used of hogging a Kubernetes pod (megabytes)  Defaults to 500MB   NUMBER_OF_WORKERS   The number of workers used to run the stress process    Defaults to 1   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)    Defaults to 60s   LIB    The chaos lib used to inject the chaos. Available libs are <code>litmus</code> and <code>pumba</code>  Defaults to <code>litmus</code>  LIB_IMAGE    Image used to run the helper pod.  Defaults to <code>litmuschaos/go-runner:1.13.8<code>  STRESS_IMAGE    Container run on the node at runtime by the pumba lib to inject stressors. Only used in LIB <code>pumba</code>  Default to <code>alexeiled/stress-ng:latest-ubuntu</code>  TARGET_PODS   Comma separated list of application pod name subjected to pod memory hog chaos  If not provided, it will select target pods randomly based on provided appLabels  TARGET_CONTAINER   Name of the target container under chaos.  If not provided, it will select the first container of the target pod  CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   RAMP_TIME   Period to wait before injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel"},{"location":"experiments/categories/pods/pod-memory-hog/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-memory-hog/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-memory-hog/#memory-consumption","title":"Memory Consumption","text":"<p>It stresses the <code>MEMORY_CONSUMPTION</code> MB memory of the targeted pod for the <code>TOTAL_CHAOS_DURATION</code> duration.</p> <p>Use the following example to tune this:</p> <pre><code># define the memory consumption in MB\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-memory-hog-sa\n  experiments:\n  - name: pod-memory-hog\n    spec:\n      components:\n        env:\n        # memory consumption value\n        - name: MEMORY_CONSUMPTION\n          value: '500' #in MB\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-memory-hog/#workers-for-stress","title":"Workers For Stress","text":"<p>The worker's count for the stress can be tuned with <code>NUMBER_OF_WORKERS</code> ENV. </p> <p>Use the following example to tune this:</p> <pre><code># number of workers used for the stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-memory-hog-sa\n  experiments:\n  - name: pod-memory-hog\n    spec:\n      components:\n        env:\n        # number of workers for stress\n        - name: NUMBER_OF_WORKERS\n          value: '1'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-memory-hog/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul>"},{"location":"experiments/categories/pods/pod-memory-hog/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>. Provide the stress image via <code>STRESS_IMAGE</code> ENV for the pumba library.</p> <p>Use the following example to tune this:</p> <pre><code># use the pumba lib for the memory stress\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-memory-hog-sa\n  experiments:\n  - name: pod-memory-hog\n    spec:\n      components:\n        env:\n        # name of chaoslib\n        # it supports litmus and pumba lib\n        - name: LIB\n          value: 'pumba'\n        # stress image - applicable for pumba lib only\n        - name: STRESS_IMAGE\n          value: 'alexeiled/stress-ng:latest-ubuntu'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-corruption/","title":"Pod Network Corruption","text":""},{"location":"experiments/categories/pods/pod-network-corruption/#introduction","title":"Introduction","text":"<ul> <li>It injects packet corruption on the specified container by starting a traffic control (tc) process with netem rules to add egress packet corruption</li> <li>It can test the application's resilience to lossy/flaky network</li> </ul> <p>Scenario: Corrupt the network packets of target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-network-corruption/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-network-corruption/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-network-corruption</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-network-corruption/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-network-corruption/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-network-corruption-sa\n  namespace: default\n  labels:\n    name: pod-network-corruption-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-network-corruption-sa\n  namespace: default\n  labels:\n    name: pod-network-corruption-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-network-corruption-sa\n  namespace: default\n  labels:\n    name: pod-network-corruption-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-network-corruption-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-network-corruption-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-network-corruption/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   NETWORK_INTERFACE   Name of ethernet interface considered for shaping traffic    TARGET_CONTAINER    Name of container which is subjected to network corruption   Applicable for containerd &amp; CRI-O runtime only. Even with these runtimes, if the value is not provided, it injects chaos on the first container of the pod   NETWORK_PACKET_CORRUPTION_PERCENTAGE    Packet corruption in percentage   Default (100)   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod network corruption chaos  If not provided, it will select target pods randomly based on provided appLabels  DESTINATION_IPS   IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated IP(S) or CIDR(S) can be provided. if not provided, it will induce network chaos for all ips/destinations  DESTINATION_HOSTS   DNS Names/FQDN names of the services, the accessibility to which, is impacted   if not provided, it will induce network chaos for all ips/destinations or DESTINATION_IPS if already defined  SOURCE_PORTS   ports of the target application, the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  DESTINATION_PORTS   ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB   The chaos lib used to inject the chaos   Default value: litmus, supported values: pumba and litmus   TC_IMAGE   Image used for traffic control in linux   default value is <code>gaiadocker/iproute2</code>  LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-network-corruption/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-network-corruption/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-network-corruption/#network-packet-corruption","title":"Network Packet Corruption","text":"<p>It defines the network packet corruption percentage to be injected in the targeted application. It can be tuned via <code>NETWORK_PACKET_CORRUPTION_PERCENTAGE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it inject the network-corruption for the egress traffic\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-corruption-sa\n  experiments:\n  - name: pod-network-corruption\n    spec:\n      components:\n        env:\n        # network packet corruption percentage\n        - name: NETWORK_PACKET_CORRUPTION_PERCENTAGE\n          value: '100' #in percentage\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-corruption/#destination-ips-and-destination-hosts","title":"Destination IPs And Destination Hosts","text":"<p>The network experiments interrupt traffic for all the IPs/hosts by default. The interruption of specific IPs/Hosts can be tuned via <code>DESTINATION_IPS</code> and <code>DESTINATION_HOSTS</code> ENV.</p> <ul> <li><code>DESTINATION_IPS</code>: It contains the IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted.</li> <li><code>DESTINATION_HOSTS</code>: It contains the DNS Names/FQDN names of the services, the accessibility to which, is impacted.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the egress traffic for specific ips/hosts\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-corruption-sa\n  experiments:\n  - name: pod-network-corruption\n    spec:\n      components:\n        env:\n        # supports comma separated destination ips\n        - name: DESTINATION_IPS\n          value: '8.8.8.8,192.168.5.6'\n        # supports comma separated destination hosts\n        - name: DESTINATION_HOSTS\n          value: 'nginx.default.svc.cluster.local,google.com'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-corruption/#source-and-destination-ports","title":"Source And Destination Ports","text":"<p>The network experiments interrupt traffic for all the source &amp; destination ports by default. The interruption of specific port(s) can be tuned via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: It contains ports of the target application, the accessibility to which is impacted</li> <li><code>DESTINATION_PORTS</code>: It contains the ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the ingrees and egress traffic for specific ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-corruption-sa\n  experiments:\n  - name: pod-network-corruption\n    spec:\n      components:\n        env:\n        # supports comma separated source ports\n        - name: SOURCE_PORTS\n          value: '80'\n        # supports comma separated destination ports\n        - name: DESTINATION_PORTS\n          value: '8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-corruption/#blacklist-source-and-destination-ports","title":"Blacklist Source and Destination Ports","text":"<p>By default, the network experiments disrupt traffic for all the source and destination ports. The specific ports can be blacklisted via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: Provide the comma separated source ports preceded by <code>!</code>, that you'd like to blacklist from the chaos.</li> <li><code>DESTINATION_PORTS</code>: Provide the comma separated destination ports preceded by <code>!</code> , that you'd like to blacklist from the chaos.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># blacklist the source and destination ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-corruption-sa\n  experiments:\n  - name: pod-network-corruption\n    spec:\n      components:\n        env:\n        # it will blacklist 80 and 8080 source ports\n        - name: SOURCE_PORTS\n          value: '!80,8080'\n        # it will blacklist 8080 and 9000 destination ports\n        - name: DESTINATION_PORTS\n          value: '!8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-corruption/#network-interface","title":"Network Interface","text":"<p>The defined name of the ethernet interface, which is considered for shaping traffic. It can be tuned via <code>NETWORK_INTERFACE</code> ENV. Its default value is <code>eth0</code>.</p> <p>Use the following example to tune this:</p> <pre><code># provide the network interface\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-corruption-sa\n  experiments:\n  - name: pod-network-corruption\n    spec:\n      components:\n        env:\n        # name of the network interface\n        - name: NETWORK_INTERFACE\n          value: 'eth0'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-corruption/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-corruption-sa\n  experiments:\n  - name: pod-network-corruption\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-corruption/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>. Provide the traffic control image via <code>TC_IMAGE</code> ENV for the pumba library.</p> <p>Use the following example to tune this:</p> <pre><code># use pumba chaoslib for the network chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-corruption-sa\n  experiments:\n  - name: pod-network-corruption\n    spec:\n      components:\n        env:\n        # name of the chaoslib\n        # supports litmus and pumba lib\n        - name: LIB\n          value: 'pumba'\n        # image used for the traffic control in linux\n        # applicable for pumba lib only\n        - name: TC_IMAGE\n          value: 'gaiadocker/iproute2'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-duplication/","title":"Pod Network Duplication","text":""},{"location":"experiments/categories/pods/pod-network-duplication/#introduction","title":"Introduction","text":"<ul> <li>It injects chaos to disrupt network connectivity to kubernetes pods.</li> <li>It causes Injection of network duplication on the specified container by starting a traffic control (tc) process with netem rules to add egress delays. It Can test the application's resilience to duplicate network.</li> </ul> <p>Scenario: Duplicate the network packets of target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-network-duplication/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-network-duplication/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-network-duplication</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-network-duplication/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-network-duplication/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-network-duplication-sa\n  namespace: default\n  labels:\n    name: pod-network-duplication-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-network-duplication-sa\n  namespace: default\n  labels:\n    name: pod-network-duplication-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-network-duplication-sa\n  namespace: default\n  labels:\n    name: pod-network-duplication-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-network-duplication-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-network-duplication-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-network-duplication/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   NETWORK_INTERFACE   Name of ethernet interface considered for shaping traffic    TARGET_CONTAINER    Name of container which is subjected to network latency   Optional   Applicable for containerd &amp; CRI-O runtime only. Even with these runtimes, if the value is not provided, it injects chaos on the first container of the pod   NETWORK_PACKET_DUPLICATION_PERCENTAGE   The packet duplication in percentage   Optional   Default to 100 percentage   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod network corruption chaos  If not provided, it will select target pods randomly based on provided appLabels  DESTINATION_IPS   IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated IP(S) or CIDR(S) can be provided. if not provided, it will induce network chaos for all ips/destinations  DESTINATION_HOSTS   DNS Names/FQDN names of the services, the accessibility to which, is impacted   if not provided, it will induce network chaos for all ips/destinations or DESTINATION_IPS if already defined  SOURCE_PORTS   ports of the target application, the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  DESTINATION_PORTS   ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB   The chaos lib used to inject the chaos   Default value: litmus, supported values: pumba and litmus   TC_IMAGE   Image used for traffic control in linux   default value is <code>gaiadocker/iproute2</code>  LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-network-duplication/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-network-duplication/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-network-duplication/#network-packet-duplication","title":"Network Packet Duplication","text":"<p>It defines the network packet duplication percentage to be injected in the targeted application. It can be tuned via <code>NETWORK_PACKET_DUPLICATION_PERCENTAGE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it inject the network-duplication for the egress traffic\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-duplication-sa\n  experiments:\n  - name: pod-network-duplication\n    spec:\n      components:\n        env:\n        # network packet duplication percentage\n        - name: NETWORK_PACKET_DUPLICATION_PERCENTAGE\n          value: '100'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-duplication/#destination-ips-and-destination-hosts","title":"Destination IPs And Destination Hosts","text":"<p>The network experiments interrupt traffic for all the IPs/hosts by default. The interruption of specific IPs/Hosts can be tuned via <code>DESTINATION_IPS</code> and <code>DESTINATION_HOSTS</code> ENV.</p> <ul> <li><code>DESTINATION_IPS</code>: It contains the IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted.</li> <li><code>DESTINATION_HOSTS</code>: It contains the DNS Names/FQDN names of the services, the accessibility to which, is impacted.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the egress traffic for specific ips/hosts\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-duplication-sa\n  experiments:\n  - name: pod-network-duplication\n    spec:\n      components:\n        env:\n        # supports comma separated destination ips\n        - name: DESTINATION_IPS\n          value: '8.8.8.8,192.168.5.6'\n        # supports comma separated destination hosts\n        - name: DESTINATION_HOSTS\n          value: 'nginx.default.svc.cluster.local,google.com'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-duplication/#source-and-destination-ports","title":"Source And Destination Ports","text":"<p>The network experiments interrupt traffic for all the source &amp; destination ports by default. The interruption of specific port(s) can be tuned via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: It contains ports of the target application, the accessibility to which is impacted</li> <li><code>DESTINATION_PORTS</code>: It contains the ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the ingrees and egress traffic for specific ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-duplication-sa\n  experiments:\n  - name: pod-network-duplication\n    spec:\n      components:\n        env:\n        # supports comma separated source ports\n        - name: SOURCE_PORTS\n          value: '80'\n        # supports comma separated destination ports\n        - name: DESTINATION_PORTS\n          value: '8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-duplication/#blacklist-source-and-destination-ports","title":"Blacklist Source and Destination Ports","text":"<p>By default, the network experiments disrupt traffic for all the source and destination ports. The specific ports can be blacklisted via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: Provide the comma separated source ports preceded by <code>!</code>, that you'd like to blacklist from the chaos.</li> <li><code>DESTINATION_PORTS</code>: Provide the comma separated destination ports preceded by <code>!</code> , that you'd like to blacklist from the chaos.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># blacklist the source and destination ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-duplication-sa\n  experiments:\n  - name: pod-network-duplication\n    spec:\n      components:\n        env:\n        # it will blacklist 80 and 8080 source ports\n        - name: SOURCE_PORTS\n          value: '!80,8080'\n        # it will blacklist 8080 and 9000 destination ports\n        - name: DESTINATION_PORTS\n          value: '!8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-duplication/#network-interface","title":"Network Interface","text":"<p>The defined name of the ethernet interface, which is considered for shaping traffic. It can be tuned via <code>NETWORK_INTERFACE</code> ENV. Its default value is <code>eth0</code>.</p> <p>Use the following example to tune this:</p> <pre><code># provide the network interface\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-duplication-sa\n  experiments:\n  - name: pod-network-duplication\n    spec:\n      components:\n        env:\n        # name of the network interface\n        - name: NETWORK_INTERFACE\n          value: 'eth0'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-duplication/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-duplication-sa\n  experiments:\n  - name: pod-network-duplication\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-duplication/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>. Provide the traffic control image via <code>TC_IMAGE</code> ENV for the pumba library.</p> <p>Use the following example to tune this:</p> <pre><code># use pumba chaoslib for the network chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-duplication-sa\n  experiments:\n  - name: pod-network-duplication\n    spec:\n      components:\n        env:\n        # name of the chaoslib\n        # supports litmus and pumba lib\n        - name: LIB\n          value: 'pumba'\n        # image used for the traffic control in linux\n        # applicable for pumba lib only\n        - name: TC_IMAGE\n          value: 'gaiadocker/iproute2'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/","title":"Pod Network Latency","text":""},{"location":"experiments/categories/pods/pod-network-latency/#introduction","title":"Introduction","text":"<ul> <li>It injects latency on the specified container by starting a traffic control (tc) process with netem rules to add egress delays</li> <li>It can test the application's resilience to lossy/flaky network</li> </ul> <p>Scenario: Induce letency in the network of target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-network-latency/#uses","title":"Uses","text":"View the uses of the experiment <p>The experiment causes network degradation without the pod being marked unhealthy/unworthy of traffic by kube-proxy (unless you have a liveness probe of sorts that measures latency and restarts/crashes the container). The idea of this experiment is to simulate issues within your pod network OR microservice communication across services in different availability zones/regions etc.</p> <p>Mitigation (in this case keep the timeout i.e., access latency low) could be via some middleware that can switch traffic based on some SLOs/perf parameters. If such an arrangement is not available the next best thing would be to verify if such a degradation is highlighted via notification/alerts etc,. so the admin/SRE has the opportunity to investigate and fix things. Another utility of the test would be to see what the extent of impact caused to the end-user OR the last point in the app stack on account of degradation in access to a downstream/dependent microservice. Whether it is acceptable OR breaks the system to an unacceptable degree. The experiment provides DESTINATION_IPS or DESTINATION_HOSTS so that you can control the chaos against specific services within or outside the cluster.</p> <p>The applications may stall or get corrupted while they wait endlessly for a packet. The experiment limits the impact (blast radius) to only the traffic you want to test by specifying IP addresses or application information.This experiment will help to improve the resilience of your services over time</p>"},{"location":"experiments/categories/pods/pod-network-latency/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-network-latency</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-network-latency/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-network-latency/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-network-latency-sa\n  namespace: default\n  labels:\n    name: pod-network-latency-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-network-latency-sa\n  namespace: default\n  labels:\n    name: pod-network-latency-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-network-latency-sa\n  namespace: default\n  labels:\n    name: pod-network-latency-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-network-latency-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-network-latency-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-network-latency/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   NETWORK_INTERFACE   Name of ethernet interface considered for shaping traffic    TARGET_CONTAINER    Name of container which is subjected to network latency   Applicable for containerd &amp; CRI-O runtime only. Even with these runtimes, if the value is not provided, it injects chaos on the first container of the pod   NETWORK_LATENCY   The latency/delay in milliseconds   Default 2000, provide numeric value only   JITTER   The network jitter value in ms   Default 0, provide numeric value only   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod network corruption chaos  If not provided, it will select target pods randomly based on provided appLabels  DESTINATION_IPS   IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated IP(S) or CIDR(S) can be provided. if not provided, it will induce network chaos for all ips/destinations  DESTINATION_HOSTS   DNS Names/FQDN names of the services, the accessibility to which, is impacted   if not provided, it will induce network chaos for all ips/destinations or DESTINATION_IPS if already defined  SOURCE_PORTS   ports of the target application, the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  DESTINATION_PORTS   ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB   The chaos lib used to inject the chaos   Default value: litmus, supported values: pumba and litmus   TC_IMAGE   Image used for traffic control in linux   default value is <code>gaiadocker/iproute2</code>  LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-network-latency/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-network-latency/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-network-latency/#network-latency","title":"Network Latency","text":"<p>It defines the network latency(in ms) to be injected in the targeted application. It can be tuned via <code>NETWORK_LATENCY</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it inject the network-latency for the egress traffic\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # network latency to be injected\n        - name: NETWORK_LATENCY\n          value: '2000' #in ms\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/#destination-ips-and-destination-hosts","title":"Destination IPs And Destination Hosts","text":"<p>The network experiments interrupt traffic for all the IPs/hosts by default. The interruption of specific IPs/Hosts can be tuned via <code>DESTINATION_IPS</code> and <code>DESTINATION_HOSTS</code> ENV.</p> <ul> <li><code>DESTINATION_IPS</code>: It contains the IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted.</li> <li><code>DESTINATION_HOSTS</code>: It contains the DNS Names/FQDN names of the services, the accessibility to which, is impacted.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the egress traffic for specific ips/hosts\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # supports comma separated destination ips\n        - name: DESTINATION_IPS\n          value: '8.8.8.8,192.168.5.6'\n        # supports comma separated destination hosts\n        - name: DESTINATION_HOSTS\n          value: 'nginx.default.svc.cluster.local,google.com'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/#source-and-destination-ports","title":"Source And Destination Ports","text":"<p>The network experiments interrupt traffic for all the source &amp; destination ports by default. The interruption of specific port(s) can be tuned via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: It contains ports of the target application, the accessibility to which is impacted</li> <li><code>DESTINATION_PORTS</code>: It contains the ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the ingrees and egress traffic for specific ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # supports comma separated source ports\n        - name: SOURCE_PORTS\n          value: '80'\n        # supports comma separated destination ports\n        - name: DESTINATION_PORTS\n          value: '8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/#blacklist-source-and-destination-ports","title":"Blacklist Source and Destination Ports","text":"<p>By default, the network experiments disrupt traffic for all the source and destination ports. The specific ports can be blacklisted via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: Provide the comma separated source ports preceded by <code>!</code>, that you'd like to blacklist from the chaos.</li> <li><code>DESTINATION_PORTS</code>: Provide the comma separated destination ports preceded by <code>!</code> , that you'd like to blacklist from the chaos.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># blacklist the source and destination ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # it will blacklist 80 and 8080 source ports\n        - name: SOURCE_PORTS\n          value: '!80,8080'\n        # it will blacklist 8080 and 9000 destination ports\n        - name: DESTINATION_PORTS\n          value: '!8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/#network-interface","title":"Network Interface","text":"<p>The defined name of the ethernet interface, which is considered for shaping traffic. It can be tuned via <code>NETWORK_INTERFACE</code> ENV. Its default value is <code>eth0</code>.</p> <p>Use the following example to tune this:</p> <pre><code># provide the network interface\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # name of the network interface\n        - name: NETWORK_INTERFACE\n          value: 'eth0'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/#jitter","title":"Jitter","text":"<p>It defines the jitter (in ms), a parameter that allows introducing a network delay variation. It can be tuned via <code>JITTER</code> ENV. Its default value is <code>0</code>.</p> <p>Use the following example to tune this:</p> <pre><code># provide the network latency jitter\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # value of the network latency jitter (in ms)\n        - name: JITTER\n          value: '200'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-latency/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>. Provide the traffic control image via <code>TC_IMAGE</code> ENV for the pumba library.</p> <p>Use the following example to tune this:</p> <pre><code># use pumba chaoslib for the network chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-latency-sa\n  experiments:\n  - name: pod-network-latency\n    spec:\n      components:\n        env:\n        # name of the chaoslib\n        # supports litmus and pumba lib\n        - name: LIB\n          value: 'pumba'\n        # image used for the traffic control in linux\n        # applicable for pumba lib only\n        - name: TC_IMAGE\n          value: 'gaiadocker/iproute2'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-loss/","title":"Pod Network Loss","text":""},{"location":"experiments/categories/pods/pod-network-loss/#introduction","title":"Introduction","text":"<ul> <li>It injects packet loss on the specified container by starting a traffic control (tc) process with netem rules to add egress loss</li> <li>It can test the application's resilience to lossy/flaky network</li> </ul> <p>Scenario: Induce network loss of the target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-network-loss/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-network-loss/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16</li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-network-loss</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> </ul>"},{"location":"experiments/categories/pods/pod-network-loss/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-network-loss/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-network-loss-sa\n  namespace: default\n  labels:\n    name: pod-network-loss-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-network-loss-sa\n  namespace: default\n  labels:\n    name: pod-network-loss-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # deriving the parent/owner details of the pod(if parent is anyof {deployment, statefulset, daemonsets})\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\",\"statefulsets\",\"replicasets\", \"daemonsets\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"apps.openshift.io\"]\n    resources: [\"deploymentconfigs\"]\n    verbs: [\"list\",\"get\"]\n  # deriving the parent/owner details of the pod(if parent is deploymentConfig)\n  - apiGroups: [\"\"]\n    resources: [\"replicationcontrollers\"]\n    verbs: [\"get\",\"list\"]\n  # deriving the parent/owner details of the pod(if parent is argo-rollouts)\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"rollouts\"]\n    verbs: [\"list\",\"get\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-network-loss-sa\n  namespace: default\n  labels:\n    name: pod-network-loss-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-network-loss-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-network-loss-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-network-loss/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   NETWORK_INTERFACE   Name of ethernet interface considered for shaping traffic    TARGET_CONTAINER    Name of container which is subjected to network loss   Optional   Applicable for containerd &amp; CRI-O runtime only. Even with these runtimes, if the value is not provided, it injects chaos on the first container of the pod  NETWORK_PACKET_LOSS_PERCENTAGE   The packet loss in percentage   Optional   Default to 100 percentage   CONTAINER_RUNTIME    container runtime interface for the cluster  Defaults to containerd, supported values: docker, containerd and crio for litmus and only docker for pumba LIB   SOCKET_PATH   Path of the containerd/crio/docker socket file   Defaults to <code>/run/containerd/containerd.sock</code>  TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Default (60s)   TARGET_PODS   Comma separated list of application pod name subjected to pod network corruption chaos  If not provided, it will select target pods randomly based on provided appLabels  DESTINATION_IPS   IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated IP(S) or CIDR(S) can be provided. if not provided, it will induce network chaos for all ips/destinations  DESTINATION_HOSTS   DNS Names/FQDN names of the services, the accessibility to which, is impacted   if not provided, it will induce network chaos for all ips/destinations or DESTINATION_IPS if already defined  SOURCE_PORTS   ports of the target application, the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  DESTINATION_PORTS   ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated port(s) can be provided. If not provided, it will induce network chaos for all ports  PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0 (corresponds to 1 replica), provide numeric value only   LIB   The chaos lib used to inject the chaos   Default value: litmus, supported values: pumba and litmus   TC_IMAGE   Image used for traffic control in linux   default value is <code>gaiadocker/iproute2</code>  LIB_IMAGE    Image used to run the netem command   Defaults to <code>litmuschaos/go-runner:latest</code>  RAMP_TIME   Period to wait before and after injection of chaos in sec   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel  </p>"},{"location":"experiments/categories/pods/pod-network-loss/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-network-loss/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables.</p>"},{"location":"experiments/categories/pods/pod-network-loss/#network-packet-loss","title":"Network Packet Loss","text":"<p>It defines the network packet loss percentage to be injected in the targeted application. It can be tuned via <code>NETWORK_PACKET_LOSS_PERCENTAGE</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it inject the network-loss for the egress traffic\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-loss-sa\n  experiments:\n  - name: pod-network-loss\n    spec:\n      components:\n        env:\n        # network packet loss percentage\n        - name: NETWORK_PACKET_LOSS_PERCENTAGE\n          value: '100'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-loss/#destination-ips-and-destination-hosts","title":"Destination IPs And Destination Hosts","text":"<p>The network experiments interrupt traffic for all the IPs/hosts by default. The interruption of specific IPs/Hosts can be tuned via <code>DESTINATION_IPS</code> and <code>DESTINATION_HOSTS</code> ENV.</p> <ul> <li><code>DESTINATION_IPS</code>: It contains the IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted.</li> <li><code>DESTINATION_HOSTS</code>: It contains the DNS Names/FQDN names of the services, the accessibility to which, is impacted.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the egress traffic for specific ips/hosts\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-loss-sa\n  experiments:\n  - name: pod-network-loss\n    spec:\n      components:\n        env:\n        # supports comma separated destination ips\n        - name: DESTINATION_IPS\n          value: '8.8.8.8,192.168.5.6'\n        # supports comma separated destination hosts\n        - name: DESTINATION_HOSTS\n          value: 'nginx.default.svc.cluster.local,google.com'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-loss/#source-and-destination-ports","title":"Source And Destination Ports","text":"<p>The network experiments interrupt traffic for all the source &amp; destination ports by default. The interruption of specific port(s) can be tuned via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: It contains ports of the target application, the accessibility to which is impacted</li> <li><code>DESTINATION_PORTS</code>: It contains the ports of the destination services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for the ingrees and egress traffic for specific ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-loss-sa\n  experiments:\n  - name: pod-network-loss\n    spec:\n      components:\n        env:\n        # supports comma separated source ports\n        - name: SOURCE_PORTS\n          value: '80'\n        # supports comma separated destination ports\n        - name: DESTINATION_PORTS\n          value: '8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-loss/#blacklist-source-and-destination-ports","title":"Blacklist Source and Destination Ports","text":"<p>By default, the network experiments disrupt traffic for all the source and destination ports. The specific ports can be blacklisted via <code>SOURCE_PORTS</code> and <code>DESTINATION_PORTS</code> ENV.</p> <ul> <li><code>SOURCE_PORTS</code>: Provide the comma separated source ports preceded by <code>!</code>, that you'd like to blacklist from the chaos.</li> <li><code>DESTINATION_PORTS</code>: Provide the comma separated destination ports preceded by <code>!</code> , that you'd like to blacklist from the chaos.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># blacklist the source and destination ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-loss-sa\n  experiments:\n  - name: pod-network-loss\n    spec:\n      components:\n        env:\n        # it will blacklist 80 and 8080 source ports\n        - name: SOURCE_PORTS\n          value: '!80,8080'\n        # it will blacklist 8080 and 9000 destination ports\n        - name: DESTINATION_PORTS\n          value: '!8080,9000'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-loss/#network-interface","title":"Network Interface","text":"<p>The defined name of the ethernet interface, which is considered for shaping traffic. It can be tuned via <code>NETWORK_INTERFACE</code> ENV. Its default value is <code>eth0</code>.</p> <p>Use the following example to tune this:</p> <pre><code># provide the network interface\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-loss-sa\n  experiments:\n  - name: pod-network-loss\n    spec:\n      components:\n        env:\n        # name of the network interface\n        - name: NETWORK_INTERFACE\n          value: 'eth0'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-loss/#container-runtime-socket-path","title":"Container Runtime Socket Path","text":"<p>It defines the <code>CONTAINER_RUNTIME</code> and <code>SOCKET_PATH</code> ENV to set the container runtime and socket file path.</p> <ul> <li><code>CONTAINER_RUNTIME</code>: It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes. The default value is <code>docker</code>.</li> <li><code>SOCKET_PATH</code>: It contains path of docker socket file by default(<code>/run/containerd/containerd.sock</code>). For other runtimes provide the appropriate path.</li> </ul> <p>Use the following example to tune this:</p> <pre><code>## provide the container runtime and socket file path\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-loss-sa\n  experiments:\n  - name: pod-network-loss\n    spec:\n      components:\n        env:\n        # runtime for the container\n        # supports docker, containerd, crio\n        - name: CONTAINER_RUNTIME\n          value: 'containerd'\n        # path of the socket file\n        - name: SOCKET_PATH\n          value: '/run/containerd/containerd.sock'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-loss/#pumba-chaos-library","title":"Pumba Chaos Library","text":"<p>It specifies the Pumba chaos library for the chaos injection. It can be tuned via <code>LIB</code> ENV. The defaults chaos library is <code>litmus</code>. Provide the traffic control image via <code>TC_IMAGE</code> ENV for the pumba library.</p> <p>Use the following example to tune this:</p> <pre><code># use pumba chaoslib for the network chaos\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-loss-sa\n  experiments:\n  - name: pod-network-loss\n    spec:\n      components:\n        env:\n        # name of the chaoslib\n        # supports litmus and pumba lib\n        - name: LIB\n          value: 'pumba'\n        # image used for the traffic control in linux\n        # applicable for pumba lib only\n        - name: TC_IMAGE\n          value: 'gaiadocker/iproute2'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-partition/","title":"Pod Network Partition","text":""},{"location":"experiments/categories/pods/pod-network-partition/#introduction","title":"Introduction","text":"<ul> <li>It blocks the 100% Ingress and Egress traffic of the target application by creating network policy.</li> <li>It can test the application's resilience to lossy/flaky network</li> </ul> <p>Scenario: Induce network loss of the target pod</p> <p></p>"},{"location":"experiments/categories/pods/pod-network-partition/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/pods/pod-network-partition/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>pod-network-partition</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here </li> </ul>"},{"location":"experiments/categories/pods/pod-network-partition/#default-validations","title":"Default Validations","text":"View the default validations <p>The application pods should be in running state before and after chaos injection.</p>"},{"location":"experiments/categories/pods/pod-network-partition/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-network-partition-sa\n  namespace: default\n  labels:\n    name: pod-network-partition-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-network-partition-sa\n  namespace: default\n  labels:\n    name: pod-network-partition-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # performs CRUD operations on the network policies\n  - apiGroups: [\"networking.k8s.io\"]\n    resources: [\"networkpolicies\"]\n    verbs: [\"create\",\"delete\",\"list\",\"get\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-network-partition-sa\n  namespace: default\n  labels:\n    name: pod-network-partition-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-network-partition-sa\nsubjects:\n- kind: ServiceAccount\n  name: pod-network-partition-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/pods/pod-network-partition/#experiment-tunables","title":"Experiment tunablesOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The time duration for chaos insertion (seconds)   Default (60s)   POLICY_TYPES   Contains type of network policy   It supports <code>egress</code>, <code>ingress</code> and <code>all</code> values  POD_SELECTOR   Contains labels of the destination pods   NAMESPACE_SELECTOR   Contains labels of the destination namespaces   PORTS   Comma separated list of the targeted ports   DESTINATION_IPS   IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted   comma separated IP(S) or CIDR(S) can be provided. if not provided, it will induce network chaos for all ips/destinations  DESTINATION_HOSTS   DNS Names/FQDN names of the services, the accessibility to which, is impacted   if not provided, it will induce network chaos for all ips/destinations or DESTINATION_IPS if already defined  LIB   The chaos lib used to inject the chaos   supported value: litmus   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/pods/pod-network-partition/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/pods/pod-network-partition/#common-and-pod-specific-tunables","title":"Common and Pod specific tunables","text":"<p>Refer the common attributes and Pod specific tunable to tune the common tunables for all experiments and pod specific tunables. </p>"},{"location":"experiments/categories/pods/pod-network-partition/#destination-ips-and-destination-hosts","title":"Destination IPs And Destination Hosts","text":"<p>The network partition experiment interrupt traffic for all the IPs/hosts by default. The interruption of specific IPs/Hosts can be tuned via <code>DESTINATION_IPS</code> and <code>DESTINATION_HOSTS</code> ENV.</p> <ul> <li><code>DESTINATION_IPS</code>: It contains the IP addresses of the services or pods or the CIDR blocks(range of IPs), the accessibility to which is impacted.</li> <li><code>DESTINATION_HOSTS</code>: It contains the DNS Names/FQDN names of the services, the accessibility to which, is impacted.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for specific ips/hosts\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-partition-sa\n  experiments:\n  - name: pod-network-partition\n    spec:\n      components:\n        env:\n        # supports comma separated destination ips\n        - name: DESTINATION_IPS\n          value: '8.8.8.8,192.168.5.6'\n        # supports comma separated destination hosts\n        - name: DESTINATION_HOSTS\n          value: 'nginx.default.svc.cluster.local,google.com'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-partition/#target-specific-namespaces","title":"Target Specific Namespace(s)","text":"<p>The network partition experiment interrupt traffic for all the namespaces by default. The access to/from pods in specific namespace can be allowed via providing namespace labels inside <code>NAMESPACE_SELECTOR</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for specified namespaces, matched by labels\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-partition-sa\n  experiments:\n  - name: pod-network-partition\n    spec:\n      components:\n        env:\n        # labels of the destination namespace\n        - name: NAMESPACE_SELECTOR\n          value: 'key=value'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-partition/#target-specific-pods","title":"Target Specific Pod(s)","text":"<p>The network partition experiment interrupt traffic for all the extranal pods by default. The access to/from specific pod(s) can be allowed via providing pod labels inside <code>POD_SELECTOR</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for specified pods, matched by labels\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-partition-sa\n  experiments:\n  - name: pod-network-partition\n    spec:\n      components:\n        env:\n        # labels of the destination pods\n        - name: POD_SELECTOR\n          value: 'key=value'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-partition/#policy-type","title":"Policy Type","text":"<p>The network partition experiment interrupt both ingress and egress traffic by default. The interruption of either <code>ingress</code> or <code>egress</code> traffic can be tuned via <code>POLICY_TYPES</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># inject network loss for only ingress or only engress or all traffics\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-partition-sa\n  experiments:\n  - name: pod-network-partition\n    spec:\n      components:\n        env:\n        # provide the network policy type\n        # it supports `ingress`, `egress`, and `all` values\n        # default value is `all`\n        - name: POLICY_TYPES\n          value: 'all'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/pods/pod-network-partition/#destination-ports","title":"Destination Ports","text":"<p>The network partition experiment interrupt traffic for all the external ports by default. Access to specific port(s) can be allowed by providing comma separated list of ports inside <code>PORTS</code> ENV. </p> <p>Note: </p> <ul> <li>If <code>PORT</code> is not set and none of the pod-selector, namespace-selector and destination_ips are provided then it will block traffic for all ports for all pods/ips</li> <li>If <code>PORT</code> is not set but any of the podselector, nsselector and destination ips are provided then it will allow all ports for all the pods/ips filtered by the specified selectors</li> </ul> <p>Use the following example to tune this:</p> <pre><code># it inject the chaos for specified ports\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-network-partition-sa\n  experiments:\n  - name: pod-network-partition\n    spec:\n      components:\n        env:\n        # comma separated list of ports\n        - name: PORTS\n          value: 'tcp: [8080,80], udp: [9000,90]'\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/","title":"Spring Boot App Kill","text":""},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#introduction","title":"Introduction","text":"<ul> <li>It can target random pods with a Spring Boot application and allows configuring the assaults to inject app-kill. When the configured methods are called in the application, it will shut down the application.</li> </ul> <p>Scenario: Kill Spring Boot Application</p> <p></p>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <p><ul> <li> Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here </li> <li> Ensure that the <code> spring-boot-app-kill </code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Chaos Monkey Spring Boot dependency should be present in the application. It can be enabled in two ways:       <ol> <li>Add internal dependency inside the spring boot application             <ol> <li>Add Chaos Monkey for Spring Boot as dependency for your project                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> Start your Spring Boot App with the chaos-monkey spring profile enabled                     <pre><code>java -jar your-app.jar --spring.profiles.active=chaos-monkey --chaos.monkey.enabled=true\n</code></pre> </li> </ol> </li> <li> Add as external dependency             <ol> <li>You can extend your existing application with the chaos-monkey and add it as an external dependency at startup, for this, it is necessary to use the PropertiesLauncher of Spring Boot                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;classifier&gt;jar-with-dependencies&lt;/classifier&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li>Start your Spring Boot application, add Chaos Monkey for Spring Boot JAR and properties                     <pre><code>java -cp your-app.jar -Dloader.path=chaos-monkey-spring-boot-2.6.1-jar-with-dependencies.jar org.springframework.boot.loader.PropertiesLauncher --spring.profiles.active=chaos-monkey --spring.config.location=file:./chaos-monkey.properties\n</code></pre> </li> </ol> </li> </ol> </li> </ul></p>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Spring boot pods are healthy before and after chaos injection</li> </ul>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre-installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: spring-boot-app-kill-sa\n  namespace: default\n  labels:\n    name: spring-boot-app-kill-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: spring-boot-app-kill-sa\n  namespace: default\n  labels:\n    name: spring-boot-app-kill-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute commands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: spring-boot-app-kill-sa\n  namespace: default\n  labels:\n    name: spring-boot-app-kill-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: spring-boot-app-kill-sa\nsubjects:\n  - kind: ServiceAccount\n    name: spring-boot-app-kill-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CM_PORT   It contains port of the spring boot application  </p> <p></p> <p>  Variables   Description   Notes   CM_LEVEL   It contains the number of requests to be attacked, n value means the nth request will be affected   Default value is 1, it lies in [1,10000] range   CM_WATCHED_CUSTOM_SERVICES   It limits watched packages/classes/methods by providing a comma-seperated list of fully qualified packages(class and/or method names)  Default is an empty list, which means it will target all services   CM_WATCHERS   It contains comma separated list of watchers from the following watchers list [controller, restController, service, repository, component, webClient]   Default it is <code> restController </code>  SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0% (corresponds to 1 replica)   LIB   The chaos lib used to inject the chaos   Defaults to <code>litmus</code>. Supported <code>litmus</code> only   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes and  Spring Boot specific tunable to tune the common tunables for all experiments and spring-boot specific tunables.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-app-kill/#spring-boot-application-port","title":"Spring Boot Application Port","text":"<p>It tunes the spring-boot application port via <code>CM_PORT</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># kill spring-boot target application\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-app-kill-sa\n  experiments:\n    - name: spring-boot-app-kill\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/","title":"Spring Boot CPU Stress","text":""},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#introduction","title":"Introduction","text":"<ul> <li>It can target random pods with a Spring Boot application and allows configuring the assaults to inject cpu-stress. Which attacks the CPU of the Java Virtual Machine. It tests the resiliency of the system when some applications are having unexpected faulty behavior.</li> </ul> <p>Scenario: Stress CPU of Spring Boot Application</p> <p></p>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <p><ul> <li> Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here </li> <li> Ensure that the <code> spring-boot-cpu-stress </code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Chaos Monkey Spring Boot dependency should be present in the application. It can be enabled in two ways:       <ol> <li>Add internal dependency inside the spring boot application             <ol> <li>Add Chaos Monkey for Spring Boot as dependency for your project                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> Start your Spring Boot App with the chaos-monkey spring profile enabled                     <pre><code>java -jar your-app.jar --spring.profiles.active=chaos-monkey --chaos.monkey.enabled=true\n</code></pre> </li> </ol> </li> <li> Add as external dependency             <ol> <li>You can extend your existing application with the chaos-monkey and add it as an external dependency at startup, for this it is necessary to use the PropertiesLauncher of Spring Boot                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;classifier&gt;jar-with-dependencies&lt;/classifier&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li>Start your Spring Boot application, add Chaos Monkey for Spring Boot JAR and properties                     <pre><code>java -cp your-app.jar -Dloader.path=chaos-monkey-spring-boot-2.6.1-jar-with-dependencies.jar org.springframework.boot.loader.PropertiesLauncher --spring.profiles.active=chaos-monkey --spring.config.location=file:./chaos-monkey.properties\n</code></pre> </li> </ol> </li> </ol> </li> </ul></p>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Spring boot pods are healthy before and after chaos injection</li> </ul>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre-installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: spring-boot-cpu-stress-sa\n  namespace: default\n  labels:\n    name: spring-boot-cpu-stress-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: spring-boot-cpu-stress-sa\n  namespace: default\n  labels:\n    name: spring-boot-cpu-stress-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute commands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: spring-boot-cpu-stress-sa\n  namespace: default\n  labels:\n    name: spring-boot-cpu-stress-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: spring-boot-cpu-stress-sa\nsubjects:\n  - kind: ServiceAccount\n    name: spring-boot-cpu-stress-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CM_PORT   It contains port of the spring boot application   CPU_LOAD_FRACTION   It contains fraction of CPU to be stressed, Eg: 0.95 equals 95%  Default value is 0.9. It supports a value in range [0.1,1.0] </p> <p></p> <p>  Variables   Description   Notes   CM_LEVEL   It contains number of requests are to be attacked, n value means nth request will be affected   Default value: 1, it lies in [1,10000] range   CM_WATCHED_CUSTOM_SERVICES   It limits watched packages/classes/methods, it contains comma seperated list of fully qualified packages(class and/or method names)  Default is an empty list, which means it will target all services   CM_WATCHERS   It contains comma separated list of watchers from the following watchers list [controller, restController, service, repository, component, webClient]   Default is <code> restController </code>  TOTAL_CHAOS_DURATION   The time duration for chaos injection (seconds)   Defaults to 30   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0% (corresponds to 1 replica)   LIB   The chaos lib used to inject the chaos   Defaults to <code>litmus</code>. Supported <code>litmus</code> only   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes and  Spring Boot specific tunable to tune the common tunables for all experiments and spring-boot specific tunables.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#spring-boot-application-port","title":"Spring Boot Application Port","text":"<p>It tunes the spring-boot application port via <code>CM_PORT</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># stress cpu of spring-boot application\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-cpu-stress-sa\n  experiments:\n    - name: spring-boot-cpu-stress\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-cpu-stress/#cpu-load-fraction","title":"CPU Load Fraction","text":"<p>It contains fraction of cpu to be stressed, 0.95 equals 95%. It can be tunes via <code>CPU_LOAD_FRACTION</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># provide the cpu load fraction to be stressed\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-cpu-stress-sa\n  experiments:\n    - name: spring-boot-cpu-stress\n      spec:\n        components:\n          env:\n            # it contains the fraction of the used CPU. Eg: 0.95 equals 95%.\n            # it supports value in range [0.1,1.0]\n            - name: CPU_LOAD_FRACTION\n              value: '0.9'\n\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/","title":"Spring Boot Exceptions","text":""},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#introduction","title":"Introduction","text":"<ul> <li>It can target random pods with a Spring Boot application and allows configuring the assaults to inject exceptions at runtime when the method is used. It tests the resiliency of the system when some applications are having unexpected faulty behavior.</li> </ul> <p>Scenario: Inject exceptions to Spring Boot Application</p> <p></p>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <p><ul> <li> Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here </li> <li> Ensure that the <code> spring-boot-exceptions </code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Chaos Monkey Spring Boot dependency should be present in application. It can be enabled by two ways:       <ol> <li>Add internal dependency inside the spring boot application             <ol> <li>Add Chaos Monkey for Spring Boot as dependency for your project                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> Start your Spring Boot App with the chaos-monkey spring profile enabled                     <pre><code>java -jar your-app.jar --spring.profiles.active=chaos-monkey --chaos.monkey.enabled=true\n</code></pre> </li> </ol> </li> <li> Add as external dependency             <ol> <li>You can extend your existing application with the chaos-monkey and add it as an external dependency at startup, for this it is necessary to use the PropertiesLauncher of Spring Boot                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;classifier&gt;jar-with-dependencies&lt;/classifier&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li>Start your Spring Boot application, add Chaos Monkey for Spring Boot JAR and properties                     <pre><code>java -cp your-app.jar -Dloader.path=chaos-monkey-spring-boot-2.6.1-jar-with-dependencies.jar org.springframework.boot.loader.PropertiesLauncher --spring.profiles.active=chaos-monkey --spring.config.location=file:./chaos-monkey.properties\n</code></pre> </li> </ol> </li> </ol> </li> </ul></p>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Spring boot pods are healthy before and after chaos injection</li> </ul>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre-installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: spring-boot-exceptions-sa\n  namespace: default\n  labels:\n    name: spring-boot-exceptions-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: spring-boot-exceptions-sa\n  namespace: default\n  labels:\n    name: spring-boot-exceptions-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute commands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: spring-boot-exceptions-sa\n  namespace: default\n  labels:\n    name: spring-boot-exceptions-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: spring-boot-exceptions-sa\nsubjects:\n  - kind: ServiceAccount\n    name: spring-boot-exceptions-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CM_PORT   It contains port of the spring boot application  </p> <p></p> <p>  Variables   Description   Notes   CM_EXCEPTIONS_TYPE   It contains type of raised exception   Defaults value: <code> java.lang.IllegalArgumentException </code>  CM_EXCEPTIONS_ARGUMENTS   It contains argument of raised exception   Defaults value: <code> java.lang.String:custom illegal argument exception </code>  CM_LEVEL   It contains number of requests are to be attacked, n value means nth request will be affected   Defaults value: 1, it lies in [1,10000] range   CM_WATCHED_CUSTOM_SERVICES   It limits watched packages/classes/methods, it contains comma seperated list of fully qualified packages(class and/or method names)  ByDefault it is empty list, which means it target all services   CM_WATCHERS   It contains comma separated list of watchers from the following watchers list [controller, restController, service, repository, component, webClient]   ByDefault it is <code> restController </code>  TOTAL_CHAOS_DURATION   The time duration for chaos injection (seconds)   Defaults to 30   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0% (corresponds to 1 replica)   LIB   The chaos lib used to inject the chaos   Defaults to <code>litmus</code>. Supported <code>litmus</code> only   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes and  Spring Boot specific tunable to tune the common tunables for all experiments and spring-boot specific tunables.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#spring-boot-application-port","title":"Spring Boot Application Port","text":"<p>It tunes the spring-boot application port via <code>CM_PORT</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># kill spring-boot target application\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-exceptions-sa\n  experiments:\n    - name: spring-boot-exceptions\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-exceptions/#exception-type-and-arguments","title":"Exception Type and Arguments","text":"<p>Spring boot exception type and arguments can be tuned via <code>CM_EXCEPTIONS_TYPE</code> and <code>CM_EXCEPTIONS_ARGUMENTS</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># provide the exception type and args\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-exceptions-sa\n  experiments:\n    - name: spring-boot-exceptions\n      spec:\n        components:\n          env:\n            # Type of raised exception\n            - name: CM_EXCEPTIONS_TYPE\n              value: 'java.lang.IllegalArgumentException'\n\n             # Argument of the raised exception\n            - name: CM_EXCEPTIONS_ARGUMENTS\n              value: 'java.lang.String:custom illegal argument exception'\n\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-experiments-tunables/","title":"Spring boot experiments tunables","text":"<p>It contains the Spring Boot specific experiment tunables.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-experiments-tunables/#spring-boot-request-level","title":"Spring Boot request Level","text":"<p>It contains number of requests are to be attacked, n value means each nth request will be affected. It can be tuned by <code>CM_LEVEL</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># limits the number of requests to be attacked\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-app-kill-sa\n  experiments:\n    - name: spring-boot-app-kill\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n\n            # it contains the number of requests that are to be attacked.\n            # n value means nth request will be affected\n            - name: CM_LEVEL\n              value: '1'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-experiments-tunables/#watch-custom-services","title":"Watch Custom Services","text":"<p>It contains comma seperated list of fully qualified packages(class and/or method names), which limits watched packages/classes/methods. It can be tuned by <code>CM_WATCHED_CUSTOM_SERVICES</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it contains comma separated list of custom services\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-app-kill-sa\n  experiments:\n    - name: spring-boot-app-kill\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n\n            # it limits watched packages/classes/methods\n            - name: CM_WATCHED_CUSTOM_SERVICES\n              value: 'com.example.chaosdemo.controller.HelloController.sayHello,com.example.chaosdemo.service.HelloService'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-experiments-tunables/#watchers","title":"Watchers","text":"<p>It contains comma separated list of watchers from the following watchers list [controller, restController, service, repository, component, webClient]. It can be tuned by <code>CM_WATCHERS</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># it contains comma separated list of watchers\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-app-kill-sa\n  experiments:\n    - name: spring-boot-app-kill\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n\n            # provide name of watcher\n            # it supports controller, restController, service, repository, component, webClient\n            - name: CM_WATCHERS\n              value: 'restController'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/","title":"Spring Boot Faults","text":""},{"location":"experiments/categories/spring-boot/spring-boot-faults/#introduction","title":"Introduction","text":"<ul> <li>It can target random pods with a Spring Boot application and allows configuring the assaults to inject multiple spring boot faults simultaneously on the target pod.</li> <li>It supports <code>app-kill</code>, <code>cpu-stress</code>, <code>memory-stress</code>, <code>latency</code>, and <code>exceptions</code> faults</li> </ul> <p>Scenario: Inject Spring Boot Faults</p> <p></p>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <p><ul> <li> Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here </li> <li> Ensure that the <code> spring-boot-faults </code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Chaos Monkey Spring Boot dependency should be present in application. It can be enabled by two ways:       <ol> <li>Add internal dependency inside the spring boot application             <ol> <li>Add Chaos Monkey for Spring Boot as dependency for your project                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> Start your Spring Boot App with the chaos-monkey spring profile enabled                     <pre><code>java -jar your-app.jar --spring.profiles.active=chaos-monkey --chaos.monkey.enabled=true\n</code></pre> </li> </ol> </li> <li> Add as external dependency             <ol> <li>You can extend your existing application with the chaos-monkey and add it as an external dependency at startup, for this it is necessary to use the PropertiesLauncher of Spring Boot                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;classifier&gt;jar-with-dependencies&lt;/classifier&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li>Start your Spring Boot application, add Chaos Monkey for Spring Boot JAR and properties                     <pre><code>java -cp your-app.jar -Dloader.path=chaos-monkey-spring-boot-2.6.1-jar-with-dependencies.jar org.springframework.boot.loader.PropertiesLauncher --spring.profiles.active=chaos-monkey --spring.config.location=file:./chaos-monkey.properties\n</code></pre> </li> </ol> </li> </ol> </li> </ul></p>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Spring boot pods are healthy before and after chaos injection</li> </ul>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre-installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: spring-boot-faults-sa\n  namespace: default\n  labels:\n    name: spring-boot-faults-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: spring-boot-faults-sa\n  namespace: default\n  labels:\n    name: spring-boot-faults-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute commands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: spring-boot-faults-sa\n  namespace: default\n  labels:\n    name: spring-boot-faults-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: spring-boot-faults-sa\nsubjects:\n  - kind: ServiceAccount\n    name: spring-boot-faults-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CM_PORT   It contains port of the spring boot application   CM_KILL_APPLICATION_ACTIVE   It enable the app-kill faults  It supports boolean values. Default is false  CM_LATENCY_ACTIVE   It enable the latency faults  It supports boolean values. Default is false  CM_MEMORY_ACTIVE   It enable the memory stress faults  It supports boolean values. Default is false  CM_CPU_ACTIVE   It enable the cpu stress faults  It supports boolean values. Default is false  CM_EXCEPTIONS_ACTIVE   It enable the exceptions faults  It supports boolean values. Default is false  CPU_LOAD_FRACTION   It contains fraction of cpu to be stressed, 0.95 equals 95%  default value is 0.9. It supports value in range [0.1,1.0]  CM_EXCEPTIONS_TYPE   It contains type of raised exception   Defaults value: <code> java.lang.IllegalArgumentException </code>  CM_EXCEPTIONS_ARGUMENTS   It contains argument of raised exception   Defaults value: <code> java.lang.String:custom illegal argument exception </code>  LATENCY   It contains network latency to be injected(in ms)  default value is 2000  MEMORY_FILL_FRACTION   It contains fraction of memory to be stressed, 0.7 equals 70%  default value is 0.70. It supports value in range [0.01,0.95] </p> <p></p> <p>  Variables   Description   Notes   CM_LEVEL   It contains number of requests are to be attacked, n value means nth request will be affected   Defaults value: 1, it lies in [1,10000] range   CM_WATCHED_CUSTOM_SERVICES   It limits watched packages/classes/methods, it contains comma seperated list of fully qualified packages(class and/or method names)  ByDefault it is empty list, which means it target all services   CM_WATCHERS   It contains comma separated list of watchers from the following watchers list [controller, restController, service, repository, component, webClient]   ByDefault it is <code> restController </code>  TOTAL_CHAOS_DURATION   The time duration for chaos injection (seconds)   Defaults to 30   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0% (corresponds to 1 replica)   LIB   The chaos lib used to inject the chaos   Defaults to <code>litmus</code>. Supported <code>litmus</code> only   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/spring-boot/spring-boot-faults/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes and  Spring Boot specific tunable to tune the common tunables for all experiments and spring-boot specific tunables.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#inject-multiple-faults-simultaneously-cpu-latency-and-exceptions","title":"Inject Multiple Faults Simultaneously (CPU, Latency and Exceptions)","text":"<p>It injects cpu, latency, and exceptions faults simultaneously on the target pods</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-faults-sa\n  experiments:\n    - name: spring-boot-faults\n      spec:\n        components:\n          env:\n            # set chaos duration (in sec) as desired\n            - name: TOTAL_CHAOS_DURATION\n              value: '30'\n\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n\n            # it enables spring-boot latency fault\n            - name: CM_LATENCY_ACTIVE\n              value: 'true'\n\n            # provide the latency (ms)\n            # it is applicable when latency is active\n            - name: LATENCY\n              value: '2000'\n\n            # it enables spring-boot cpu stress fault\n            - name: CM_CPU_ACTIVE\n              value: 'true'\n\n            # it contains fraction of cpu to be stressed(0.95 equals 95%)\n            # it supports value in range [0.1,1.0]\n            # it is applicable when cpu is active\n            - name: CPU_LOAD_FRACTION\n              value: '0.9'\n\n            # it enables spring-boot exceptions fault\n            - name: CM_EXCEPTIONS_ACTIVE\n              value: 'true'\n\n            # Type of raised exception\n            # it is applicable when exceptions is active\n            - name: CM_EXCEPTIONS_TYPE\n              value: 'java.lang.IllegalArgumentException'\n\n              # Argument of raised exception\n              # it is applicable when exceptions is active\n            - name: CM_EXCEPTIONS_ARGUMENTS\n              value: 'java.lang.String:custom illegal argument exception'\n\n            ## percentage of total pods to target\n            - name: PODS_AFFECTED_PERC\n              value: ''\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-faults/#inject-multiple-faults-simultaneously-appkill-and-memory","title":"Inject Multiple Faults Simultaneously (Appkill and Memory)","text":"<p>It injects appkill and memory stress faults simultaneously on the target pods</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-faults-sa\n  experiments:\n    - name: spring-boot-faults\n      spec:\n        components:\n          env:\n            # set chaos duration (in sec) as desired\n            - name: TOTAL_CHAOS_DURATION\n              value: '30'\n\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n\n            # it enables spring app-kill fault\n            - name: CM_KILL_APPLICATION_ACTIVE\n              value: 'true'\n\n            # it enables spring-boot memory stress fault\n            - name: CM_MEMORY_ACTIVE\n              value: ''\n\n            # it contains fraction of memory to be stressed(0.70 equals 70%)\n            # it supports value in range [0.01,0.95]\n            # it is applicable when memory is active\n            - name: MEMORY_FILL_FRACTION\n              value: '0.70'\n\n            ## percentage of total pods to target\n            - name: PODS_AFFECTED_PERC\n              value: ''\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/","title":"Spring Boot Latency","text":""},{"location":"experiments/categories/spring-boot/spring-boot-latency/#introduction","title":"Introduction","text":"<ul> <li>It can target random pods with a Spring Boot application and allows configuring the assaults to inject network latency to every nth request. This can be tuned via <code>CM_LEVEL</code> ENV.</li> </ul> <p>Scenario: Inject network latency to Spring Boot Application</p> <p></p>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <p><ul> <li> Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here </li> <li> Ensure that the <code> spring-boot-latency </code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Chaos Monkey Spring Boot dependency should be present in application. It can be enabled by two ways:       <ol> <li>Add internal dependency inside the spring boot application             <ol> <li>Add Chaos Monkey for Spring Boot as dependency for your project                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> Start your Spring Boot App with the chaos-monkey spring profile enabled                     <pre><code>java -jar your-app.jar --spring.profiles.active=chaos-monkey --chaos.monkey.enabled=true\n</code></pre> </li> </ol> </li> <li> Add as external dependency             <ol> <li>You can extend your existing application with the chaos-monkey and add it as an external dependency at startup, for this it is necessary to use the PropertiesLauncher of Spring Boot                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;classifier&gt;jar-with-dependencies&lt;/classifier&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li>Start your Spring Boot application, add Chaos Monkey for Spring Boot JAR and properties                     <pre><code>java -cp your-app.jar -Dloader.path=chaos-monkey-spring-boot-2.6.1-jar-with-dependencies.jar org.springframework.boot.loader.PropertiesLauncher --spring.profiles.active=chaos-monkey --spring.config.location=file:./chaos-monkey.properties\n</code></pre> </li> </ol> </li> </ol> </li> </ul></p>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Spring boot pods are healthy before and after chaos injection</li> </ul>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre-installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: spring-boot-latency-sa\n  namespace: default\n  labels:\n    name: spring-boot-latency-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: spring-boot-latency-sa\n  namespace: default\n  labels:\n    name: spring-boot-latency-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute commands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: spring-boot-latency-sa\n  namespace: default\n  labels:\n    name: spring-boot-latency-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: spring-boot-latency-sa\nsubjects:\n  - kind: ServiceAccount\n    name: spring-boot-latency-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CM_PORT   It contains port of the spring boot application   LATENCY   It contains network latency to be injected(in ms)  default value is 2000 </p> <p></p> <p>  Variables   Description   Notes   CM_LEVEL   It contains number of requests are to be attacked, n value means nth request will be affected   Defaults value: 1, it lies in [1,10000] range   CM_WATCHED_CUSTOM_SERVICES   It limits watched packages/classes/methods, it contains comma seperated list of fully qualified packages(class and/or method names)  ByDefault it is empty list, which means it target all services   CM_WATCHERS   It contains comma separated list of watchers from the following watchers list [controller, restController, service, repository, component, webClient]   ByDefault it is <code> restController </code>  TOTAL_CHAOS_DURATION   The time duration for chaos injection (seconds)   Defaults to 30   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0% (corresponds to 1 replica)   LIB   The chaos lib used to inject the chaos   Defaults to <code>litmus</code>. Supported <code>litmus</code> only   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/spring-boot/spring-boot-latency/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes and  Spring Boot specific tunable to tune the common tunables for all experiments and spring-boot specific tunables.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#spring-boot-application-port","title":"Spring Boot Application Port","text":"<p>It tunes the spring-boot application port via <code>CM_PORT</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># kill spring-boot target application\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-latency-sa\n  experiments:\n    - name: spring-boot-latency\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-latency/#network-latency","title":"Network Latency","text":"<p>It contains network latency value in ms. It can be tunes via <code>LATENCY</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># provide the network latency\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-latency-sa\n  experiments:\n    - name: spring-boot-latency\n      spec:\n        components:\n          env:\n            # provide the latency (ms)\n            - name: LATENCY\n              value: '2000'\n\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/","title":"Spring Boot Memory Stress","text":""},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#introduction","title":"Introduction","text":"<ul> <li>It can target random pods with a Spring Boot application and allows configuring the assaults to inject memory-stress. Which attacks the memory of the Java Virtual Machine. It tests the resiliency of the system when some applications are having unexpected faulty behavior.</li> </ul> <p>Scenario: Stress Memory of Spring Boot Application</p> <p></p>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <p><ul> <li> Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here </li> <li> Ensure that the <code> spring-boot-memory-stress </code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Chaos Monkey Spring Boot dependency should be present in application. It can be enabled by two ways:       <ol> <li>Add internal dependency inside the spring boot application             <ol> <li>Add Chaos Monkey for Spring Boot as dependency for your project                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> Start your Spring Boot App with the chaos-monkey spring profile enabled                     <pre><code>java -jar your-app.jar --spring.profiles.active=chaos-monkey --chaos.monkey.enabled=true\n</code></pre> </li> </ol> </li> <li> Add as external dependency             <ol> <li>You can extend your existing application with the chaos-monkey and add it as an external dependency at startup, for this it is necessary to use the PropertiesLauncher of Spring Boot                     <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;\n    &lt;artifactId&gt;chaos-monkey-spring-boot&lt;/artifactId&gt;\n    &lt;classifier&gt;jar-with-dependencies&lt;/classifier&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li>Start your Spring Boot application, add Chaos Monkey for Spring Boot JAR and properties                     <pre><code>java -cp your-app.jar -Dloader.path=chaos-monkey-spring-boot-2.6.1-jar-with-dependencies.jar org.springframework.boot.loader.PropertiesLauncher --spring.profiles.active=chaos-monkey --spring.config.location=file:./chaos-monkey.properties\n</code></pre> </li> </ol> </li> </ol> </li> </ul></p>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>Spring boot pods are healthy before and after chaos injection</li> </ul>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre-installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: spring-boot-memory-stress-sa\n  namespace: default\n  labels:\n    name: spring-boot-memory-stress-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: spring-boot-memory-stress-sa\n  namespace: default\n  labels:\n    name: spring-boot-memory-stress-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]\n  # for creating and managing to execute commands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: spring-boot-memory-stress-sa\n  namespace: default\n  labels:\n    name: spring-boot-memory-stress-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: spring-boot-memory-stress-sa\nsubjects:\n  - kind: ServiceAccount\n    name: spring-boot-memory-stress-sa\n    namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   CM_PORT   It contains port of the spring boot application   MEMORY_FILL_FRACTION   It contains fraction of memory to be stressed, 0.7 equals 70%  default value is 0.70. It supports value in range [0.01,0.95] </p> <p></p> <p>  Variables   Description   Notes   CM_LEVEL   It contains number of requests are to be attacked, n value means nth request will be affected   Defaults value: 1, it lies in [1,10000] range   CM_WATCHED_CUSTOM_SERVICES   It limits watched packages/classes/methods, it contains comma seperated list of fully qualified packages(class and/or method names)  ByDefault it is empty list, which means it target all services   CM_WATCHERS   It contains comma separated list of watchers from the following watchers list [controller, restController, service, repository, component, webClient]   ByDefault it is <code> restController </code>  TOTAL_CHAOS_DURATION   The time duration for chaos injection (seconds)   Defaults to 30   SEQUENCE   It defines sequence of chaos execution for multiple target pods   Default value: parallel. Supported: serial, parallel   PODS_AFFECTED_PERC   The Percentage of total pods to target    Defaults to 0% (corresponds to 1 replica)   LIB   The chaos lib used to inject the chaos   Defaults to <code>litmus</code>. Supported <code>litmus</code> only   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes and  Spring Boot specific tunable to tune the common tunables for all experiments and spring-boot specific tunables.</p>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#spring-boot-application-port","title":"Spring Boot Application Port","text":"<p>It tunes the spring-boot application port via <code>CM_PORT</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># stress memory of spring-boot application\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-memory-stress-sa\n  experiments:\n    - name: spring-boot-memory-stress\n      spec:\n        components:\n          env:\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/spring-boot/spring-boot-memory-stress/#memory-fill-fraction","title":"Memory Fill Fraction","text":"<p>It contains fraction of memory to be stressed, 0.70 equals 70%. It can be tunes via <code>MEMORY_FILL_FRACTION</code> ENV</p> <p>Use the following example to tune this:</p> <pre><code># provide the memory fraction to be filled\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: spring-boot-chaos\n  namespace: default\nspec:\n  appinfo:\n    appns: 'default'\n    applabel: 'app=spring-boot'\n    appkind: 'deployment'\n  # It can be active/stop\n  engineState: 'active'\n  chaosServiceAccount: spring-boot-memory-stress-sa\n  experiments:\n    - name: spring-boot-memory-stress\n      spec:\n        components:\n          env:\n            # it contains the fraction of used CPU. Eg: 0.70 equals 70%.\n            # it supports value in range [0.01,0.95]\n            - name: MEMORY_FILL_FRACTION\n              value: '0.70'\n\n            # port of the spring boot application\n            - name: CM_PORT\n              value: '8080'\n</code></pre>"},{"location":"experiments/categories/vmware/vm-poweroff/","title":"VM Poweroff","text":""},{"location":"experiments/categories/vmware/vm-poweroff/#introduction","title":"Introduction","text":"<ul> <li>It causes VMWare VMs to Stop/Power-off before bringing them back to Powered-on state after a specified chaos duration using the VMWare APIs to start/stop the target VM.</li> <li>It helps to check the performance of the application/process running on the VMWare VMs.</li> </ul> <p>Scenario: poweroff the vm</p> <p></p>"},{"location":"experiments/categories/vmware/vm-poweroff/#uses","title":"Uses","text":"View the uses of the experiment <p>coming soon</p>"},{"location":"experiments/categories/vmware/vm-poweroff/#prerequisites","title":"Prerequisites","text":"Verify the prerequisites <ul> <li>Ensure that Kubernetes Version &gt; 1.16 </li> <li>Ensure that the Litmus Chaos Operator is running by executing <code>kubectl get pods</code> in operator namespace (typically, <code>litmus</code>).If not, install from here</li> <li>Ensure that the <code>vm-poweroff</code> experiment resource is available in the cluster by executing <code>kubectl get chaosexperiments</code> in the desired namespace. If not, install from here</li> <li>Ensure that you have sufficient Vcenter access to stop and start the VM.</li> <li> <p>(Optional) Ensure to create a Kubernetes secret having the Vcenter credentials in the <code>CHAOS_NAMESPACE</code>. A sample secret file looks like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: vcenter-secret\n  namespace: litmus\ntype: Opaque\nstringData:\n    VCENTERSERVER: XXXXXXXXXXX\n    VCENTERUSER: XXXXXXXXXXXXX\n    VCENTERPASS: XXXXXXXXXXXXX\n</code></pre> </li> </ul> <p>Note: You can pass the VM credentials as secrets or as an chaosengine ENV variable. </p>"},{"location":"experiments/categories/vmware/vm-poweroff/#default-validations","title":"Default Validations","text":"View the default validations <ul> <li>VM should be in healthy state.</li> </ul>"},{"location":"experiments/categories/vmware/vm-poweroff/#minimal-rbac-configuration-example-optional","title":"Minimal RBAC configuration example (optional)","text":"<p>NOTE</p> <p>If you are using this experiment as part of a litmus workflow scheduled constructed &amp; executed from chaos-center, then you may be making use of the litmus-admin RBAC, which is pre installed in the cluster as part of the agent setup.</p> View the Minimal RBAC permissions <p><pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: vm-poweroff-sa\n  namespace: default\n  labels:\n    name: vm-poweroff-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: vm-poweroff-sa\n  labels:\n    name: vm-poweroff-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n  # Create and monitor the experiment &amp; helper pods\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\", \"deletecollection\"]\n  # Performs CRUD operations on the events inside chaosengine and chaosresult\n  - apiGroups: [\"\"]\n    resources: [\"events\"]\n    verbs: [\"create\",\"get\",\"list\",\"patch\",\"update\"]\n  # Fetch configmaps &amp; secrets details and mount it to the experiment pod (if specified)\n  - apiGroups: [\"\"]\n    resources: [\"secrets\",\"configmaps\"]\n    verbs: [\"get\",\"list\",]\n  # Track and get the runner, experiment, and helper pods log \n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\",\"list\",\"watch\"]  \n  # for creating and managing to execute comands inside target container\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"get\",\"list\",\"create\"]\n  # for configuring and monitor the experiment job by the chaos-runner pod\n  - apiGroups: [\"batch\"]\n    resources: [\"jobs\"]\n    verbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n  # for creation, status polling and deletion of litmus chaos resources used within a chaos workflow\n  - apiGroups: [\"litmuschaos.io\"]\n    resources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\n    verbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: vm-poweroff-sa\n  labels:\n    name: vm-poweroff-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: vm-poweroff-sa\nsubjects:\n- kind: ServiceAccount\n  name: vm-poweroff-sa\n  namespace: default\n</code></pre> Use this sample RBAC manifest to create a chaosServiceAccount in the desired (app) namespace. This example consists of the minimum necessary role permissions to execute the experiment.</p>"},{"location":"experiments/categories/vmware/vm-poweroff/#experiment-tunables","title":"Experiment tunablesMandatory FieldsOptional Fields","text":"check the experiment tunables <p>  Variables   Description   Notes   APP_VM_MOIDS   MOIDs of the vmware instance  Once you open VM in vCenter WebClient, you can find MOID in address field (VirtualMachine:vm-5365). Alternatively you can use the CLI to fetch the MOID. Eg: vm-5365  </p> <p></p> <p>  Variables   Description   Notes   TOTAL_CHAOS_DURATION   The total time duration for chaos insertion (sec)   Defaults to 30s   CHAOS_INTERVAL   The interval (in sec) between successive instance termination   Defaults to 30s   SEQUENCE   It defines sequence of chaos execution for multiple instance   Default value: parallel. Supported: serial, parallel   RAMP_TIME   Period to wait before and after injection of chaos in sec  </p>"},{"location":"experiments/categories/vmware/vm-poweroff/#experiment-examples","title":"Experiment Examples","text":""},{"location":"experiments/categories/vmware/vm-poweroff/#common-experiment-tunables","title":"Common Experiment Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the experiments.</p>"},{"location":"experiments/categories/vmware/vm-poweroff/#stoppoweroff-vm-by-moid","title":"Stop/Poweroff VM By MOID","text":"<p>It contains MOID of the vm instance. It can be tuned via <code>APP_VM_MOIDS</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># power-off the VMWare VM\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  chaosServiceAccount: vm-poweroff-sa\n  experiments:\n  - name: vm-poweroff\n    spec:\n      components:\n        env:\n        # MOID of the VM\n        - name: APP_VM_MOIDS\n          value: 'vm-53,vm-65'\n\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/concepts/IAM/awsIamIntegration/","title":"IAM integration for Litmus service accounts","text":"<p>You can execute Litmus AWS experiments to target different AWS services from the EKS cluster itself, for this we need to authenticate Litmus with the AWS platform, we can do this in two different ways:</p> <ul> <li> Using secrets: It is one of the common ways to authenticate litmus with AWS irrespective of the Kubernetes cluster used for the deployment. In other words, it is Kubernetes\u2019 native way for the authentication of litmus with the AWS platform. </li> <li> IAM Integration: It can be used when we\u2019ve deployed Litmus on <code>EKS cluster</code>, we can associate an IAM role with a Kubernetes service account. This service account can then provide AWS permissions to the experiment pod that uses that service account. We\u2019ll discuss more this method in the below sections.</li> </ul>"},{"location":"experiments/concepts/IAM/awsIamIntegration/#why-should-we-use-iam-integration-for-aws-authentication","title":"Why should we use IAM integration for AWS authentication?","text":"<p>The IAM roles for service accounts feature provides the following benefits:</p> <ul> <li> Least privilege: By using the IAM roles for service accounts feature, you no longer need to provide extended permissions to the node IAM role so that pods on that node can call AWS APIs. You can scope IAM permissions to a service account, and only pods that use that service account have access to those permissions.</li> <li> Credential isolation: The experiment can only retrieve credentials for the IAM role that is associated with the service account to which it belongs. The experiment never has access to credentials that are intended for another experiment that belongs to another pod.</li> </ul>"},{"location":"experiments/concepts/IAM/awsIamIntegration/#enable-service-accounts-to-access-aws-resources","title":"Enable service accounts to access AWS resources:","text":""},{"location":"experiments/concepts/IAM/awsIamIntegration/#step-1-create-an-iam-oidc-provider-for-your-cluster","title":"Step 1: Create an IAM OIDC provider for your cluster","text":"<p>We need to perform this once for a cluster. We\u2019re going to follow the AWS documentation to setup an OIDC provider with eksctl.</p> <p>Check whether you have an existing IAM OIDC provider for your cluster: To check this you can follow the given instruction.</p> <p>Note: For demonstration we\u2019ll be using cluster name as litmus-demo and region us-west-1 you can replace these values according to your ENV.</p> <p><pre><code>aws eks describe-cluster --name &lt;litmus-demo&gt; --query \"cluster.identity.oidc.issuer\" --output text\n</code></pre> Output:</p> <pre><code>https://oidc.eks.us-west-1.amazonaws.com/id/D054E55B6947B1A7B3F200297789662C\n</code></pre> <p>Now list the IAM OIDC providers in your account.</p> <p>Command:</p> <pre><code>aws iam list-open-id-connect-providers | grep &lt;EXAMPLED539D4633E53DE1B716D3041E&gt;\n</code></pre> <p>Replace <code>&lt;D054E55B6947B1A7B3F200297789662C&gt;</code> (including <code>&lt;&gt;</code>) with the value returned from the previous command.</p> <p>So now here we don\u2019t have an IAM OIDC identity provider, So we need to create it for your cluster with the following command. Replace <code>&lt;litmus-demo&gt;</code> (<code>including &lt;&gt;</code>) with your own value.</p> <pre><code>eksctl utils associate-iam-oidc-provider --cluster litmus-demo --approve\n2021-09-07 14:54:01 [\u2139]  eksctl version 0.52.0\n2021-09-07 14:54:01 [\u2139]  using region us-west-1\n2021-09-07 14:54:04 [\u2139]  will create IAM Open ID Connect provider for cluster \"udit-cluster-11\" in \"us-west-1\"\n2021-09-07 14:54:05 [\u2714]  created IAM Open ID Connect provider for cluster \"litmus-demo\" in \"us-west-1\"\n</code></pre>"},{"location":"experiments/concepts/IAM/awsIamIntegration/#step-2-creating-an-iam-role-and-policy-for-your-service-account","title":"Step 2: Creating an IAM role and policy for your service account","text":"<p>You must create an IAM policy that specifies the permissions that you would like the experiment should to have. You have several ways to create a new IAM permission policy. Check out the AWS docs for creating the IAM policy. We will make use of eksctl command to setup the same.</p> <pre><code>eksctl create iamserviceaccount \\\n--name &lt;service_account_name&gt; \\\n--namespace &lt;service_account_namespace&gt; \\\n--cluster &lt;cluster_name&gt; \\\n--attach-policy-arn &lt;IAM_policy_ARN&gt; \\\n--approve \\\n--override-existing-serviceaccounts\n</code></pre>"},{"location":"experiments/concepts/IAM/awsIamIntegration/#step-3-associate-an-iam-role-with-a-service-account","title":"Step 3: Associate an IAM role with a service account","text":"<p>Complete this task for each Kubernetes service account that needs access to AWS resources. We can do this by defining the IAM role to associate with a service account in your cluster by adding the following annotation to the service account.</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  annotations:\n    eks.amazonaws.com/role-arn: arn:aws:iam::&lt;ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;\n</code></pre> <p>You can also annotate the experiment service account running the following command.</p> <p>Notes: 1. Ideally, annotating the <code>litmus-admin</code> service account in <code>litmus</code> namespace should work for most of the experiments. 2. For the cluster autoscaler experiment, annotate the service account in the <code>kube-system</code> namespace.</p> <pre><code>kubectl annotate serviceaccount -n &lt;SERVICE_ACCOUNT_NAMESPACE&gt; &lt;SERVICE_ACCOUNT_NAME&gt; \\\neks.amazonaws.com/role-arn=arn:aws:iam::&lt;ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;\n</code></pre> <p>Verify that the experiment service account is now associated with the IAM.</p> <p>If you run an experiment and describe one of the pods, you can verify that the <code>AWS_WEB_IDENTITY_TOKEN_FILE</code> and <code>AWS_ROLE_ARN</code> environment variables exist.</p> <p><pre><code>kubectl exec -n litmus &lt;ec2-terminate-by-id-z4zdf&gt; env | grep AWS\n</code></pre> Output: <pre><code>AWS_VPC_K8S_CNI_LOGLEVEL=DEBUG\nAWS_ROLE_ARN=arn:aws:iam::&lt;ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;\nAWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token\n</code></pre></p> <p>Now we have successfully enabled the experiment service accounts to access AWS resources.</p>"},{"location":"experiments/concepts/IAM/awsIamIntegration/#configure-the-experiment-cr","title":"Configure the Experiment CR.","text":"<p>Since we have already configured the IAM for the experiment service account we don\u2019t need to create secret and mount it with experiment CR which is enabled by default. To remove the secret mount we have to remove the following lines from experiment YAML. </p> <p><pre><code>secrets:\n- name: cloud-secret\n    mountPath: /tmp/\n</code></pre> We can now run the experiment with the direct IAM integration.</p>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/","title":"IAM integration for Litmus service accounts","text":"<p>To execute LitmusChaos GCP experiments, one needs to authenticate with the GCP by means of a service account before trying to access the target resources. Usually, you have only one way of providing the service account credentials to the experiment, using a service account key, but if you're using a GKE cluster you have a keyless medium of authentication as well. </p> <p>Therefore you have two ways of providing the service account credentials to your GKE cluster:</p> <ul> <li> <p>Using Secrets: As you would normally do, you can create a secret containing the GCP service account in your GKE cluster, which gets utilized by the experiment for authentication to access your GCP resources.</p> </li> <li> <p>IAM Integration: When you're using a GKE cluster, you can bind a GCP service account to a Kubernetes service account as an IAM policy, which can be then used by the experiment for keyless authentication using GCP Workload Identity. We\u2019ll discuss more on this method in the following sections.</p> </li> </ul>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#why-use-iam-integration-for-gcp-authentication","title":"Why use IAM integration for GCP authentication?","text":"<p>A Google API request can be made using a GCP IAM service account, which is an identity that an application uses to make calls to Google APIs. You might create individual IAM service accounts for each application as an application developer, then download and save the keys as a Kubernetes secret that you manually rotate. Not only is this a time-consuming process, but service account keys only last ten years (or until you manually rotate them). An unaccounted-for key could give an attacker extended access in the event of a breach or compromise. Using service account keys as secrets is not an optimal way of authenticating GKE workloads due to this potential blind spot and the management cost of key inventory and rotation.</p> <p>Workload Identity allows you to restrict the possible \"blast radius\" of a breach or compromise while enforcing the principle of least privilege across your environment. It accomplishes this by automating workload authentication best practices, eliminating the need for workarounds, and making it simple to implement recommended security best practices.</p> <ul> <li> <p>Your tasks will only have the permissions they require to fulfil their role with the principle of least privilege. It minimizes the breadth of a potential compromise by not granting broad permissions.</p> </li> <li> <p>Unlike the 10-year lifetime service account keys, credentials supplied to the Workload Identity are only valid for a short time, decreasing the blast radius in the case of a compromise.</p> </li> <li> <p>The risk of unintentional disclosure of credentials due to a human mistake is greatly reduced because Google controls the namespace service account credentials for you. It also eliminates the need for you to manually rotate these credentials.</p> </li> </ul>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#how-to-enable-service-accounts-to-access-gcp-resources","title":"How to enable service accounts to access GCP resources?","text":"<p>We will be following the steps from the GCP Documentation for Workload Identity</p>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#step-1-enable-workload-identity","title":"STEP 1: Enable Workload Identity","text":"<p>You can enable Workload Identity on clusters and node pools using the Google Cloud CLI or the Google Cloud Console. Workload Identity must be enabled at the cluster level before you can enable Workload Identity on node pools.</p> <p>Workload Identity can be enabled for an existing cluster as well as a new cluster. To enable Workload Identity on a new cluster, run the following command: <pre><code>gcloud container clusters create CLUSTER_NAME \\\n    --region=COMPUTE_REGION \\\n    --workload-pool=PROJECT_ID.svc.id.goog\n</code></pre> Replace the following: - CLUSTER_NAME: the name of your new cluster. - COMPUTE_REGION: the Compute Engine region of your cluster. For zonal clusters, use --zone=COMPUTE_ZONE. - PROJECT_ID: your Google Cloud project ID.</p> <p>You can enable Workload Identity on an existing Standard cluster by using the gcloud CLI or the Cloud Console. Existing node pools are unaffected, but any new node pools in the cluster use Workload Identity. To enable Workload Identity on an existing cluster, run the following command:</p> <p><pre><code>gcloud container clusters update CLUSTER_NAME \\\n    --region=COMPUTE_REGION \\\n    --workload-pool=PROJECT_ID.svc.id.goog\n</code></pre> Replace the following: - CLUSTER_NAME: the name of your new cluster. - COMPUTE_REGION: the Compute Engine region of your cluster. For zonal clusters, use --zone=COMPUTE_ZONE. - PROJECT_ID: your Google Cloud project ID.</p>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#step-2-configure-litmuschaos-to-use-workload-identity","title":"STEP 2: Configure LitmusChaos to use Workload Identity","text":"<p>Assuming that you already have LitmusChaos installed in your GKE cluster as well as the Kubernetes service account you want to use for your GCP experiments, execute the following steps.</p> <ol> <li> <p>Get Credentials for your cluster. <pre><code>gcloud container clusters get-credentials CLUSTER_NAME\n</code></pre> Replace CLUSTER_NAME with the name of your cluster that has Workload Identity enabled.</p> </li> <li> <p>Create an IAM service account for your application or use an existing IAM service account instead. You can use any IAM service account in any project in your organization. For Config Connector, apply the <code>IAMServiceAccount</code> object for your selected service account. To create a new IAM service account using the gcloud CLI, run the following command: <pre><code>gcloud iam service-accounts create GSA_NAME \\\n    --project=GSA_PROJECT\n</code></pre> Replace the following:</p> </li> <li>GSA_NAME: the name of the new IAM service account.</li> <li> <p>GSA_PROJECT: the project ID of the Google Cloud project for your IAM service account.</p> </li> <li> <p>Please ensure that this service account has all the roles requisite for interacting with the Compute Engine resources including VM Instances and Persistent Disks according to the GCP experiments that you're willing to run. You can grant additional roles using the following command: <pre><code>gcloud projects add-iam-policy-binding PROJECT_ID \\\n    --member \"serviceAccount:GSA_NAME@GSA_PROJECT.iam.gserviceaccount.com\" \\\n    --role \"ROLE_NAME\"\n</code></pre> Replace the following:</p> </li> <li>PROJECT_ID: your Google Cloud project ID.</li> <li>GSA_NAME: the name of your IAM service account.</li> <li>GSA_PROJECT: the project ID of the Google Cloud project of your IAM service account.</li> <li> <p>ROLE_NAME: the IAM role to assign to your service account, like roles/spanner.viewer.</p> </li> <li> <p>Allow the Kubernetes service account to be used for the GCP experiments to impersonate the GCP IAM service account by adding an IAM policy binding between the two service accounts. This binding allows the Kubernetes service account to act as the IAM service account. <pre><code>gcloud iam service-accounts add-iam-policy-binding GSA_NAME@GSA_PROJECT.iam.gserviceaccount.com \\\n    --role roles/iam.workloadIdentityUser \\\n    --member \"serviceAccount:PROJECT_ID.svc.id.goog[NAMESPACE/KSA_NAME]\"\n</code></pre> Replace the following:</p> </li> <li>GSA_NAME: the name of your IAM service account.</li> <li>GSA_PROJECT: the project ID of the Google Cloud project of your IAM service account.</li> <li>KSA_NAME: the name of the service account to be used for LitmusChaos GCP experiments.</li> <li> <p>NAMESPACE: the namespace in which the Kubernetes service account to be used for LitmusChaos GCP experiments is present.</p> </li> <li> <p>Annotate the Kubernetes service account to be used for LitmusChaos GCP experiments with the email address of the GCP IAM service account. <pre><code>kubectl annotate serviceaccount KSA_NAME \\\n    --namespace NAMESPACE \\\n    iam.gke.io/gcp-service-account=GSA_NAME@GSA_PROJECT.iam.gserviceaccount.com\n</code></pre> Replace the following:</p> </li> <li>KSA_NAME: the name of the service account to be used for LitmusChaos GCP experiments.</li> <li>NAMESPACE: the namespace in which the Kubernetes service account to be used for LitmusChaos GCP experiments is present.</li> <li>GSA_NAME: the name of your IAM service account.</li> <li>GSA_PROJECT: the project ID of the Google Cloud project of your IAM service account.</li> </ol>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#step-3-update-chaosengine-manifest","title":"STEP 3: Update ChaosEngine Manifest","text":"<p>Add the following value to the ChaosEngine manifest field <code>.spec.experiments[].spec.components.nodeSelector</code> to schedule the experiment pod on nodes that use Workload Identity. <pre><code>iam.gke.io/gke-metadata-server-enabled: \"true\"\n</code></pre></p>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#step-4-update-chaosexperiment-manifest","title":"STEP 4: Update ChaosExperiment Manifest","text":"<p>Remove <code>cloud-secret</code> at <code>.spec.definition.secrets</code> in the ChaosExperiment manifest as we are not using a secret to provide our GCP Service Account credentials.</p> <p>Now you can run your GCP experiments with a keyless authentication provided by GCP using Workload Identity.</p>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#how-to-disable-iam-service-accounts-from-accessing-gcp-resources","title":"How to disable IAM service accounts from accessing GCP resources?","text":"<p>To stop using Workload Identity, revoke access to the GCP IAM service account and disable Workload Identity on the cluster.</p>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#step-1-revoke-access-to-the-iam-service-account","title":"STEP 1: Revoke access to the IAM service account","text":"<ol> <li>To revoke access to the GCP IAM service account, use the following command: <pre><code>gcloud iam service-accounts remove-iam-policy-binding GSA_NAME@GSA_PROJECT.iam.gserviceaccount.com \\\n    --role roles/iam.workloadIdentityUser \\\n    --member \"serviceAccount:PROJECT_ID.svc.id.goog[NAMESPACE/KSA_NAME]\"\n</code></pre> Replace the following:</li> <li>PROJECT_ID: the project ID of the GKE cluster.</li> <li>NAMESPACE: the namespace in which the Kubernetes service account to be used for LitmusChaos GCP experiments is present.</li> <li>KSA_NAME: the name of the service account to be used for LitmusChaos GCP experiments.</li> <li>GSA_NAME: the name of the IAM service account.</li> <li>GSA_PROJECT: the project ID of the IAM service account.</li> </ol> <p>It can take up to 30 minutes for cached tokens to expire. </p> <ol> <li>Remove the annotation from the service account being used for LitmusChaos GCP experiments: <pre><code>kubectl annotate serviceaccount KSA_NAME \\\n    --namespace NAMESPACE iam.gke.io/gcp-service-account-\n</code></pre></li> </ol>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#step-2-disable-workload-identity","title":"STEP 2: Disable Workload Identity","text":"<ol> <li> <p>Disable Workload Identity on each node pool: <pre><code>gcloud container node-pools update NODEPOOL_NAME \\\n    --cluster=CLUSTER_NAME \\\n    --workload-metadata=GCE_METADATA\n</code></pre> Repeat this command for every node pool in the cluster.</p> </li> <li> <p>Disable Workload Identity in the cluster: <pre><code>gcloud container clusters update CLUSTER_NAME \\\n    --disable-workload-identity\n</code></pre></p> </li> </ol>"},{"location":"experiments/concepts/IAM/gcpIamIntegration/#troubleshooting-guide","title":"Troubleshooting Guide","text":"<p>Refer to the GCP documentation on troubleshooting Workload Identity here.</p>"},{"location":"experiments/concepts/chaos-resources/contents/","title":"Chaos Resources","text":"<p>At the heart of the Litmus Platform are the chaos custom resources. This section consists of the specification (details of each field within the .spec &amp; .status of the resources) as well as standard examples for tuning the supported parameters.</p> Chaos Resource Name Description User Guide ChaosEngine Contains the ChaosEngine specifications user-guide ChaosEngine ChaosExperiment Contains the ChaosExperiment specifications user-guide ChaosExperiment ChaosResult Contains the ChaosResult specifications user-guide ChaosResult ChaosScheduler Contains the ChaosScheduler specifications user-guide ChaosScheduler Probes Contains the Probes specifications user-guide Probes"},{"location":"experiments/concepts/chaos-resources/chaos-engine/application-details/","title":"Application Specifications","text":"<p>It contains AUT and auxiliary applications details provided at <code>spec.appinfo</code> and <code>spec.auxiliaryAppInfo</code> respectively inside chaosengine.</p> View the application specification schema <p> Field <code>.spec.appinfo.appns</code> Description Flag to specify namespace of application under test Type Optional Range user-defined (type: string) Default n/a Notes The <code>appns</code> in the spec specifies the namespace of the AUT. Usually provided as a quoted string. It is optional for the infra chaos. </p> <p> Field <code>.spec.appinfo.applabel</code> Description Flag to specify unique label of application under test Type Optional Range user-defined (type: string)(pattern: \"label_key=label_value\") Default n/a Notes The <code>applabel</code> in the spec specifies a unique label of the AUT. Usually provided as a quoted string of pattern key=value. Note that if multiple applications share the same label within a given namespace, the AUT is filtered based on the presence of the chaos annotation <code>litmuschaos.io/chaos: \"true\"</code>. If, however, the <code>annotationCheck</code> is disabled, then a random application (pod) sharing the specified label is selected for chaos. It is optional for the infra chaos. </p> <p> Field <code>.spec.appinfo.appkind</code> Description Flag to specify resource kind of application under test Type Optional Range <code>deployment</code>, <code>statefulset</code>, <code>daemonset</code>, <code>deploymentconfig</code>, <code>rollout</code> Default n/a (depends on app type) Notes The <code>appkind</code> in the spec specifies the Kubernetes resource type of the app deployment. The Litmus ChaosOperator supports chaos on deployments, statefulsets and daemonsets. Application health check routines are dependent on the resource types, in case of some experiments. It is optional for the infra chaos </p> <p> Field <code>.spec.auxiliaryAppInfo</code> Description Flag to specify one or more app namespace-label pairs whose health is also monitored as part of the chaos experiment, in addition to a primary application specified in the <code>.spec.appInfo</code>. NOTE: If the auxiliary applications are deployed in namespaces other than the AUT, ensure that the chaosServiceAccount is bound to a cluster role and has adequate permissions to list pods on other namespaces.  Type Optional Range user-defined (type: string)(pattern: \"namespace:label_key=label_value\"). Default n/a Notes The <code>auxiliaryAppInfo</code> in the spec specifies a (comma-separated) list of namespace-label pairs for downstream (dependent) apps of the primary app specified in <code>.spec.appInfo</code> in case of pod-level chaos experiments. In case of infra-level chaos experiments, this flag specifies those apps that may be directly impacted by chaos and upon which health checks are necessary. </p>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/application-details/#application-under-test","title":"Application Under Test","text":"<p>It defines the <code>appns</code>, <code>applabel</code>, and <code>appkind</code> to set the namespace, labels, and kind of the application under test.</p> <ul> <li><code>appkind</code>: It supports <code>deployment</code>, <code>statefulset</code>, <code>daemonset</code>, <code>deploymentconfig</code>, and <code>rollout</code>. It is mandatory for the pod-level experiments and optional for the rest of the experiments.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains details of the AUT(application under test)\n# appns: name of the application\n# applabel: label of the applicaton\n# appkind: kind of the application. supports: deployment, statefulset, daemonset, rollout, deploymentconfig\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  # AUT details\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/application-details/#auxiliary-application-info","title":"Auxiliary Application Info","text":"<p>The contains a (comma-separated) list of namespace-label pairs for downstream (dependent) apps of the primary app specified in <code>.spec.appInfo</code> in case of pod-level chaos experiments. In the case of infra-level chaos experiments, this flag specifies those apps that may be directly impacted by chaos and upon which health checks are necessary. It can be tuned via <code>auxiliaryAppInfo</code> field. It supports input the below format:</p> <ul> <li><code>auxiliaryAppInfo</code>: <code>&lt;namespace1&gt;:&lt;key1=value1&gt;,&lt;namespace2&gt;:&lt;key2=value2&gt;</code></li> </ul> <p>Note: Auxiliary application check is only supported for node-level experiments.</p> <p>Use the following example to tune this:</p> <pre><code># contains the comma seperated list of auxiliary applications details\n# it is provide in `&lt;namespace1&gt;:&lt;key1=value1&gt;,&lt;namespace2&gt;:&lt;key2=value2&gt;` format\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  # provide the comma separated auxiliary applications details\n  auxiliaryAppInfo: \"nginx:app=nginx,default:app=busybox\"\n  chaosServiceAccount: node-drain-sa\n  experiments:\n  - name: node-drain\n    spec:\n      components:\n        env:\n        # name of the target node\n        - name: TARGET_NODE\n          value: 'node01'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/contents/","title":"Chaos Engine Specifications","text":"<p>Bind an instance of a given app with one or more chaos experiments, define run characteristics, override chaos defaults, define steady-state hypothesis, reconciled by Litmus Chaos Operator.</p> <p>This section describes the fields in the ChaosEngine spec and the possible values that can be set against the same.</p> Field Name Description User Guide State Specification It defines the state of the chaosengine State Specifications Application Specification It defines the details of AUT and auxiliary applications Application Specifications RBAC Specification It defines the chaos-service-account name RBAC Specifications Runtime Specification It defines the runtime details of the chaosengine Runtime Specifications Runner Specification It defines the runner pod specifications Runner Specifications Experiment Specification It defines the experiment pod specifications Experiment Specifications"},{"location":"experiments/concepts/chaos-resources/chaos-engine/engine-state/","title":"State Specifications","text":"<p>It is a user-defined flag to trigger chaos. Setting it to <code>active</code> ensures the successful execution of chaos. Patching it with <code>stop</code> aborts ongoing experiments. It has a corresponding flag in the chaosengine status field, called <code>engineStatus</code> which is updated by the controller based on the actual state of the ChaosEngine. It can be tuned via <code>engineState</code> field. It supports <code>active</code> and <code>stop</code> values.</p> View the state specification schema <p> Field <code>.spec.engineState</code> Description Flag to control the state of the chaosengine Type Mandatory Range <code>active</code>, <code>stop</code> Default <code>active</code> Notes The <code>engineState</code> in the spec is a user defined flag to trigger chaos. Setting it to <code>active</code> ensures successful execution of chaos. Patching it with <code>stop</code> aborts ongoing experiments. It has a corresponding flag in the chaosengine status field, called <code>engineStatus</code> which is updated by the controller based on actual state of the ChaosEngine. </p> <p>Use the following example to tune this:</p> <pre><code># contains the chaosengine state\n# supports: active and stop states\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  # contains the state of engine\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/","title":"Experiment Specifications","text":"<p>It contains all the experiment tunables provided at <code>.spec.experiments[].spec.components</code> inside chaosengine. </p> View the experiment specification schema <p> Field <code>.spec.experiments[].spec.components.configMaps</code> Description Configmaps passed to the chaos experiment Type Optional Range user-defined (type: {name: string, mountPath: string}) Default n/a Notes The <code>experiment[].spec.components.configMaps</code> provides for a means to insert config information into the experiment. The configmaps definition is validated for correctness and those specified are checked for availability (in the cluster/namespace) before being mounted into the experiment pods. </p> <p> Field <code>.spec.experiments[].spec.components.secrets</code> Description Kubernetes secrets passed to the chaos experiment Type Optional Range user-defined (type: {name: string, mountPath: string}) Default n/a Notes The <code>experiment[].spec.components.secrets</code> provides for a means to push secrets (typically project ids, access credentials etc.,) into the experiment pods. These are especially useful in case of platform-level/infra-level chaos experiments. The secrets definition is validated for correctness and those specified are checked for availability (in the cluster/namespace) before being mounted into the experiment pods. </p> <p> Field <code>.spec.experiments[].spec.components.experimentImage</code> Description Override the image of the chaos experiment Type Optional Range  string  Default n/a Notes The <code>experiment[].spec.components.experimentImage</code> overrides the experiment image for the chaoexperiment. </p> <p> Field <code>.spec.experiments[].spec.components.experimentImagePullSecrets</code> Description Flag to specify imagePullSecrets for the ChaosExperiment Type Optional Range user-defined (type: []corev1.LocalObjectReference) Default n/a Notes The <code>.components.runner.experimentImagePullSecrets</code> allows developers to specify the <code>imagePullSecret</code> name for ChaosExperiment.  </p> <p> Field <code>.spec.experiments[].spec.components.nodeSelector</code> Description Provide the node selector for the experiment pod Type Optional Range  Labels in the from of label key=value Default n/a Notes The <code>experiment[].spec.components.nodeSelector</code> The nodeselector contains labels of the node on which experiment pod should be scheduled. Typically used in case of infra/node level chaos. </p> <p> Field <code>.spec.experiments[].spec.components.statusCheckTimeouts</code> Description Provides the timeout and retry values for the status checks. Defaults to 180s &amp; 90 retries (2s per retry) Type Optional Range  It contains values in the form {delay: int, timeout: int}  Default delay: 2s and timeout: 180s Notes The <code>experiment[].spec.components.statusCheckTimeouts</code> The statusCheckTimeouts override the status timeouts inside chaosexperiments. It contains timeout &amp; delay in seconds. </p> <p> Field <code>.spec.experiments[].spec.components.resources</code> Description Specify the resource requirements for the ChaosExperiment pod Type Optional Range user-defined (type: corev1.ResourceRequirements) Default n/a Notes The <code>experiment[].spec.components.resources</code> contains the resource requirements for the ChaosExperiment Pod, where we can provide resource requests and limits for the pod. </p> <p> Field <code>.spec.experiments[].spec.components.experimentAnnotations</code> Description Annotations that needs to be provided in the pod which will be created (experiment-pod) Type Optional Range user-defined (type: label key=value)  Default  n/a  Notes The <code>.spec.components.experimentAnnotation</code> allows developers to specify the custom annotations for the experiment pod. </p> <p> Field <code>.spec.experiments[].spec.components.tolerations</code> Description Toleration for the experiment pod Type Optional Range user-defined (type: []corev1.Toleration) Default n/a Notes The <code>.spec.components.tolerations</code>Tolerations for the experiment pod so that it can be scheduled on the respective tainted node. Typically used in case of infra/node level chaos. </p>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-annotations","title":"Experiment Annotations","text":"<p>It allows developers to specify the custom annotations for the experiment pod. It can be tuned via <code>experimentAnnotations</code> field. </p> <p>Use the following example to tune this:</p> <pre><code># contains annotations for the chaos runner pod\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # annotations for the experiment pod\n        experimentAnnotations:\n          name: chaos-experiment\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-configmaps-and-secrets","title":"Experiment Configmaps And Secrets","text":"<p>It defines the <code>configMaps</code> and <code>secrets</code> to set the configmaps and secrets mounted to the experiment pod respectively.</p> <ul> <li><code>configMaps</code>: It provides for a means to insert config information into the experiment. The configmaps definition is validated for the correctness and those specified are checked for availability (in the cluster/namespace) before being mounted into the experiment pods.</li> <li><code>secrets</code>: It provides for a means to push secrets (typically project ids, access credentials, etc.,) into the experiment pods. These are especially useful in the case of platform-level/infra-level chaos experiments. The secrets definition is validated for the correctness and those specified are checked for availability (in the cluster/namespace) before being mounted into the experiment pods.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains configmaps and secrets for the experiment pod\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # configmaps details mounted to the experiment pod\n        configMaps:\n        - name: \"configmap-01\"\n          mountPath: \"/mnt\"\n        # secrets details mounted to the experiment pod\n        secrets:\n        - name: \"secret-01\"\n          mountPath: \"/tmp\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-image","title":"Experiment Image","text":"<p>It overrides the experiment image for the chaosexperiment. It allows developers to specify the experiment image. It can be tuned via <code>experimentImage</code> field. </p> <p>Use the following example to tune this:</p> <pre><code># contains the custom image for the experiment pod\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # override the image of the experiment pod\n        experimentImage: \"litmuschaos/go-runner:ci\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-imagepullsecrets","title":"Experiment ImagePullSecrets","text":"<p>It allows developers to specify the imagePullSecret name for ChaosExperiment. It can be tuned via <code>experimentImagePullSecrets</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the imagePullSecrets for the experiment pod\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # secret name for the experiment image, if using private registry\n        experimentImagePullSecrets:\n        - name: regcred\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-nodeselectors","title":"Experiment NodeSelectors","text":"<p>The nodeselector contains labels of the node on which experiment pod should be scheduled. Typically used in case of infra/node level chaos. It can be tuned via <code>nodeSelector</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the node-selector for the experiment pod\n# it will schedule the experiment pod on the coresponding node with matching labels\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # nodeselector for the experiment pod\n        nodeSelector:\n          context: chaos\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-resource-requirements","title":"Experiment Resource Requirements","text":"<p>It contains the resource requirements for the ChaosExperiment Pod, where we can provide resource requests and limits for the pod. It can be tuned via <code>resources</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the resource requirements for the experiment pod\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # resource requirements for the experiment pod\n        resources:\n          requests:\n            cpu: \"250m\"\n            memory: \"64Mi\"\n          limits:\n          cpu: \"500m\"\n          memory: \"128Mi\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-tolerations","title":"Experiment Tolerations","text":"<p>It provides tolerations for the experiment pod so that it can be scheduled on the respective tainted node. Typically used in case of infra/node level chaos. It can be tuned via <code>tolerations</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the tolerations for the experiment pod\n# it will schedule the experiment pod on the tainted node\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # tolerations for the experiment pod\n        tolerations:\n        - key: \"key1\"\n          operator: \"Equal\"\n          value: \"value1\"\n          effect: \"Schedule\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/experiment-components/#experiment-status-check-timeout","title":"Experiment Status Check Timeout","text":"<p>It overrides the status timeouts inside chaosexperiments. It contains timeout &amp; delay in seconds. It can be tuned via <code>statusCheckTimeouts</code> field. </p> <p>Use the following example to tune this:</p> <pre><code># contains status check timeout for the experiment pod\n# it will set this timeout as upper bound while checking application status, node status in experiments\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      components:\n        # status check timeout for the experiment pod\n        statusCheckTimeouts:\n          delay: 2\n          timeout: 180\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/rbac-details/","title":"RBAC Specifications","text":"<p>It specifies the name of the serviceaccount mapped to a role/clusterRole with enough permissions to execute the desired chaos experiment. The minimum permissions needed for any given experiment are provided in the <code>.spec.definition.permissions</code> field of the respective chaosexperiment CR. It can be tuned via <code>chaosServiceAccount</code> field.</p> View the RBAC specification schema <p> Field <code>.spec.chaosServiceAccount</code> Description Flag to specify serviceaccount used for chaos experiment Type Mandatory Range user-defined (type: string) Default n/a Notes The <code>chaosServiceAccount</code> in the spec specifies the name of the serviceaccount mapped to a role/clusterRole with enough permissions to execute the desired chaos experiment. The minimum permissions needed for any given experiment is provided in the <code>.spec.definition.permissions</code> field of the respective chaosexperiment CR. </p> <p>Use the following example to tune this:</p> <pre><code># contains name of the serviceAccount which contains all the RBAC permissions required for the experiment\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  # name of the service account w/ sufficient permissions\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/","title":"Runner Specifications","text":"<p>It contains all the chaos-runner tunables provided at <code>.spec.components.runner</code> inside chaosengine.</p> View the runner specification schema <p> Field <code>.spec.components.runner.image</code> Description Flag to specify image of ChaosRunner pod Type Optional Range user-defined (type: string) Default n/a (refer Notes) Notes The <code>.components.runner.image</code> allows developers to specify their own debug runner images. Defaults for the runner image can be enforced via the operator env CHAOS_RUNNER_IMAGE </p> <p> Field <code>.spec.components.runner.imagePullPolicy</code> Description Flag to specify imagePullPolicy for the ChaosRunner Type Optional Range <code>Always</code>, <code>IfNotPresent</code> Default <code>IfNotPresent</code> Notes The <code>.components.runner.imagePullPolicy</code> allows developers to specify the pull policy for chaos-runner. Set to <code>Always</code> during debug/test. </p> <p> Field <code>.spec.components.runner.imagePullSecrets</code> Description Flag to specify imagePullSecrets for the ChaosRunner Type Optional Range user-defined (type: []corev1.LocalObjectReference) Default n/a Notes The <code>.components.runner.imagePullSecrets</code> allows developers to specify the <code>imagePullSecret</code> name for ChaosRunner.  </p> <p> Field <code>.spec.components.runner.runnerAnnotations</code> Description Annotations that needs to be provided in the pod which will be created (runner-pod) Type Optional Range user-defined (type: map[string]string)  Default  n/a  Notes The <code>.components.runner.runnerAnnotation</code> allows developers to specify the custom annotations for the runner pod. </p> <p> Field <code>.spec.components.runner.args</code> Description Specify the args for the ChaosRunner Pod Type Optional Range user-defined (type: []string) Default n/a Notes The <code>.components.runner.args</code> allows developers to specify their own debug runner args. </p> <p> Field <code>.spec.components.runner.command</code> Description Specify the commands for the ChaosRunner Pod Type Optional Range user-defined (type: []string) Default n/a Notes The <code>.components.runner.command</code> allows developers to specify their own debug runner commands. </p> <p> Field <code>.spec.components.runner.configMaps</code> Description Configmaps passed to the chaos runner pod Type Optional Range user-defined (type: {name: string, mountPath: string}) Default n/a Notes The <code>.spec.components.runner.configMaps</code> provides for a means to insert config information into the runner pod. </p> <p> Field <code>.spec.components.runner.secrets</code> Description Kubernetes secrets passed to the chaos runner pod. Type Optional Range user-defined (type: {name: string, mountPath: string}) Default n/a Notes The <code>.spec.components.runner.secrets</code> provides for a means to push secrets (typically project ids, access credentials etc.,) into the chaos runner pod. These are especially useful in case of platform-level/infra-level chaos experiments.  </p> <p> Field <code>.spec.components.runner.nodeSelector</code> Description Node selectors for the runner pod Type Optional Range Labels in the from of label key=value Default n/a Notes The <code>.spec.components.runner.nodeSelector</code> The nodeselector contains labels of the node on which runner pod should be scheduled. Typically used in case of infra/node level chaos. </p> <p> Field <code>.spec.components.runner.resources</code> Description Specify the resource requirements for the ChaosRunner pod Type Optional Range user-defined (type: corev1.ResourceRequirements) Default n/a Notes The <code>.spec.components.runner.resources</code> contains the resource requirements for the ChaosRunner Pod, where we can provide resource requests and limits for the pod. </p> <p> Field <code>.spec.components.runner.tolerations</code> Description Toleration for the runner pod Type Optional Range user-defined (type: []corev1.Toleration) Default n/a Notes The <code>.spec.components.runner.tolerations</code> Provides tolerations for the runner pod so that it can be scheduled on the respective tainted node. Typically used in case of infra/node level chaos. </p>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-annotations","title":"ChaosRunner Annotations","text":"<p>It allows developers to specify the custom annotations for the runner pod. It can be tuned via <code>runnerAnnotations</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains annotations for the chaos runner pod\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    runner:\n     # annotations for the chaos-runner\n     runnerAnnotations:\n       name: chaos-runner\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-args-and-command","title":"ChaosRunner Args And Command","text":"<p>It defines the <code>args</code> and <code>command</code> to set the args and command of the chaos-runner respectively.</p> <ul> <li><code>args</code>: It allows developers to specify their own debug runner args.</li> <li><code>command</code>: It allows developers to specify their own debug runner commands.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains args and command for the chaos runner\n# it will be useful for the cases where custom image of the chaos-runner is used, which supports args and commands\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    # override the args and command for the chaos-runner\n    runner:\n      # name of the custom image\n      image: \"&lt;your repo&gt;/chaos-runner:ci\"\n      # args for the image\n      args:\n      - \"/bin/sh\"\n      # command for the image\n      command:\n      - \"-c\"\n      - \"&lt;custom-command&gt;\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-configmaps-and-secrets","title":"ChaosRunner Configmaps And Secrets","text":"<p>It defines the <code>configMaps</code> and <code>secrets</code> to set the configmaps and secrets mounted to the chaos-runner respectively.</p> <ul> <li><code>configMaps</code>: It provides for a means to insert config information into the runner pod.</li> <li><code>secrets</code>: It provides for a means to push secrets (typically project ids, access credentials, etc.,) into the chaos runner pod. These are especially useful in the case of platform-level/infra-level chaos experiments.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains configmaps and secrets for the chaos-runner\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    runner:\n     # configmaps details mounted to the runner pod\n     configMaps:\n     - name: \"configmap-01\"\n       mountPath: \"/mnt\"\n     # secrets details mounted to the runner pod\n     secrets:\n     - name: \"secret-01\"\n       mountPath: \"/tmp\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-image-and-imagepullpoicy","title":"ChaosRunner Image and ImagePullPoicy","text":"<p>It defines the <code>image</code> and <code>imagePullPolicy</code> to set the image and imagePullPolicy for the chaos-runner respectively.</p> <ul> <li><code>image</code>: It allows developers to specify their own debug runner images. Defaults for the runner image can be enforced via the operator env <code>CHAOS_RUNNER_IMAGE</code>.</li> <li><code>imagePullPolicy</code>: It allows developers to specify the pull policy for chaos-runner. Set to Always during debug/test.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains the image and imagePullPolicy of the chaos-runner\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    runner:\n      # override the image of the chaos-runner\n      # by default it is used the image based on the litmus version\n      image: \"litmuschaos/chaos-runner:latest\"\n      # imagePullPolicy for the runner image\n      # supports: Always, IfNotPresent. default: IfNotPresent\n      imagePullPolicy: \"Always\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-imagepullsecrets","title":"ChaosRunner ImagePullSecrets","text":"<p>It allows developers to specify the imagePullSecret name for the ChaosRunner. It can be tuned via <code>imagePullSecrets</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the imagePullSecrets for the chaos-runner\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    runner:\n      # secret name for the runner image, if using private registry\n      imagePullSecrets:\n      - name: regcred\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-nodeselectors","title":"ChaosRunner NodeSelectors","text":"<p>The nodeselector contains labels of the node on which runner pod should be scheduled. Typically used in case of infra/node level chaos. It can be tuned via <code>nodeSelector</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the node-selector for the chaos-runner\n# it will schedule the chaos-runner on the coresponding node with matching labels\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    runner:\n      # nodeselector for the runner pod\n      nodeSelector:\n        context: chaos\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-resource-requirements","title":"ChaosRunner Resource Requirements","text":"<p>It contains the resource requirements for the ChaosRunner Pod, where we can provide resource requests and limits for the pod. It can be tuned via <code>resources</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the resource requirements for the runner pod\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    runner:\n      # resource requirements for the runner pod\n      resources:\n        requests:\n          cpu: \"250m\"\n          memory: \"64Mi\"\n        limits:\n         cpu: \"500m\"\n         memory: \"128Mi\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runner-components/#chaosrunner-tolerations","title":"ChaosRunner Tolerations","text":"<p>It provides tolerations for the runner pod so that it can be scheduled on the respective tainted node. Typically used in case of infra/node level chaos. It can be tuned via <code>tolerations</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the tolerations for the chaos-runner\n# it will schedule the chaos-runner on the tainted node\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  components:\n    runner:\n      # tolerations for the runner pod\n      tolerations:\n      - key: \"key1\"\n        operator: \"Equal\"\n        value: \"value1\"\n        effect: \"Schedule\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runtime-details/","title":"Runtime Specifications","text":"<p>It contains runtime details of the chaos experiments provided at <code>.spec</code> inside chaosengine.</p> View the runtime specification schema <p> Field <code>.spec.annotationCheck</code> Description Flag to control annotationChecks on applications as prerequisites for chaos Type Optional Range <code>true</code>, <code>false</code> Default <code>true</code> Notes The <code>annotationCheck</code> in the spec controls whether or not the operator checks for the annotation \"litmuschaos.io/chaos\" to be set against the application under test (AUT). Setting it to <code>true</code> ensures the check is performed, with chaos being skipped if the app is not annotated, while setting it to <code>false</code> suppresses this check and proceeds with chaos injection. </p> <p> Field <code>.spec.terminationGracePeriodSeconds</code> Description Flag to control terminationGracePeriodSeconds for the chaos pods(abort case) Type Optional Range integer value Default <code>30</code> Notes The <code>terminationGracePeriodSeconds</code> in the spec controls the terminationGracePeriodSeconds for the chaos resources in abort case. Chaos pods contains chaos revert upon abortion steps, which continuously looking for the termination signals. The terminationGracePeriodSeconds should be provided in such a way that the chaos pods got enough time for the revert before completely terminated. </p> <p> Field <code>.spec.jobCleanUpPolicy</code> Description Flag to control cleanup of chaos experiment job post execution of chaos Type Optional Range <code>delete</code>, <code>retain</code> Default <code>delete</code> Notes &lt;The <code>jobCleanUpPolicy</code> controls whether or not the experiment pods are removed once execution completes. Set to <code>retain</code> for debug purposes (in the absence of standard logging mechanisms). </p>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runtime-details/#annotation-check","title":"Annotation Check","text":"<p>It controls whether or not the operator checks for the annotation <code>litmuschaos.io/chaos</code> to be set against the application under test (AUT). Setting it to <code>true</code> ensures the check is performed, with chaos being skipped if the app is not annotated while setting it to <code>false</code> suppresses this check and proceeds with chaos injection. It can be tuned via <code>annotationCheck</code> field. It supports the boolean value and the default value is <code>false</code>.</p> <p>Use the following example to tune this:</p> <pre><code># checks the AUT for the annoations. The AUT should be annotated with `litmuschaos.io/chaos: true` if provided as true\n# supports: true, false. default: false\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  # annotaionCheck details\n  annotationCheck: \"true\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runtime-details/#jobcleanup-policy","title":"Jobcleanup Policy","text":"<p>It controls whether or not the experiment pods are removed once execution completes. Set to <code>retain</code> for debug purposes (in the absence of standard logging mechanisms). It can be tuned via <code>jobCleanUpPolicy</code> fields. It supports <code>retain</code> and <code>delete</code>. The default value is <code>retain</code>.</p> <p>Use the following example to tune this:</p> <pre><code># flag to delete or retain the chaos resources after completions of chaosengine\n# supports: delete, retain. default: retain\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  jobCleanUpPolicy: \"delete\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-engine/runtime-details/#termination-grace-period-seconds","title":"Termination Grace Period Seconds","text":"<p>It controls the <code>terminationGracePeriodSeconds</code> for the chaos resources in the abort case. Chaos pods contain chaos revert upon abortion steps, which continuously looking for the termination signals. The <code>terminationGracePeriodSeconds</code> should be provided in such a way that the chaos pods got enough time for the revert before being completely terminated. It can be tuned via <code>terminationGracePeriodSeconds</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains flag to control the terminationGracePeriodSeconds for the chaos pod(abort case)\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  # contains terminationGracePeriodSeconds for the chaos pods\n  terminationGracePeriodSeconds: 100\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/component-specification/","title":"Component Specification","text":"<p>It contains component details provided at <code>spec.definition</code> inside chaosexperiment</p> View the component specification schema <p> Field <code>.spec.definition.image</code> Description Flag to specify the image to run the ChaosExperiment  Type Mandatory Range user-defined (type: string) Default n/a (refer Notes) Notes The <code>.spec.definition.image</code> allows the developers to specify their experiment images. Typically set to the Litmus <code>go-runner</code> or the <code>ansible-runner</code>. This feature of the experiment enables BYOC (BringYourOwnChaos), where developers can implement their own variants of a standard chaos experiment </p> <p> Field <code>.spec.definition.imagePullPolicy</code> Description Flag that helps the developers to specify imagePullPolicy for the ChaosExperiment Type Mandatory Range <code>IfNotPresent</code>, <code>Always</code> (type: string) Default <code>Always</code> Notes The <code>.spec.definition.imagePullPolicy</code> allows developers to specify the pull policy for ChaosExperiment image. Set to <code>Always</code> during debug/test </p> <p> Field <code>.spec.definition.args</code> Description Flag to specify the entrypoint for the ChaosExperiment Type Mandatory Range user-defined (type:list of string) Default n/a Notes The <code>.spec.definition.args</code> specifies the entrypoint for the ChaosExperiment. It depends on the language used in the experiment. For litmus-go the <code>.spec.definition.args</code> contains a single binary of all experiments and managed via <code>-name</code> flag to indicate experiment to run(<code>-name (exp-name)</code>). </p> <p> Field <code>.spec.definition.command</code> Description Flag to specify the shell on which the ChaosExperiment will execute Type Mandatory Range user-defined (type: list of string). Default <code>/bin/bash</code> Notes The <code>.spec.definition.command</code> specifies the shell used to run the experiment <code>/bin/bash</code> is the most common shell to be used. </p>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/component-specification/#image","title":"Image","text":"<p>It allows the developers to specify their experiment images. Typically set to the Litmus go-runner or the ansible-runner. This feature of the experiment enables BYOC (BringYourOwnChaos), where developers can implement their own variants of a standard chaos experiment. It can be tuned via <code>image</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    # image of the chaosexperiment\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/component-specification/#imagepullpolicy","title":"ImagePullPolicy","text":"<p>It allows developers to specify the pull policy for ChaosExperiment image. Set to Always during debug/test. It can be tuned via <code>imagePullPolicy</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    # imagePullPolicy of the chaosexperiment\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/component-specification/#args","title":"Args","text":"<p>It specifies the entrypoint for the ChaosExperiment. It depends on the language used in the experiment. For litmus-go the .spec.definition.args contains a single binary of all experiments and managed via -name flag to indicate experiment to run(-name (exp-name)). It can be tuned via <code>args</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    # it contains args of the experiment\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/component-specification/#command","title":"Command","text":"<p>It specifies the shell used to run the experiment /bin/bash is the most common shell to be used. It can be tuned via <code>command</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    # it contains command of the experiment\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/","title":"Configuration Specification","text":"<p>It contains configuration details provided at <code>spec.definition</code> inside chaosexperiment</p> View the configuration specification schema <p> Field <code>.spec.definition.labels</code> Description Flag to specify the label for the ChaosPod Type Optional Range user-defined (type:map[string]string) Default n/a Notes  The <code>.spec.definition.labels</code> allow developers to specify the ChaosPod label for an experiment.  <p> Field <code>.spec.definition.securityContext.podSecurityContext</code> Description Flag to specify security context for ChaosPod Type Optional Range user-defined (type:corev1.PodSecurityContext) Default n/a Notes  The <code>.spec.definition.securityContext.podSecurityContext</code> allows the developers to specify the security context for the ChaosPod which applies to all containers inside the Pod. <p> Field <code>.spec.definition.securityContext.containerSecurityContext.privileged</code> Description Flag to specify the security context for the ChaosExperiment pod Type Optional Range true, false (type:bool) Default n/a Notes The <code>.spec.definition.securityContext.containerSecurityContext.privileged</code> specify the securityContext params to the experiment container. </p> <p> Field <code>.spec.definition.configMaps</code> Description Flag to specify the configmap for ChaosPod Type Optional Range user-defined Default n/a Notes  The <code>.spec.definition.configMaps</code> allows the developers to mount the ConfigMap volume into the experiment pod. <p> Field <code>.spec.definition.secrets</code> Description Flag to specify the secrets for ChaosPod Type Optional Range user-defined Default n/a Notes  The <code>.spec.definition.secrets</code> specify the secret data to be passed for the ChaosPod. The secrets typically contains confidential information like credentials. <p> Field <code>.spec.definition.experimentAnnotations</code> Description Flag to specify the custom annotation to the ChaosPod Type Optional Range user-defined (type:map[string]string) Default n/a Notes  The <code>.spec.definition.experimentAnnotations</code> allows the developer to specify the Custom annotation for the chaos pod. <p> Field <code>.spec.definition.hostFileVolumes</code> Description Flag to specify the host file volumes to the ChaosPod Type Optional Range user-defined (type:map[string]string) Default n/a Notes  The <code>.spec.definition.hostFileVolumes</code> allows the developer to specify the host file volumes to the ChaosPod. <p> Field <code>.spec.definition.hostPID</code> Description Flag to specify the host PID for the ChaosPod Type Optional Range true, false (type:bool) Default n/a Notes  The <code>.spec.definition.hostPID</code> allows the developer to specify the host PID  for the ChaosPod.  </p>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#labels","title":"Labels","text":"<p>It allows developers to specify the ChaosPod label for an experiment. It can be tuned via <code>labels</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it contains experiment labels\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#podsecuritycontext","title":"PodSecurityContext","text":"<p>It allows the developers to specify the security context for the ChaosPod which applies to all containers inside the Pod. It can be tuned via <code>podSecurityContext</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it contains pod security context\n    securityContext:\n      podSecurityContext:\n        allowPrivilegeEscalation: true\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#container-security-context","title":"Container Security Context","text":"<p>It allows the developers to specify the security context for the container inside ChaosPod. It can be tuned via <code>containerSecurityContext</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it contains container security context\n    securityContext:\n      containerSecurityContext:\n        privileged: true\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#configmaps","title":"ConfigMaps","text":"<p>It allows the developers to mount the ConfigMap volume into the experiment pod. It can tuned via <code>configMaps</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it contains configmaps details\n    configMaps:\n      - name: experiment-data\n        mountPath: \"/mnt\"\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#secrets","title":"Secrets","text":"<p>It specify the secret data to be passed for the ChaosPod. The secrets typically contains confidential information like credentials. It can be tuned via <code>secret</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it contains secret details\n    secret:\n      - name: auth-credentials\n        mountPath: \"/tmp\"\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#experiment-annotations","title":"Experiment Annotations","text":"<p>It allows the developer to specify the Custom annotation for the chaos pod. It can be tuned via <code>experimentAnnotations</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it contains experiment annotations\n    experimentAnnotations:\n      context: chaos\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#host-file-volumes","title":"Host File Volumes","text":"<p>It allows the developer to specify the host file volumes to the ChaosPod. It can be tuned via <code>hostFileVolumes</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it contains host file volumes\n    hostFileVolumes:\n      - name: socket file\n        mountPath: \"/run/containerd/containerd.sock\"\n        nodePath: \"/run/containerd/containerd.sock\"\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/configuration-specification/#host-pid","title":"Host PID","text":"<p>It allows the developer to specify the host PID for the ChaosPod. It can be tuned via <code>hostPID</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n    # it allows hostPID\n    hostPID: true\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/contents/","title":"Chaos Experiment Specifications","text":"<p>Granular definition of chaos intent specified via image, librar, necessary permissions, low-level chaos parameters (default values).</p> <p>This section describes the fields in the ChaosExperiment and the possible values that can be set against the same.</p>  Field Name   Description   User Guide   Scope Specification   It defines scope of the chaosexperiment  Scope Specifications  Component Specification   It defines component details of the chaosexperiment  Component Specifications  Experiment Tunables Specification   It defines tunables of the chaosexperiment  Experiment Tunables Specification  Configuration Specification   It defines configuration details of the chaosexperiment  Configuration Specification"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/experiment-tunable-specification/","title":"Experiment Tunables Specification","text":"<p>It contains the array of tunables passed to the experiment pods as environment variables. It is used to manage the experiment execution. We can set the default values for all the variables (tunable) here which can be overridden by ChaosEngine from <code>.spec.experiments[].spec.components.env</code> if required. To know about the variables that need to be overridden check the list of \"mandatory\" &amp; \"optional\" env for an experiment as provided within the respective experiment documentation. It can be provided at <code>spec.definition.env</code> inside chaosexperiment.</p> View the experiment tunables specification <p> Field <code>.spec.definition.env</code> Description Flag to specify env used for ChaosExperiment Type Mandatory Range user-defined (type: {name: string, value: string}) Default n/a Notes  The <code>.spec.definition.env</code> specifies the array of tunables passed to the experiment pods as environment variables. It is used to manage the experiment execution. We can set the default values for all the variables (tunable) here which can be overridden by ChaosEngine from <code>.spec.experiments[].spec.components.env</code> if required. To know about the variables that need to be overridden check the list of \"mandatory\" &amp; \"optional\" env for an experiment as provided within the respective experiment documentation. </p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    # permissions for the chaosexperiment\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    # it contains experiment tunables\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/scope-specification/","title":"Scope Specification","text":"<p>It contains scope and permissions details provided at <code>spec.definition.scope</code> and <code>spec.definition.permissions</code> respectively inside chaosexperiment.</p> View the scope specification schema <p> Field <code>.spec.definition.scope</code> Description Flag to specify the scope of the ChaosExperiment Type Optional Range <code>Namespaced</code>, <code>Cluster</code> Default n/a (depends on experiment type) Notes The <code>.spec.definition.scope</code> specifies the scope of the experiment. It can be <code>Namespaced</code> scope for pod level experiments and <code>Cluster</code> for the experiments having a cluster wide impact. </p> <p> Field <code>.spec.definition.permissions</code> Description Flag to specify the minimum permission to run the ChaosExperiment Type Optional Range user-defined (type: list) Default n/a Notes The <code>.spec.definition.permissions</code> specify the minimum permission that is required to run the ChaosExperiment. It also helps to estimate the blast radius for the ChaosExperiment. </p>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/scope-specification/#experiment-scope","title":"Experiment Scope","text":"<p>It specifies the scope of the experiment. It can be <code>Namespaced</code> scope for pod level experiments and <code>Cluster</code> for the experiments having a cluster wide impact. It can be tuned via <code>scope</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    # scope of the chaosexperiment\n    scope: Namespaced\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    - name: SEQUENCE\n      value: 'parallel'\n\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-experiment/scope-specification/#experiment-permissions","title":"Experiment Permissions","text":"<p>It specify the minimum permission that is required to run the ChaosExperiment. It also helps to estimate the blast radius for the ChaosExperiment. It can be tuned via <code>permissions</code> field.</p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\ndescription:\n  message: |\n    Deletes a pod belonging to a deployment/statefulset/daemonset\nkind: ChaosExperiment\nmetadata:\n  name: pod-delete\n  labels:\n    name: pod-delete\n    app.kubernetes.io/part-of: litmus\n    app.kubernetes.io/component: chaosexperiment\n    app.kubernetes.io/version: latest\nspec:\n  definition:\n    scope: Namespaced\n    # permissions for the chaosexperiment\n    permissions:\n      - apiGroups:\n          - \"\"\n          - \"apps\"\n          - \"apps.openshift.io\"\n          - \"argoproj.io\"\n          - \"batch\"\n          - \"litmuschaos.io\"\n        resources:\n          - \"deployments\"\n          - \"jobs\"\n          - \"pods\"\n          - \"pods/log\"\n          - \"replicationcontrollers\"\n          - \"deployments\"\n          - \"statefulsets\"\n          - \"daemonsets\"\n          - \"replicasets\"\n          - \"deploymentconfigs\"\n          - \"rollouts\"\n          - \"pods/exec\"\n          - \"events\"\n          - \"chaosengines\"\n          - \"chaosexperiments\"\n          - \"chaosresults\"\n        verbs:\n          - \"create\"\n          - \"list\"\n          - \"get\"\n          - \"patch\"\n          - \"update\"\n          - \"delete\"\n          - \"deletecollection\"\n    image: \"litmuschaos/go-runner:latest\"\n    imagePullPolicy: Always\n    args:\n    - -c\n    - ./experiments -name pod-delete\n    command:\n    - /bin/bash\n    env:\n\n    - name: TOTAL_CHAOS_DURATION\n      value: '15'\n\n    - name: RAMP_TIME\n      value: ''\n\n    - name: FORCE\n      value: 'true'\n\n    - name: CHAOS_INTERVAL\n      value: '5'\n\n    - name: PODS_AFFECTED_PERC\n      value: ''\n\n    - name: LIB\n      value: 'litmus'    \n\n    - name: TARGET_PODS\n      value: ''\n\n    ## it defines the sequence of chaos execution for multiple target pods\n    ## supported values: serial, parallel\n    - name: SEQUENCE\n      value: 'parallel'\n\n    labels:\n      name: pod-delete\n      app.kubernetes.io/part-of: litmus\n      app.kubernetes.io/component: experiment-job\n      app.kubernetes.io/version: latest\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-result/contents/","title":"Chaos Result Specifications","text":"<p>Hold engine reference, experiment state, verdict(on complete), salient application/result attributes, sources for metrics collection</p> <p>This section describes the fields in the ChaosResult and the possible values that can be set against the same.</p>  Field Name   Description   User Guide   Spec Specification   It defines spec details of the chaosresult  Spec Specification  Status Specification   It defines status details of the chaosresult  Status Specification  Probe Specification   It defines component details of the chaosresult  Probe Specification"},{"location":"experiments/concepts/chaos-resources/chaos-result/probe-specification/","title":"Probe Status","text":"<p>It contains probe details provided at <code>status.probeStatus</code> inside chaosresult. It contains following fields:</p> <ul> <li><code>name</code>: Flag to show the name of probe used in the experiment</li> <li><code>type</code>: Flag to show the type of probe used</li> <li><code>status.continuous</code>: Flag to show the result of probe in continuous mode</li> <li><code>status.prechaos</code>: Flag to show the result of probe in pre chaos</li> <li><code>status.postchaos</code>: Flag to show the result of probe in post chaos</li> </ul> View the probe schema <p> Field <code>.status.probestatus.name</code> Description Flag to show the name of probe used in the experiment Range n/a n/a (type: string) Notes The <code>.status.probestatus.name</code> shows the name of the probe used in the experiment. </p> <p> Field <code>.status.probestatus.type</code> Description Flag to show the type of probe used Range HTTPProbe,K8sProbe,CmdProbe(type:string) Notes The <code>.status.probestatus.type</code> shows the type of probe used. </p> <p> Field <code>.status.probestatus.status.continuous</code> Description Flag to show the result of probe in continuous mode Range Awaited,Passed,Better Luck Next Time (type: string) Notes The <code>.status.probestatus.status.continuous</code> helps to get the result of the probe in the continuous mode. The httpProbe is better used in the Continuous mode. </p> <p> Field <code>.status.probestatus.status.postchaos</code> Description Flag to show the probe result post chaos Range Awaited,Passed,Better Luck Next Time (type:map[string]string) Notes The <code>.status.probestatus.status.postchaos</code> shows the result of probe setup in EOT mode executed at the End of Test as a post-chaos check.  </p> <p> Field <code>.status.probestatus.status.prechaos</code> Description Flag to show the probe result pre chaos Range Awaited,Passed,Better Luck Next Time (type:string) Notes The <code>.status.probestatus.status.prechaos</code> shows the result of probe setup in SOT mode executed at the Start of Test as a pre-chaos check. </p> <p>view the sample example:</p> <pre><code>Name:         engine-nginx-pod-delete\nNamespace:    default\nLabels:       app.kubernetes.io/component=experiment-job\n              app.kubernetes.io/part-of=litmus\n              app.kubernetes.io/version=1.13.8\n              chaosUID=aa0a0084-f20f-4294-a879-d6df9aba6f9b\n              controller-uid=6943c955-0154-4542-8745-de991eb47c61\n              job-name=pod-delete-w4p5op\n              name=engine-nginx-pod-delete\nAnnotations:  &lt;none&gt;\nAPI Version:  litmuschaos.io/v1alpha1\nKind:         ChaosResult\nMetadata:\n  Creation Timestamp:  2021-09-29T13:28:59Z\n  Generation:          6\n  Resource Version:    66788\n  Self Link:           /apis/litmuschaos.io/v1alpha1/namespaces/default/chaosresults/engine-nginx-pod-delete\n  UID:                 fe7f01c8-8118-4761-8ff9-0a87824d863f\nSpec:\n  Engine:      engine-nginx\n  Experiment:  pod-delete\nStatus:\n  Experiment Status:\n    Fail Step:                 N/A\n    Phase:                     Completed\n    Probe Success Percentage:  100\n    Verdict:                   Pass\n  History:\n    Failed Runs:   1\n    Passed Runs:   1\n    Stopped Runs:  0\n    Targets:\n      Chaos Status:  targeted\n      Kind:          deployment\n      Name:          hello\n  Probe Status:\n    # name of probe\n    Name:  check-frontend-access-url\n    # status of probe\n    Status:\n      Continuous:  Passed \ud83d\udc4d #Continuous\n    # type of probe\n    Type:          HTTPProbe\n    # name of probe\n    Name:          check-app-cluster-cr-status\n    # status of probe\n    Status:\n      Post Chaos:  Passed \ud83d\udc4d #EoT\n    # type of probe\n    Type:          K8sProbe\n    # name of probe\n    Name:          check-database-integrity\n    # status of probe\n    Status:\n      Post Chaos:  Passed \ud83d\udc4d #Edge\n      Pre Chaos:   Passed \ud83d\udc4d \n    # type of probe\n    Type:          CmdProbe\nEvents:              &lt;none&gt;\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-result/spec-specification/","title":"Spec Specification","text":"<p>It contains spec details provided at <code>spec</code> inside chaosresult. The name of chaosengine and chaosexperiment are present at <code>spec.engine</code> and <code>spec.experiment</code> respectively.</p> View the spec details schema <p> Field <code>.spec.engine</code> Description Flag to hold the ChaosEngine name for the experiment Range n/a  (type: string) Notes The <code>.spec.engine<code> holds the engine name for the current course of the experiment. <p> Field <code>.spec.experiment</code> Description Flag to hold the ChaosExperiment name which induces chaos. Range n/a (type: string) Notes The <code>.spec.experiment</code> holds the ChaosExperiment name for the current course of the experiment. </p> <p>view the sample chaosresult:</p> <pre><code>Name:         engine-nginx-pod-delete\nNamespace:    default\nLabels:       app.kubernetes.io/component=experiment-job\n              app.kubernetes.io/part-of=litmus\n              app.kubernetes.io/version=1.13.8\n              chaosUID=aa0a0084-f20f-4294-a879-d6df9aba6f9b\n              controller-uid=6943c955-0154-4542-8745-de991eb47c61\n              job-name=pod-delete-w4p5op\n              name=engine-nginx-pod-delete\nAnnotations:  &lt;none&gt;\nAPI Version:  litmuschaos.io/v1alpha1\nKind:         ChaosResult\nMetadata:\n  Creation Timestamp:  2021-09-29T13:28:59Z\n  Generation:          6\n  Resource Version:    66788\n  Self Link:           /apis/litmuschaos.io/v1alpha1/namespaces/default/chaosresults/engine-nginx-pod-delete\n  UID:                 fe7f01c8-8118-4761-8ff9-0a87824d863f\nSpec:\n  # name of the chaosengine\n  Engine:      engine-nginx\n  # name of the chaosexperiment\n  Experiment:  pod-delete\nStatus:\n  Experiment Status:\n    Fail Step:                 N/A\n    Phase:                     Completed\n    Probe Success Percentage:  100\n    Verdict:                   Pass\n  History:\n    Failed Runs:   1\n    Passed Runs:   1\n    Stopped Runs:  0\n    Targets:\n      Chaos Status:  targeted\n      Kind:          deployment\n      Name:          hello\nEvents:              &lt;none&gt;\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-result/status-specification/","title":"Status Specification","text":"<p>It contains status details provided at <code>status</code> inside chaosresult.</p>"},{"location":"experiments/concepts/chaos-resources/chaos-result/status-specification/#experiment-status","title":"Experiment Status","text":"<p>It contains experiment status provided at <code>status.experimentStatus</code> inside chaosresult. It contains following fields:</p> <ul> <li><code>failStep</code>: Flag to show the failure step of the ChaosExperiment</li> <li><code>phase</code>: Flag to show the current phase of the experiment</li> <li><code>probesuccesspercentage</code>: Flag to show the probe success percentage</li> <li><code>verdict</code>: Flag to show the verdict of the experiment</li> </ul> View the experiment status <p> Field <code>.status.experimentStatus.failstep</code> Description Flag to show the failure step of the ChaosExperiment Range n/a(type: string) Notes The <code>.status.experimentStatus.failstep</code> Show the step at which the experiment failed. It helps in faster debugging of failures in the experiment execution. <p> Field <code>.status.experimentStatus.phase</code> Description Flag to show the current phase of the experiment Range Awaited,Running,Completed,Aborted (type: string) Notes The <code>.status.experimentStatus.phase</code> shows the current phase in which the experiment is. It gets updated as the experiment proceeds.If the experiment is aborted then the status will be Aborted. </p> <p> Field <code>.status.experimentStatus.probesuccesspercentage</code> Description Flag to show the probe success percentage Range 1 to 100 (type: int) Notes The <code>.status.experimentStatus.probesuccesspercentage</code> shows the probe success percentage which is a ratio of successful checks v/s total probes. </p> <p> Field <code>.status.experimentStatus.verdict</code> Description Flag to show the verdict of the experiment. Range Awaited,Pass,Fail,Stopped (type: string) Notes The <code>.status.experimentStatus.verdict</code> shows the verdict of the experiment. It is <code>Awaited</code> when the experiment is in progress and ends up with Pass or Fail according to the experiment result. </p> <p>view the sample example:</p> <pre><code>Name:         engine-nginx-pod-delete\nNamespace:    default\nLabels:       app.kubernetes.io/component=experiment-job\n              app.kubernetes.io/part-of=litmus\n              app.kubernetes.io/version=1.13.8\n              chaosUID=aa0a0084-f20f-4294-a879-d6df9aba6f9b\n              controller-uid=6943c955-0154-4542-8745-de991eb47c61\n              job-name=pod-delete-w4p5op\n              name=engine-nginx-pod-delete\nAnnotations:  &lt;none&gt;\nAPI Version:  litmuschaos.io/v1alpha1\nKind:         ChaosResult\nMetadata:\n  Creation Timestamp:  2021-09-29T13:28:59Z\n  Generation:          6\n  Resource Version:    66788\n  Self Link:           /apis/litmuschaos.io/v1alpha1/namespaces/default/chaosresults/engine-nginx-pod-delete\n  UID:                 fe7f01c8-8118-4761-8ff9-0a87824d863f\nSpec:\n  Engine:      engine-nginx\n  Experiment:  pod-delete\nStatus:\n  Experiment Status:\n    # step on which experiment fails\n    Fail Step:                 N/A\n    # phase of the chaos result\n    Phase:                     Completed\n    # Success Percentage of the litmus probes\n    Probe Success Percentage:  100\n    # Verdict of the chaos result\n    Verdict:                   Pass\n  History:\n    Failed Runs:   1\n    Passed Runs:   1\n    Stopped Runs:  0\n    Targets:\n      Chaos Status:  targeted\n      Kind:          deployment\n      Name:          hello\nEvents:              &lt;none&gt;\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-result/status-specification/#result-history","title":"Result History","text":"<p>It contains history of experiment runs present at <code>status.history</code>. It contains following fields:</p> <ul> <li><code>passedRuns</code>: It contains cumulative passed run count</li> <li><code>failedRuns</code>: It contains cumulative failed run count</li> <li><code>stoppedRuns</code>: It contains cumulative stopped run count</li> <li><code>targets.name</code>: It contains name of target application</li> <li><code>target.kind</code>: It contains kinds of target application</li> <li><code>target.chaosStatus</code>: It contains chaos status</li> </ul> View the history details <p> Field <code>.status.history.passedRuns</code> Description It contains cumulative passed run count Range  ANY NON NEGATIVE INTEGER  Notes The <code>.status.history.passedRuns</code> contains cumulative passed run counts for a specific ChaosResult. </p> <p> Field <code>.status.history.failedRuns</code> Description It contains cumulative failed run count Range  ANY NON NEGATIVE INTEGER  Notes The <code>.status.history.failedRuns</code> contains cumulative failed run counts for a specific ChaosResult. </p> <p> Field <code>.status.history.stoppedRuns</code> Description It contains cumulative stopped run count Range  ANY NON NEGATIVE INTEGER  Notes The <code>.status.history.stoppedRuns</code> contains cumulative stopped run counts for a specific ChaosResult. </p> <p> Field <code>.status.history.targets.name</code> Description It contains name of the target application Range  string  Notes The <code>.status.history.targets.name</code> contains name of the target application </p> <p> Field <code>.status.history.targets.kind</code> Description It contains kind of the target application Range  string  Notes The <code>.status.history.targets.kind</code> contains kind of the target application </p> <p> Field <code>.status.history.targets.chaosStatus</code> Description It contains status of the chaos Range  targeted, injected, reverted  Notes The <code>.status.history.targets.chaosStatus</code> contains status of the chaos </p> <p>view the sample example:</p> <pre><code>Name:         engine-nginx-pod-delete\nNamespace:    default\nLabels:       app.kubernetes.io/component=experiment-job\n              app.kubernetes.io/part-of=litmus\n              app.kubernetes.io/version=1.13.8\n              chaosUID=aa0a0084-f20f-4294-a879-d6df9aba6f9b\n              controller-uid=6943c955-0154-4542-8745-de991eb47c61\n              job-name=pod-delete-w4p5op\n              name=engine-nginx-pod-delete\nAnnotations:  &lt;none&gt;\nAPI Version:  litmuschaos.io/v1alpha1\nKind:         ChaosResult\nMetadata:\n  Creation Timestamp:  2021-09-29T13:28:59Z\n  Generation:          6\n  Resource Version:    66788\n  Self Link:           /apis/litmuschaos.io/v1alpha1/namespaces/default/chaosresults/engine-nginx-pod-delete\n  UID:                 fe7f01c8-8118-4761-8ff9-0a87824d863f\nSpec:\n  Engine:      engine-nginx\n  Experiment:  pod-delete\nStatus:\n  Experiment Status:\n    Fail Step:                 N/A\n    Phase:                     Completed\n    Probe Success Percentage:  100\n    Verdict:                   Pass\n  History:\n    # fail experiment run count\n    Failed Runs:   1\n    # passed experiment run count\n    Passed Runs:   1\n    # stopped experiment run count\n    Stopped Runs:  0\n    Targets:\n      # status of the chaos\n      Chaos Status:  targeted\n      # kind of the application\n      Kind:          deployment\n      # name of the application\n      Name:          hello\nEvents:              &lt;none&gt;\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/contents/","title":"Chaos Scheduler Specifications","text":"<p>Hold attributes for repeated execution (run now, once@timestamp, b/w start-end timestamp@ interval). Embeds the ChaosEngine as template</p> <p>This section describes the fields in the ChaosScheduler and the possible values that can be set against the same.</p> Parameter Description User Guide Schedule Once Schedule chaos once on specified time or now Schedule Once Repeat Schedule Schedule chaos in repeat mode Repeat Schedule Schedule State Defines the state of the schedule Schedule State Engine Specifications Defines the chaosengine specifications Engine Specifications"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/engine-specification/","title":"Engine Specification","text":"<p>It embeds the ChaosEngine as a template inside schedule CR. Which contains the chaosexperiment and target application details.</p> View the engine details <p> Field <code>.spec.engineTemplateSpec</code> Description Flag to control chaosengine to be formed  Type Mandatory Range n/a Default n/a Notes The <code>engineTemplateSpec</code> is the ChaosEngineSpec of ChaosEngine that is to be formed. </p>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/engine-specification/#engine-specification_1","title":"Engine Specification","text":"<p>Specify the chaosengine details at <code>spec.engineTemplateSpec</code> inside schedule CR</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      properties:\n         #format should be like \"10m\" or \"2h\" accordingly for minutes or hours\n        minChaosInterval: \"2m\"  \n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-once/","title":"Schedule Once","text":"<p>It schedule the chaos once either on the specified time or immediately after creation of schedule CR. </p> View the schedule once schema"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-once/#schedule-now","title":"Schedule NOW","text":"<p> Field <code>.spec.schedule.now</code> Description Flag to control the type of scheduling Type Mandatory Range <code>true</code>, <code>false</code> Default <code>n/a</code> Notes The <code>now</code> in the <code>spec.schedule</code> ensures immediate creation of chaosengine, i.e., injection of chaos."},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-once/#schedule-once_1","title":"Schedule Once","text":"<p> Field <code>.spec.schedule.once.executionTime</code> Description Flag to specify execution timestamp at which chaos is injected, when the policy is <code>once</code>. The chaosengine is created exactly at this timestamp. Type Mandatory Range user-defined (type: UTC Timeformat) Default n/a Notes <code>.spec.schedule.once</code> refers to a single-instance execution of chaos at a particular timestamp specified by <code>.spec.schedule.once.executionTime</code> </p>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-once/#immediate-chaos","title":"Immediate Chaos","text":"<p>It schedule the chaos immediately after creation of the chaos-schedule CR. It can be tuned via setting <code>spec.schedule.now</code> to <code>true</code>.</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    now: true\n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-once/#chaos-at-a-specified-timestamp","title":"Chaos at a Specified TimeStamp","text":"<p>It schedule the chaos once at the specified time. It can be tuned via setting <code>spec.schedule.once.executionTime</code>. The execution time should be in <code>UTC Timezone</code>. </p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    once:\n      #should be modified according to current UTC Time\n      executionTime: \"2020-05-12T05:47:00Z\"   \n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/","title":"Repeat Schedule","text":"<p>It schedule the chaos in the repeat mode. There are various ways we can set up this type of schedule by varying the the fields inside <code>spec.repeat</code>. </p> <p><code>Note</code> - We have just one field i.e. minChaosInterval to be specified as mandatory one. All other fields are optional and totally dependent on the desired behaviour.</p> View the schedule repeat schema <p> Field <code>.spec.schedule.repeat.timeRange.startTime</code> Description Flag to specify start timestamp of the range within which chaos is injected, when the policy is <code>repeat</code>. The chaosengine is not created before this timestamp. Type Mandatory Range user-defined (type: UTC Timeformat) Default n/a Notes When <code>startTime</code> is specified against the policy <code>repeat</code>, ChaosEngine will not be formed before this time, no matter when it was created. </p> <p> Field <code>.spec.schedule.repeat.timeRange.endTime</code> Description Flag to specify end timestamp of the range within which chaos is injected, when the policy is <code>repeat</code>. The chaosengine is not created after this timestamp. Type Mandatory Range user-defined (type: UTC Timeformat) Default n/a Notes When <code>endTime</code> is specified against the policy <code>repeat</code>, ChaosEngine will not be formed after this time. </p> <p> Field <code>.spec.schedule.repeat.properties.minChaosInterval.hour.everyNthHour</code> Description Flag to specify the hours between each successive schedule  Type Mandatory Range integer Default n/a Notes The <code>minChaosInterval.hour.everyNthHour</code> in the spec specifies the time interval in hours between each schedule </p> <p> Field <code>.spec.schedule.repeat.properties.minChaosInterval.hour.minuteOfTheHour</code> Description Flag to specify minute of hour for each successive schedule  Type Mandatory Range integer Default 0 Notes The <code>minChaosInterval.hour.minuteOfTheHour</code> in the spec specifies the minute of the hour between each schedule </p> <p> Field <code>.spec.schedule.repeat.properties.minChaosInterval.minute.everyNthMinute</code> Description Flag to specify the minutes for each successive schedule  Type Mandatory Range integer Default n/a Notes The <code>minChaosInterval.hour.everyNthMinute</code> in the spec specifies the time interval in minutes between each schedule </p> <p> Field <code>.spec.schedule.repeat.workDays.includedDays</code> Description Flag to specify the days at which chaos is allowed to take place Type Mandatory Range user-defined (type: string)(pattern: [{day_name},{day_name}...]). Default n/a Notes The <code>includedDays</code> in the spec specifies a (comma-separated) list of days of the week at which chaos is allowed to take place. {day_name} is to be specified with the first 3 letters of the name of day such as <code>Mon</code>, <code>Tue</code> etc. </p> <p> Field <code>.spec.schedule.repeat.workHours.includedHours</code> Description Flag to specify the hours at which chaos is allowed to take place Type Mandatory Range {hour_number} will range from 0 to 23 (type: string)(pattern: {hour_number}-{hour_number}). Default n/a Notes The <code>includedHours</code> in the spec specifies a range of hours of the day at which chaos is allowed to take place. 24 hour format is followed"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#basic-schema-to-execute-repeat-strategy","title":"Basic Schema to Execute Repeat Strategy","text":"<p>This will keep executing the schedule and creating engines for an indefinite amount of time.</p>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#schedule-chaosengine-at-every-nth-minute","title":"Schedule ChaosEngine at every nth minute","text":"<pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      properties:\n        minChaosInterval:\n          # schedule the chaos at every 5 minutes\n          minute:\n            everyNthMinute: 5  \n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#schedule-chaosengine-at-every-nth-hour","title":"Schedule ChaosEngine at every nth hour","text":"<pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      properties:\n        minChaosInterval:\n          # schedule the chaos every hour at 0th minute\n          hour:\n            everyNthHour: 1\n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#schedule-chaosengine-at-nth-minute-of-every-nth-hour","title":"Schedule ChaosEngine at nth minute of every nth hour","text":"<pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      properties:\n        minChaosInterval:\n          # schedule the chaos every hour at 30th minute\n          hour:\n            everyNthHour: 1\n            minuteOfTheHour: 30\n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#specifying-time-range-for-the-chaos-schedule","title":"Specifying Time Range for the Chaos Schedule","text":"<p>This will manipulate the schedule to be started and ended according to our definition.</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      timeRange:\n        #should be modified according to current UTC Time\n        startTime: \"2020-05-12T05:47:00Z\"   \n        endTime: \"2020-09-13T02:58:00Z\"   \n      properties:\n        minChaosInterval:\n          minute:\n            everyNthMinute: 5  \n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#specifying-just-the-end-time","title":"Specifying Just the End Time","text":"<p>Assumes the custom resource creation timestamp as the StartTime</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      timeRange:\n        #should be modified according to current UTC Time\n        endTime: \"2020-09-13T02:58:00Z\"   \n      properties:\n        minChaosInterval:\n          minute:\n            everyNthMinute: 5  \n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#specifying-just-the-starttime","title":"Specifying Just the StartTime","text":"<p>Executes chaos indefinitely (until the ChaosSchedule CR is removed) starting from the specified timestamp</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      timeRange:\n        #should be modified according to current UTC Time\n        startTime: \"2020-05-12T05:47:00Z\"   \n      properties:\n        minChaosInterval:\n          minute:\n            everyNthMinute: 5  \n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    auxiliaryAppInfo: ''\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#specifying-work-hours","title":"Specifying Work Hours","text":"<p>This ensures chaos execution within the specified hours of the day, everyday.</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      properties:\n        minChaosInterval:\n          minute:\n            everyNthMinute: 5   \n      workHours:\n        # format should be &lt;starting-hour-number&gt;-&lt;ending-hour-number&gt;(inclusive)\n        includedHours: 0-12\n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    # It can be true/false\n    annotationCheck: 'true'\n    #ex. values: ns1:name=percona,ns2:run=nginx\n    auxiliaryAppInfo: ''\n    chaosServiceAccount: pod-delete-sa\n    # It can be delete/retain\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/schedule-repeat/#specifying-work-days","title":"Specifying work days","text":"<p>This executes chaos on specified days of the week, with the specified minimum interval.</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosSchedule\nmetadata:\n  name: schedule-nginx\nspec:\n  schedule:\n    repeat:\n      properties:\n        minChaosInterval:\n          minute:\n            everyNthMinute: 5  \n      workDays:\n        includedDays: \"Mon,Tue,Wed,Sat,Sun\"\n  engineTemplateSpec:\n    engineState: 'active'\n    appinfo:\n      appns: 'default'\n      applabel: 'app=nginx'\n      appkind: 'deployment'\n    annotationCheck: 'true'\n    auxiliaryAppInfo: ''\n    chaosServiceAccount: pod-delete-sa\n    jobCleanUpPolicy: 'delete'\n    experiments:\n      - name: pod-delete\n        spec:\n          components:\n            env:\n              # set chaos duration (in sec) as desired\n              - name: TOTAL_CHAOS_DURATION\n                value: '30'\n\n              # set chaos interval (in sec) as desired\n              - name: CHAOS_INTERVAL\n                value: '10'\n\n              # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n              - name: FORCE\n                value: 'false'\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/state/","title":"Halt/Resume ChaosSchedule","text":"<p>Chaos Schedules can be <code>halted</code> or <code>resumed</code> as per need. It can tuned via setting <code>spec.scheduleState</code> to <code>halt</code> and <code>active</code> respectively. </p> View the state schema <p> Field <code>.spec.scheduleState</code> Description Flag to control chaosshedule state  Type Optional Range <code>active</code>, <code>halt</code>, <code>complete</code> Default <code>active</code> Notes The <code>scheduleState</code> is the current state of ChaosSchedule. If the schedule is running its state will be <code>active</code>, if the schedule is halted its state will be <code>halt</code> and if the schedule is completed it state will be <code>complete</code>. </p>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/state/#halt-the-schedule","title":"Halt The Schedule","text":"<p>Follow the below steps to halt the active schedule:</p> <ul> <li>Edit the ChaosSchedule CR in your favourite editor <pre><code>kubectl edit chaosschedule schedule-nginx\n</code></pre></li> <li>Change the spec.scheduleState to halt <pre><code>spec:\n  scheduleState: halt\n</code></pre></li> </ul>"},{"location":"experiments/concepts/chaos-resources/chaos-scheduler/state/#resume-the-schedule","title":"Resume The Schedule","text":"<p>Follow the below steps to resume the halted schedule:</p> <ul> <li>Edit the chaosschedule <pre><code>kubectl edit chaosschedule schedule-nginx\n</code></pre></li> <li>Change the spec.scheduleState to active <pre><code>spec:\n  scheduleState: active\n</code></pre></li> </ul>"},{"location":"experiments/concepts/chaos-resources/probes/cmdProbe/","title":"Command Probe","text":"<p>The command probe allows developers to run shell commands and match the resulting output as part of the entry/exit criteria. The intent behind this probe was to allow users to implement a non-standard &amp; imperative way of expressing their hypothesis. For example, the cmdProbe enables you to check for specific data within a database, parse the value out of a JSON blob being dumped into a certain path, or check for the existence of a particular string in the service logs. It can be executed by setting <code>type</code> as <code>cmdProbe</code> inside <code>.spec.experiments[].spec.probe</code>.</p> View the command probe schema <p> Field <code>.name</code> Description Flag to hold the name of the probe Type Mandatory Range n/a  (type: string) Notes The <code>.name</code> holds the name of the probe. It can be set based on the usecase </p> <p> Field <code>.type</code> Description Flag to hold the type of the probe Type Mandatory Range <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> Notes The <code>.type</code> supports four type of probes. It can one of the <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> </p> <p> Field <code>.mode</code> Description Flag to hold the mode of the probe Type Mandatory Range <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> Notes The <code>.mode</code> supports five modes of probes. It can one of the <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> </p> <p> Field <code>.cmdProbe/inputs.command</code> Description Flag to hold the command for the cmdProbe Type Mandatory Range n/a {type: string} Notes The <code>.cmdProbe/inputs.command</code> contains the shell command, which should be run as part of cmdProbe </p> <p> Field <code>.cmdProbe/inputs.source</code> Description Flag to hold the source for the cmdProbe Type Mandatory Range  It contains the source attributes i.e, image, imagePullPolicy Notes The <code>.cmdProbe/inputs.source</code> It supports <code>inline</code> mode where command should be run within the experiment pod, and it can be tuned by omiting source field. Otherwise provide the source details(i.e, image) which can be used to launch a external pod where the command execution is carried out. </p> <p> Field <code>.cmdProbe/inputs.comparator.type</code> Description Flag to hold type of the data used for comparision Type Mandatory Range <code>string</code>, <code>int</code>, <code>float</code> Notes The <code>.cmdProbe/inputs.comparator.type</code> contains type of data, which should be compare as part of comparision operation </p> <p> Field <code>.cmdProbe/inputs.comparator.criteria</code> Description Flag to hold criteria for the comparision Type Mandatory Range  it supports {&gt;=, &lt;=, ==, &gt;, &lt;, !=, oneOf, between} for int &amp; float type. And {equal, notEqual, contains, matches, notMatches, oneOf} for string type. Notes The <code>.cmdProbe/inputs.comparator.criteria</code> contains criteria of the comparision, which should be fulfill as part of comparision operation. </p> <p> Field <code>.cmdProbe/inputs.comparator.value</code> Description Flag to hold value for the comparision Type Mandatory Range  n/a {type: string} Notes The <code>.cmdProbe/inputs.comparator.value</code> contains value of the comparision, which should follow the given criteria as part of comparision operation. </p> <p> Field <code>.runProperties.probeTimeout</code> Description Flag to hold the timeout for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.probeTimeout</code> represents the time limit for the probe to execute the specified check and return the expected data </p> <p> Field <code>.runProperties.retry</code> Description Flag to hold the retry count for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.retry</code> contains the number of times a check is re-run upon failure in the first attempt before declaring the probe status as failed. </p> <p> Field <code>.runProperties.interval</code> Description Flag to hold the interval for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.interval</code> contains the interval for which probes waits between subsequent retries </p> <p> Field <code>.runProperties.probePollingInterval</code> Description Flag to hold the polling interval for the probes(applicable for <code>Continuous</code> mode only) Type Optional Range n/a {type: integer} Notes The <code>.runProperties.probePollingInterval</code> contains the time interval for which continuous probe should be sleep after each iteration </p> <p> Field <code>.runProperties.initialDelaySeconds</code> Description Flag to hold the initial delay interval for the probes Type Optional Range n/a {type: integer} Notes The <code>.runProperties.initialDelaySeconds</code> represents the initial waiting time interval for the probes. </p> <p> Field <code>.runProperties.stopOnFailure</code> Description  Flags to hold the stop or continue the experiment on probe failure Type Optional Range false {type: boolean} Notes The <code>.runProperties.stopOnFailure</code> can be set to true/false to stop or continue the experiment execution after probe fails </p>"},{"location":"experiments/concepts/chaos-resources/probes/cmdProbe/#common-probe-tunables","title":"Common Probe Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the probes.</p>"},{"location":"experiments/concepts/chaos-resources/probes/cmdProbe/#inline-mode","title":"Inline Mode","text":"<p>In inline mode, the command probe is executed from within the experiment pod. It is preferred for simple shell commands.  It is default mode, and it can be tuned by omitting source field.</p> <p>Use the following example to tune this:</p> <pre><code># execute the command inside the experiment pod itself\n# cases where command doesn't need any extra binaries which is not available in litmsuchaos/go-runner image\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-database-integrity\"\n        type: \"cmdProbe\"\n        cmdProbe/inputs:\n          # command which needs to run in cmdProbe\n          command: \"&lt;command&gt;\"\n          comparator:\n            # output type for the above command\n            # supports: string, int, float\n            type: \"string\"\n            # criteria which should be followed by the actual output and the expected output\n            #supports [&gt;=, &lt;=, &gt;, &lt;, ==, !=] for int and float\n            # supports [contains, equal, notEqual, matches, notMatches] for string values\n            criteria: \"contains\"\n            # expected value, which should follow the specified criteria\n            value: \"&lt;value-for-criteria-match&gt;\"\n        mode: \"Edge\"\n        runProperties:\n          probeTimeout: 5\n          interval: 5\n          retry: 1\n          initialDelaySeconds: 5\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/cmdProbe/#source-mode","title":"Source Mode","text":"<p>In source mode, the command execution is carried out from within a new pod whose image can be specified. It can be used when application-specific binaries are required.</p> View the source probe schema <p> Field <code>.image</code> Description Flag to hold the image of the source pod Type Mandatory Range n/a  (type: string) Notes The <code>.image</code> holds the image of the source pod/td&gt;  <p> Field <code>.hostNetwork</code> Description Flag to enable the hostNetwork for the source pod Type Optional Range (type: boolean) Notes The <code>.hostNetwork</code> flag to enable the hostnetwork. It supports boolean values and default value is false/td&gt;  <p> Field <code>.args</code> Description Flag to hold the args for the source pod Type Optional Range (type: []string]) Notes The <code>.args</code> flag to hold the args for source pod/td&gt;  <p> Field <code>.env</code> Description Flag to hold the envs for the source pod Type Optional Range (type: []corev1.EnvVar]) Notes The <code>.env</code> flag to hold the envs for source pod/td&gt;  <p> Field <code>.labels</code> Description Flag to hold the labels for the source pod Type Optional Range (type: map[string]string) Notes The <code>.labels</code> flag to hold the labels for source pod/td&gt;  <p> Field <code>.annotations</code> Description Flag to hold the annotations for the source pod Type Optional Range (type: map[string]string) Notes The <code>.annotations</code> flag to hold the annotations for source pod/td&gt;  <p> Field <code>.command</code> Description Flag to hold the command for the source pod Type Optional Range (type: []string Notes The <code>.command</code> flag to hold the command for source pod/td&gt;  <p> Field <code>.imagePullPolicy</code> Description Flag to set the imagePullPolicy for the source pod Type Optional Range (type: corev1.PullPolicy Notes The <code>.imagePullPolicy</code> Flag to set the imagePullPolicy for the source pod/td&gt;  <p> Field <code>.privileged</code> Description Flag to set the privileged for the source pod Type Optional Range (type: boolean Notes The <code>.privileged</code> Flag to set the privileged for the source pod. Default value is false/td&gt;  <p> Field <code>.nodeSelector</code> Description Flag to hold the node selectors for the probe pod Type Optional Range (type: map[string]string Notes The <code>.nodeSelector</code> Flag to hold the node selectors for the probe pod/td&gt;  <p> Field <code>.tolerations</code> Description Flag to hold the tolerations for the probe pod Type Optional Range (type: []corev1.Tolerations Notes The <code>.tolerations</code> Flag to hold the Tolerations for the probe pod </p> <p> Field <code>.volumes</code> Description Flag to hold the volumes for the source pod Type Optional Range (type: []corev1.Volume Notes The <code>.volumes</code> Flag to hold the volumes for source pod/td&gt;  <p> Field <code>.volumeMount</code> Description Flag to hold the volume mounts for the source pod Type Optional Range (type: []corev1.VolumeMount Notes The <code>.volumes</code> Flag to hold the volume Mounts for source pod/td&gt;  <p> Field <code>.imagePullSecrets</code> Description Flag to set the imagePullSecrets for the source pod Type Optional Range (type: []corev1.LocalObjectReference Notes The <code>.imagePullSecrets</code> Flag to set the imagePullSecrets for the source pod/td&gt;  <p>Use the following example to tune this:</p> <pre><code># it launches the external pod with the source image and run the command inside the same pod\n# cases where command needs an extra binaries which is not available in litmsuchaos/go-runner image\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-database-integrity\"\n        type: \"cmdProbe\"\n        cmdProbe/inputs:\n          # command which needs to run in cmdProbe\n          command: \"&lt;command&gt;\"\n          comparator:\n            # output type for the above command\n            # supports: string, int, float\n            type: \"string\"\n            # criteria which should be followed by the actual output and the expected output\n            #supports [&gt;=, &lt;=, &gt;, &lt;, ==, !=, oneOf, between] for int and float\n            # supports [contains, equal, notEqual, matches, notMatches, oneOf] for string values\n            criteria: \"contains\"\n            # expected value, which should follow the specified criteria\n            value: \"&lt;value-for-criteria-match&gt;\"\n          # source for the cmdProbe\n          source:\n            image: \"&lt;source-image&gt;\"\n            imagePullPolicy: Always\n            privileged: true\n            hostNetwork: false\n        mode: \"Edge\"\n        runProperties:\n          probeTimeout: 5\n          interval: 5\n          retry: 1\n          initialDelaySeconds: 5\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/contents/","title":"Probes Specifications","text":"<p>Litmus probes are pluggable checks that can be defined within the ChaosEngine for any chaos experiment. The experiment pods execute these checks based on the mode they are defined in &amp; factor their success as necessary conditions in determining the verdict of the experiment (along with the standard \u201cin-built\u201d checks).</p> Probe Name Description User Guide Command Probe It defines the command probes Command Probe HTTP Probe It defines the http probes HTTP Probe K8S Probe It defines the k8s probes K8S Probe Prometheus Probe It defines the prometheus probes Prometheus Probe Probe Chaining It chain the litmus probes Probe Chaining"},{"location":"experiments/concepts/chaos-resources/probes/httpProbe/","title":"HTTP Probe","text":"<p>The http probe allows developers to specify a URL which the experiment uses to gauge health/service availability (or other custom conditions) as part of the entry/exit criteria. The received status code is mapped against an expected status. It supports http Get and Post methods. It can be executed by setting <code>type</code> as <code>httpProbe</code> inside <code>.spec.experiments[].spec.probe</code>.</p> View the http probe schema <p> Field <code>.name</code> Description Flag to hold the name of the probe Type Mandatory Range n/a  (type: string) Notes The <code>.name</code> holds the name of the probe. It can be set based on the usecase </p> <p> Field <code>.type</code> Description Flag to hold the type of the probe Type Mandatory Range <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> Notes The <code>.type</code> supports four type of probes. It can one of the <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> </p> <p> Field <code>.mode</code> Description Flag to hold the mode of the probe Type Mandatory Range <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> Notes The <code>.mode</code> supports five modes of probes. It can one of the <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> </p> <p> Field <code>.httpProbe/inputs.url</code> Description Flag to hold the URL for the httpProbe Type Mandatory Range  n/a {type: string} Notes The <code>.httpProbe/inputs.url</code> contains the URL which the experiment uses to gauge health/service availability (or other custom conditions) as part of the entry/exit criteria. </p> <p> Field <code>.httpProbe/inputs.insecureSkipVerify</code> Description Flag to hold the flag to skip certificate checks for the httpProbe Type Optional Range <code>true</code>, <code>false</code> Notes The <code>.httpProbe/inputs.insecureSkipVerify</code> contains flag to skip certificate checks. </p> <p> Field <code>.httpProbe/inputs.responseTimeout</code> Description Flag to hold the flag to response timeout for the httpProbe Type Optional Range  n/a {type: integer} Notes The <code>.httpProbe/inputs.responseTimeout</code> contains flag to provide the response timeout for the http Get/Post request. </p> <p> Field <code>.httpProbe/inputs.method.get.criteria</code> Description Flag to hold the criteria for the http get request Type Mandatory Range <code>==</code>, <code>!=</code>, <code>oneOf</code> Notes The <code>.httpProbe/inputs.method.get.criteria</code> contains criteria to match the http get request's response code with the expected responseCode, which need to be fulfill as part of httpProbe run </p> <p> Field <code>.httpProbe/inputs.method.get.responseCode</code> Description Flag to hold the expected response code for the get request Type Mandatory Range  HTTP_RESPONSE_CODE Notes The <code>.httpProbe/inputs.method.get.responseCode</code> contains the expected response code for the http get request as part of httpProbe run </p> <p> Field <code>.httpProbe/inputs.method.post.contentType</code> Description Flag to hold the content type of the post request Type Mandatory Range  n/a {type: string} Notes The <code>.httpProbe/inputs.method.post.contentType</code> contains the content type of the http body data, which need to be passed for the http post request </p> <p> Field <code>.httpProbe/inputs.method.post.body</code> Description Flag to hold the body of the http post request Type Mandatory Range  n/a {type: string} Notes The <code>.httpProbe/inputs.method.post.body</code> contains the http body, which is required for the http post request. It is used for the simple http body. If the http body is complex then use <code>.httpProbe/inputs.method.post.bodyPath</code> field. </p> <p> Field <code>.httpProbe/inputs.method.post.bodyPath</code> Description Flag to hold the path of the http body, required for the http post request Type Optional Range  n/a {type: string} Notes The <code>.httpProbe/inputs.method.post.bodyPath</code> This field is used in case of complex POST request in which the body spans multiple lines, the bodyPath attribute can be used to provide the path to a file consisting of the same. This file can be made available to the experiment pod via a ConfigMap resource, with the ConfigMap name being defined in the ChaosEngine OR the ChaosExperiment CR. </p> <p> Field <code>.httpProbe/inputs.method.post.criteria</code> Description Flag to hold the criteria for the http post request Type Mandatory Range <code>==</code>, <code>!=</code>, <code>oneOf</code> Notes The <code>.httpProbe/inputs.method.post.criteria</code> contains criteria to match the http post request's response code with the expected responseCode, which need to be fulfill as part of httpProbe run </p> <p> Field <code>.httpProbe/inputs.method.post.responseCode</code> Description Flag to hold the expected response code for the post request Type Mandatory Range  HTTP_RESPONSE_CODE Notes The <code>.httpProbe/inputs.method.post.responseCode</code> contains the expected response code for the http post request as part of httpProbe run </p> <p> Field <code>.runProperties.probeTimeout</code> Description Flag to hold the timeout for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.probeTimeout</code> represents the time limit for the probe to execute the specified check and return the expected data </p> <p> Field <code>.runProperties.retry</code> Description Flag to hold the retry count for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.retry</code> contains the number of times a check is re-run upon failure in the first attempt before declaring the probe status as failed. </p> <p> Field <code>.runProperties.interval</code> Description Flag to hold the interval for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.interval</code> contains the interval for which probes waits between subsequent retries </p> <p> Field <code>.runProperties.probePollingInterval</code> Description Flag to hold the polling interval for the probes(applicable for <code>Continuous</code> mode only) Type Optional Range n/a {type: integer} Notes The <code>.runProperties.probePollingInterval</code> contains the time interval for which continuous probe should be sleep after each iteration </p> <p> Field <code>.runProperties.initialDelaySeconds</code> Description Flag to hold the initial delay interval for the probes Type Optional Range n/a {type: integer} Notes The <code>.runProperties.initialDelaySeconds</code> represents the initial waiting time interval for the probes. </p> <p> Field <code>.runProperties.stopOnFailure</code> Description  Flags to hold the stop or continue the experiment on probe failure Type Optional Range false {type: boolean} Notes The <code>.runProperties.stopOnFailure</code> can be set to true/false to stop or continue the experiment execution after probe fails </p>"},{"location":"experiments/concepts/chaos-resources/probes/httpProbe/#common-probe-tunables","title":"Common Probe Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the probes.</p>"},{"location":"experiments/concepts/chaos-resources/probes/httpProbe/#http-get-request","title":"HTTP Get Request","text":"<p>In HTTP Get method, it sends an http GET request to the provided URL and matches the response code based on the given criteria(==, !=, oneOf). It can be executed by setting <code>httpProbe/inputs.method.get</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the http probes with get method and verify the response code\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          method:\n            # call http get method and verify the response code\n            get: \n              # criteria which should be matched\n              criteria: == # ==, !=, oneof\n              # exepected response code for the http request, which should follow the specified criteria\n              responseCode: \"&lt;response code&gt;\"\n        mode: \"Continuous\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/httpProbe/#http-post-requesthttp-body-is-a-simple","title":"HTTP Post Request(http body is a simple)","text":"<p>It contains the http body, which is required for the http post request. It is used for the simple http body. The http body can be provided in the <code>body</code> field. It can be executed by setting <code>httpProbe/inputs.method.post.body</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the http probes with post method and verify the response code\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          method:\n            # call http post method and verify the response code\n            post: \n              # value of the http body, used for the post request\n              body: \"&lt;http-body&gt;\"\n              # http body content type\n              contentType: \"application/json; charset=UTF-8\"\n              # criteria which should be matched\n              criteria: \"==\" # ==, !=, oneof\n              # exepected response code for the http request, which should follow the specified criteria\n              responseCode: \"200\"\n        mode: \"Continuous\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/httpProbe/#http-post-requesthttp-body-is-a-complex","title":"HTTP Post Request(http body is a complex)","text":"<p>In the case of a complex POST request in which the body spans multiple lines, the <code>bodyPath</code> attribute can be used to provide the path to a file consisting of the same. This file can be made available to the experiment pod via a ConfigMap resource, with the ConfigMap name being defined in the ChaosEngine OR the ChaosExperiment CR. It can be executed by setting <code>httpProbe/inputs.method.post.body</code> field.</p> <p><code>NOTE</code>: It is mutually exclusive with the <code>body</code> field. If <code>body</code> is set then it will use the body field for the post request otherwise, it will use the <code>bodyPath</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the http probes with post method and verify the response code\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          method:\n            # call http post method and verify the response code\n            post: \n              # the configMap should be mounted to the experiment which contains http body\n              # use the mounted path here\n              bodyPath: \"/mnt/body.yml\"\n              # http body content type\n              contentType: \"application/json; charset=UTF-8\"\n              # criteria which should be matched\n              criteria: \"==\" # ==, !=, oneof\n              # exepected response code for the http request, which should follow the specified criteria\n              responseCode: \"200\"\n        mode: \"Continuous\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/httpProbe/#response-timout","title":"Response Timout","text":"<p>It contains a flag to provide the response timeout for the http Get/Post request. It can be tuned via <code>.httpProbe/inputs.responseTimeout</code> field. It is an optional field and its unit is milliseconds.</p> <p>Use the following example to tune this:</p> <pre><code># defines the response timeout for the http probe\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          # timeout for the http requests\n          responseTimeout: 100 #in ms\n          method:\n            get: \n              criteria: == # ==, !=, oneof\n              responseCode: \"&lt;response code&gt;\"\n        mode: \"Continuous\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/httpProbe/#skip-certification-check","title":"Skip Certification Check","text":"<p>It contains flag to skip certificate checks. It can bed tuned via <code>.httpProbe/inputs.insecureSkipVerify</code> field. It supports boolean values. Provide it to <code>true</code> to skip the certificate checks. Its default value is false.</p> <p>Use the following example to tune this:</p> <pre><code># skip the certificate checks for the httpProbe\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          # skip certificate checks for the httpProbe\n          # supports: true, false. default: false\n          insecureSkipVerify: \"true\"\n          method:\n            get: \n              criteria: == \n              responseCode: \"&lt;response code&gt;\"\n        mode: \"Continuous\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/k8sProbe/","title":"K8S Probe","text":"<p>With the proliferation of custom resources &amp; operators, especially in the case of stateful applications, the steady-state is manifested as status parameters/flags within Kubernetes resources. <code>k8sProbe</code> addresses verification of the desired resource state by allowing users to define the Kubernetes GVR (group-version-resource) with appropriate filters (field selectors/label selectors). The experiment makes use of the Kubernetes Dynamic Client to achieve this. It supports CRUD operations which can be defined at <code>probe.k8sProbe/inputs.operation</code>. It can be executed by setting <code>type</code> as <code>k8sProbe</code> inside <code>.spec.experiments[].spec.probe</code>.</p> View the k8s probe schema <p> Field <code>.name</code> Description Flag to hold the name of the probe Type Mandatory Range n/a  (type: string) Notes The <code>.name</code> holds the name of the probe. It can be set based on the usecase </p> <p> Field <code>.type</code> Description Flag to hold the type of the probe Type Mandatory Range <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> Notes The <code>.type</code> supports four type of probes. It can one of the <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> </p> <p> Field <code>.mode</code> Description Flag to hold the mode of the probe Type Mandatory Range <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> Notes The <code>.mode</code> supports five modes of probes. It can one of the <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> </p> <p> Field <code>.k8sProbe/inputs.group</code> Description Flag to hold the group of the kubernetes resource for the k8sProbe Type Mandatory Range  n/a {type: string} Notes The <code>.k8sProbe/inputs.group</code> contains group of the kubernetes resource on which k8sProbe performs the specified operation </p> <p> Field <code>.k8sProbe/inputs.version</code> Description Flag to hold the apiVersion of the kubernetes resource for the k8sProbe Type Mandatory Range  n/a {type: string} Notes The <code>.k8sProbe/inputs.version</code> contains apiVersion of the kubernetes resource on which k8sProbe performs the specified operation </p> <p> Field <code>.k8sProbe/inputs.resource</code> Description Flag to hold the kubernetes resource name for the k8sProbe Type Mandatory Range  n/a {type: string} Notes The <code>.k8sProbe/inputs.resource</code> contains the kubernetes resource name on which k8sProbe performs the specified operation </p> <p> Field <code>.k8sProbe/inputs.namespace</code> Description Flag to hold the namespace of the kubernetes resource for the k8sProbe Type Mandatory Range  n/a {type: string} Notes The <code>.k8sProbe/inputs.namespace</code> contains namespace of the kubernetes resource on which k8sProbe performs the specified operation </p> <p> Field <code>.k8sProbe/inputs.fieldSelector</code> Description Flag to hold the fieldSelectors of the kubernetes resource for the k8sProbe Type Optional Range  n/a {type: string} Notes The <code>.k8sProbe/inputs.fieldSelector</code> contains fieldSelector to derived the kubernetes resource on which k8sProbe performs the specified operation </p> <p> Field <code>.k8sProbe/inputs.labelSelector</code> Description Flag to hold the labelSelectors of the kubernetes resource for the k8sProbe Type Optional Range  n/a {type: string} Notes The <code>.k8sProbe/inputs.labelSelector</code> contains labelSelector to derived the kubernetes resource on which k8sProbe performs the specified operation </p> <p> Field <code>.k8sProbe/inputs.operation</code> Description Flag to hold the operation type for the k8sProbe Type Mandatory Range <code>create</code>, <code>delete</code>, <code>present</code>, <code>absent</code> Notes The <code>.k8sProbe/inputs.operation</code> contains operation which should be applied on the kubernetes resource as part of k8sProbe. It supports four type of operation. It can be one of <code>create</code>, <code>delete</code>, <code>present</code>, <code>absent</code>. </p> <p> Field <code>.runProperties.probeTimeout</code> Description Flag to hold the timeout for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.probeTimeout</code> represents the time limit for the probe to execute the specified check and return the expected data </p> <p> Field <code>.runProperties.retry</code> Description Flag to hold the retry count for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.retry</code> contains the number of times a check is re-run upon failure in the first attempt before declaring the probe status as failed. </p> <p> Field <code>.runProperties.interval</code> Description Flag to hold the interval for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.interval</code> contains the interval for which probes waits between subsequent retries </p> <p> Field <code>.runProperties.probePollingInterval</code> Description Flag to hold the polling interval for the probes(applicable for <code>Continuous</code> mode only) Type Optional Range n/a {type: integer} Notes The <code>.runProperties.probePollingInterval</code> contains the time interval for which continuous probe should be sleep after each iteration </p> <p> Field <code>.runProperties.initialDelaySeconds</code> Description Flag to hold the initial delay interval for the probes Type Optional Range n/a {type: integer} Notes The <code>.runProperties.initialDelaySeconds</code> represents the initial waiting time interval for the probes. </p> <p> Field <code>.runProperties.stopOnFailure</code> Description  Flags to hold the stop or continue the experiment on probe failure Type Optional Range false {type: boolean} Notes The <code>.runProperties.stopOnFailure</code> can be set to true/false to stop or continue the experiment execution after probe fails </p>"},{"location":"experiments/concepts/chaos-resources/probes/k8sProbe/#common-probe-tunables","title":"Common Probe Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the probes.</p>"},{"location":"experiments/concepts/chaos-resources/probes/k8sProbe/#create-operation","title":"Create Operation","text":"<p>It creates kubernetes resource based on the data provided inside <code>probe.data</code> field. It can be defined by setting <code>operation</code> to <code>create</code> operation.</p> <p>Use the following example to tune this:</p> <pre><code># create the given resource provided inside data field\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"create-percona-pvc\"\n        type: \"k8sProbe\"\n        k8sProbe/inputs:\n          # group of the resource\n          group: \"\"\n          # version of the resource\n          version: \"v1\"\n          # name of the resource\n          resource: \"persistentvolumeclaims\"\n          # namespace where the instance of resource should be created\n          namespace: \"default\"\n          # type of operation\n          # supports: create, delete, present, absent\n          operation: \"create\"\n        mode: \"SOT\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n        # contains manifest, which can be used to create the resource\n        data: |\n          kind: PersistentVolumeClaim\n          apiVersion: v1\n          metadata:\n            name: percona-mysql-claim\n            labels:\n              openebs.io/target-affinity: percona\n          spec:\n            storageClassName: standard\n            accessModes:\n            - ReadWriteOnce\n            resources:\n              requests:\n                storage: 100Mi\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/k8sProbe/#delete-operation","title":"Delete Operation","text":"<p>It deletes matching kubernetes resources via GVR and filters (field selectors/label selectors) provided at <code>probe.k8sProbe/inputs</code>. It can be defined by setting <code>operation</code> to <code>delete</code> operation.</p> <p>Use the following example to tune this:</p> <pre><code># delete the resource matched with the given inputs\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"delete-percona-pvc\"\n        type: \"k8sProbe\"\n        k8sProbe/inputs:\n          # group of the resource\n          group: \"\"\n          # version of the resource\n          version: \"v1\"\n          # name of the resource\n          resource: \"persistentvolumeclaims\"\n          # namespace of the instance, which needs to be deleted\n          namespace: \"default\"\n          # labels selectors for the k8s resource, which needs to be deleted\n          labelSelector: \"openebs.io/target-affinity=percona\"\n          # fieldselector for the k8s resource, which needs to be deleted\n          fieldSelector: \"\"\n          # type of operation\n          # supports: create, delete, present, absent\n          operation: \"delete\"\n        mode: \"EOT\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/k8sProbe/#present-operation","title":"Present Operation","text":"<p>It checks for the presence of kubernetes resource based on GVR and filters (field selectors/labelselectors) provided at <code>probe.k8sProbe/inputs</code>. It can be defined by setting <code>operation</code> to <code>present</code> operation.</p> <p>Use the following example to tune this:</p> <pre><code># verify the existance of the resource matched with the given inputs inside cluster\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-percona-pvc-presence\"\n        type: \"k8sProbe\"\n        k8sProbe/inputs:\n          # group of the resource\n          group: \"\"\n          # version of the resource\n          version: \"v1\"\n          # name of the resource\n          resource: \"persistentvolumeclaims\"\n          # namespace where the instance of resource\n          namespace: \"default\"\n          # labels selectors for the k8s resource\n          labelSelector: \"openebs.io/target-affinity=percona\"\n          # fieldselector for the k8s resource\n          fieldSelector: \"\"\n          # type of operation\n          # supports: create, delete, present, absent\n          operation: \"present\"\n        mode: \"SOT\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/k8sProbe/#absent-operation","title":"Absent Operation","text":"<p>It checks for the absence of kubernetes resource based on GVR and filters (field selectors/labelselectors)  provided at <code>probe.k8sProbe/inputs</code>. It can be defined by setting <code>operation</code> to <code>absent</code> operation.</p> <p>Use the following example to tune this:</p> <pre><code># verify that the no resource should be present in cluster with the given inputs\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-percona-pvc-absence\"\n        type: \"k8sProbe\"\n        k8sProbe/inputs:\n          # group of the resource\n          group: \"\"\n          # version of the resource\n          version: \"v1\"\n          # name of the resource\n          resource: \"persistentvolumeclaims\"\n          # namespace where the instance of resource\n          namespace: \"default\"\n          # labels selectors for the k8s resource\n          labelSelector: \"openebs.io/target-affinity=percona\"\n          # fieldselector for the k8s resource\n          fieldSelector: \"\"\n          # type of operation\n          # supports: create, delete, present, absent\n          operation: \"absent\"\n        mode: \"EOT\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/","title":"Introduction","text":"<p>Litmus probes are pluggable checks that can be defined within the ChaosEngine for any chaos experiment. The experiment pods execute these checks based on the mode they are defined in &amp; factor their success as necessary conditions in determining the verdict of the experiment (along with the standard \u201cin-built\u201d checks). It can be provided at <code>.spec.experiments[].spec.probe</code> inside chaosengine.  It supports four types: <code>cmdProbe</code>, <code>k8sProbe</code>, <code>httpProbe</code>, and <code>promProbe</code>.</p>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#probe-modes","title":"Probe Modes","text":"<p>The probes can be set up to run in five different modes. Which can be tuned via <code>mode</code> ENV.</p> <ul> <li><code>SOT</code>: Executed at the Start of the Test as a pre-chaos check</li> <li><code>EOT</code>: Executed at the End of the Test as a post-chaos check</li> <li><code>Edge</code>: Executed both, before and after the chaos</li> <li><code>Continuous</code>: The probe is executed continuously, with a specified polling interval during the chaos injection.</li> <li><code>OnChaos</code>: The probe is executed continuously, with a specified polling interval strictly for chaos duration of chaos</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains the common attributes or run properties\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          insecureSkipVerify: false\n          responseTimeout: &lt;value&gt;\n          method:\n            get: \n              criteria: ==\n              responseCode: \"&lt;response code&gt;\"\n        # modes for the probes\n        # supports: [SOT, EOT, Edge, Continuous, OnChaos]\n        mode: \"Continuous\"\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#run-properties","title":"Run Properties","text":"<p>All probes share some common attributes. Which can be tuned via <code>runProperties</code> ENV.</p> <ul> <li><code>probeTimeout</code>: Represents the time limit for the probe to execute the check specified and return the expected data.</li> <li><code>retry</code>: The number of times a check is re-run upon failure in the first attempt before declaring the probe status as failed.</li> <li><code>interval</code>: The period between subsequent retries</li> <li><code>probePollingInterval</code>: The time interval for which continuous/onchaos probes should be sleep after each iteration.</li> </ul> <p>Use the following example to tune this:</p> <pre><code># contains the common attributes or run properties\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          insecureSkipVerify: false\n          responseTimeout: &lt;value&gt;\n          method:\n            get: \n              criteria: ==\n              responseCode: \"&lt;response code&gt;\"\n        mode: \"Continuous\"\n        # contains runProperties for the probes\n        runProperties:\n          # time limit for the probe to execute the specified check\n          probeTimeout: 5 #in seconds\n          # the time period between subsequent retries\n          interval: 2 #in seconds\n          # number of times a check is re-run upon failure before declaring the probe status as failed\n          retry: 1\n          #time interval for which continuous probe should wait after each iteration\n          # applicable for onChaos and Continuous probes\n          probePollingInterval: 2\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#initial-delay-seconds","title":"Initial Delay Seconds","text":"<p>It Represents the initial waiting time interval for the probes. It can be tuned via  <code>initialDelaySeconds</code> ENV.</p> <p>Use the following example to tune this:</p> <pre><code># contains the initial delay seconds for the probes\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          insecureSkipVerify: false\n          responseTimeout: &lt;value&gt;\n          method:\n            get: \n              criteria: ==\n              responseCode: \"&lt;response code&gt;\"\n        mode: \"Continuous\"\n        # contains runProperties for the probes\n        RunProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n          #initial waiting time interval for the probes\n          initialDelaySeconds: 30 #in seconds\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#stopcontinue-experiment-on-probe-failure","title":"Stop/Continue Experiment On Probe Failure","text":"<p>It can be set to true/false to stop or continue the experiment execution after the probe fails. It can be tuned via <code>stopOnFailure</code> ENV.  It supports boolean values. The default value is <code>false</code>.</p> <p>Use the following example to tune this:</p> <pre><code># contains the flag to stop/continue experiment based on the specified flag\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-frontend-access-url\"\n        type: \"httpProbe\"\n        httpProbe/inputs:\n          url: \"&lt;url&gt;\"\n          insecureSkipVerify: false\n          responseTimeout: &lt;value&gt;\n          method:\n            get: \n              criteria: ==\n              responseCode: \"&lt;response code&gt;\"\n        mode: \"Continuous\"\n        # contains runProperties for the probes\n        runProperties:\n          probeTimeout: 5 \n          interval: 2 \n          retry: 1\n          probePollingInterval: 2\n          #it can be set to true/false to stop or continue the experiment execution after probe fails\n          # supports: true, false. default: false\n          stopOnFailure: true\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#comparator","title":"Comparator","text":"<p>Comparator used to validate the SLO based on the probe's actual and expected values for the specified criteria. </p> View the comparator's supported fields <p> Field <code>.type</code> Description Flag to hold type of the probe's output Type Mandatory Range {int, float, string} (type: string) Notes The <code>.type</code> holds the type of the probe's output/td&gt;  <p> Field <code>.criteria</code> Description Flag to hold the criteria, which should to be followed by the actual and expected probe outputs Type Mandatory Range  Float &amp; Int type: {&gt;,&lt;.&lt;=,&gt;=,==,!=,oneOf,between}, String type: {equal, notEqual, contains, matches, notMatches, oneOf}  Notes The <code>.criteria</code> holds the criteria, which should to be followed by the actual and expected probe outputs  </p> <p> Field <code>.value</code> Description Flag to hold the probe's expected value, which should follow the specified criteria Type Mandatory Range  value can be of int, float, string, slice type Notes The <code>.value</code> hold the probe's expected value, which should follow the specified criteria  </p> <p>Use the following example to tune this:</p> <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n  appns: \"default\"\n  applabel: \"app=nginx\"\n  appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-database-integrity\"\n        type: \"cmdProbe\"\n        cmdProbe/inputs:\n          command: \"&lt;command&gt;\"\n          comparator:\n            # output type for the above command\n            # supports: string, int, float\n            type: \"string\"\n            # criteria which should be followed by the actual output and the expected output\n            #supports [&gt;=, &lt;=, &gt;, &lt;, ==, !=, oneOf, between] for int and float\n            # supports [contains, equal, notEqual, matches, notMatches, oneOf] for string values\n            criteria: \"contains\"\n            # expected value, which should follow the specified criteria\n            value: \"&lt;value-for-criteria-match&gt;\"\n          source:\n            image: \"&lt;source-image&gt;\"\n        mode: \"Edge\"\n        runProperties:\n          probeTimeout: 5\n          interval: 5\n          retry: 1\n          initialDelaySeconds: 5\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#arithmetic-criteria","title":"Arithmetic criteria:","text":"<p>It is used to compare the numeric values(int,float) for arithmetic comparisons. It consists of &gt;, &lt;, &gt;=, &lt;=, ==, != criteria</p> <pre><code>comparator:\n  type: int\n  criteria: \"&gt;\" \n  value: \"20\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#oneof-criteria","title":"OneOf criteria:","text":"<p>It is used to compare numeric or string values, whether actual value lies in expected slice. Here expected values consists either of int/float/string values</p> <pre><code>comparator:\n  type: int\n  criteria: \"oneOf\"\n  value: \"[400,404,405]\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#between-criteria","title":"Between criteria:","text":"<p>It is used to compare the numeric(int,float) values, whether actual value lies between the given lower and upper bound range[a,b]</p> <pre><code>comparator:\n  type: int\n  criteria: \"between\"\n  value: \"[1000,5000]\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#equal-and-notequal-criteria","title":"Equal and NotEqual criteria:","text":"<p>It is used to compare the string values, it checks whether actual value is equal/notEqual to the expected value or not</p> <pre><code>comparator:\n  type: string\n  criteria: \"equal\" #equal or notEqual\n  value: \"&lt;string value&gt;\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#contains-criteria","title":"Contains criteria:","text":"<p>It is used to compare the string values, it checks whether expected value is sub string of actual value or not</p> <pre><code>comparator:\n  type: string\n  criteria: \"contains\" \n  value: \"&lt;string value&gt;\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/litmus-probes/#matches-and-notmatches-criteria","title":"Matches and NotMatches criteria:","text":"<p>It is used to compare the string values, it checks whether the actual value matches/notMatches the regex(provided as expected value) or not</p> <pre><code>comparator:\n  type: string\n  criteria: \"matches\" #matches or notMatches\n  value: \"&lt;regex&gt;\"\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/probe-chaining/","title":"Probe Chaining","text":"<p>Probe chaining enables reuse of probe a result (represented by the template function <code>{{ .&lt;probeName&gt;.probeArtifact.Register}})</code> in subsequent \"downstream\" probes defined in the ChaosEngine.  <code>Note</code>: The order of execution of probes in the experiment depends purely on the order in which they are defined in the ChaosEngine.</p> <p>Use the following example to tune this:</p> <pre><code># chaining enables reuse of probe's result (represented by the template function {{ &lt;probeName&gt;.probeArtifact.Register}}) \n#-- in subsequent \"downstream\" probes defined in the ChaosEngine.\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"probe1\"\n        type: \"cmdProbe\"\n        cmdProbe/inputs:\n          command: \"&lt;command&gt;\"\n          comparator:\n            type: \"string\"\n            criteria: \"equals\"\n            value: \"&lt;value-for-criteria-match&gt;\"\n          source: \"inline\"\n        mode: \"SOT\"\n        runProperties:\n          probeTimeout: 5\n          interval: 5\n          retry: 1\n      - name: \"probe2\"\n        type: \"cmdProbe\"\n        cmdProbe/inputs:\n          ## probe1's result being used as one of the args in probe2\n          command: \"&lt;commmand&gt; {{ .probe1.ProbeArtifacts.Register }} &lt;arg2&gt;\"\n          comparator:\n            type: \"string\"\n            criteria: \"equals\"\n            value: \"&lt;value-for-criteria-match&gt;\"\n          source: \"inline\"\n        mode: \"SOT\"\n        runProperties:\n          probeTimeout: 5\n          interval: 5\n          retry: 1\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/promProbe/","title":"Prometheus Probe","text":"<p>The prometheus probe allows users to run Prometheus queries and match the resulting output against specific conditions. The intent behind this probe is to allow users to define metrics-based SLOs in a declarative way and determine the experiment verdict based on its success. The probe runs the query on a Prometheus server defined by the endpoint, and checks whether the output satisfies the specified criteria. It can be executed by setting <code>type</code> as <code>promProbe</code> inside <code>.spec.experiments[].spec.probe</code>.</p> View the prometheus probe schema <p> Field <code>.name</code> Description Flag to hold the name of the probe Type Mandatory Range n/a  (type: string) Notes The <code>.name</code> holds the name of the probe. It can be set based on the usecase </p> <p> Field <code>.type</code> Description Flag to hold the type of the probe Type Mandatory Range <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> Notes The <code>.type</code> supports four type of probes. It can one of the <code>httpProbe</code>, <code>k8sProbe</code>, <code>cmdProbe</code>, <code>promProbe</code> </p> <p> Field <code>.mode</code> Description Flag to hold the mode of the probe Type Mandatory Range <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> Notes The <code>.mode</code> supports five modes of probes. It can one of the <code>SOT</code>, <code>EOT</code>, <code>Edge</code>, <code>Continuous</code>, <code>OnChaos</code> </p> <p> Field <code>.promProbe/inputs.endpoint</code> Description Flag to hold the prometheus endpoints for the promProbe Type Mandatory Range  n/a {type: string} Notes The <code>.promProbe/inputs.endpoint</code> contains the prometheus endpoints </p> <p> Field <code>.promProbe/inputs.query</code> Description Flag to hold the promql query for the promProbe Type Mandatory Range  n/a {type: string} Notes The <code>.promProbe/inputs.query</code> contains the promql query to extract out the desired prometheus metrics via running it on the given prometheus endpoint </p> <p> Field <code>.promProbe/inputs.queryPath</code> Description Flag to hold the path of the promql query for the promProbe Type Optional Range  n/a {type: string} Notes The <code>.promProbe/inputs.queryPath</code> This field is used in case of complex queries that spans multiple lines, the queryPath attribute can be used to provide the path to a file consisting of the same. This file can be made available to the experiment pod via a ConfigMap resource, with the ConfigMap name being defined in the ChaosEngine OR the ChaosExperiment CR. </p> <p> Field <code>.promProbe/inputs.comparator.criteria</code> Description Flag to hold criteria for the comparision Type Mandatory Range  it supports {&gt;=, &lt;=, ==, &gt;, &lt;, !=, oneOf, between} criteria Notes The <code>.promProbe/inputs.comparator.criteria</code> contains criteria of the comparision, which should be fulfill as part of comparision operation. </p> <p> Field <code>.promProbe/inputs.comparator.value</code> Description Flag to hold value for the comparision Type Mandatory Range  n/a {type: string} Notes The <code>.promProbe/inputs.comparator.value</code> contains value of the comparision, which should follow the given criteria as part of comparision operation. </p> <p> Field <code>.runProperties.probeTimeout</code> Description Flag to hold the timeout for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.probeTimeout</code> represents the time limit for the probe to execute the specified check and return the expected data </p> <p> Field <code>.runProperties.retry</code> Description Flag to hold the retry count for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.retry</code> contains the number of times a check is re-run upon failure in the first attempt before declaring the probe status as failed. </p> <p> Field <code>.runProperties.interval</code> Description Flag to hold the interval for the probes Type Mandatory Range n/a {type: integer} Notes The <code>.runProperties.interval</code> contains the interval for which probes waits between subsequent retries </p> <p> Field <code>.runProperties.probePollingInterval</code> Description Flag to hold the polling interval for the probes(applicable for <code>Continuous</code> mode only) Type Optional Range n/a {type: integer} Notes The <code>.runProperties.probePollingInterval</code> contains the time interval for which continuous probe should be sleep after each iteration </p> <p> Field <code>.runProperties.initialDelaySeconds</code> Description Flag to hold the initial delay interval for the probes Type Optional Range n/a {type: integer} Notes The <code>.runProperties.initialDelaySeconds</code> represents the initial waiting time interval for the probes. </p> <p> Field <code>.runProperties.stopOnFailure</code> Description  Flags to hold the stop or continue the experiment on probe failure Type Optional Range false {type: boolean} Notes The <code>.runProperties.stopOnFailure</code> can be set to true/false to stop or continue the experiment execution after probe fails </p>"},{"location":"experiments/concepts/chaos-resources/probes/promProbe/#common-probe-tunables","title":"Common Probe Tunables","text":"<p>Refer the common attributes to tune the common tunables for all the probes.</p>"},{"location":"experiments/concepts/chaos-resources/probes/promProbe/#prometheus-queryquery-is-a-simple","title":"Prometheus Query(query is a simple)","text":"<p>It contains the promql query to extract out the desired prometheus metrics via running it on the given prometheus endpoint. The prometheus query can be provided in the <code>query</code> field. It can be executed by setting <code>.promProbe/inputs.query</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the prom probe which execute the query and match for the expected criteria\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-probe-success\"\n        type: \"promProbe\"\n        promProbe/inputs:\n          # endpoint for the promethus service\n          endpoint: \"&lt;prometheus-endpoint&gt;\"\n          # promql query, which should be executed\n          query: \"&lt;promql-query&gt;\"\n          comparator:\n            # criteria which should be followed by the actual output and the expected output\n            #supports &gt;=,&lt;=,&gt;,&lt;,==,!= comparision\n            criteria: \"==\" \n            # expected value, which should follow the specified criteria\n            value: \"&lt;value-for-criteria-match&gt;\"\n        mode: \"Edge\"\n        runProperties:\n          probeTimeout: 5\n          interval: 5\n          retry: 1\n</code></pre>"},{"location":"experiments/concepts/chaos-resources/probes/promProbe/#prometheus-queryquery-is-a-complex","title":"Prometheus Query(query is a complex","text":"<p>In case of complex queries that spans multiple lines, the <code>queryPath</code> attribute can be used to provide the path to a file consisting of the same. This file can be made available to the experiment pod via a ConfigMap resource, with the ConfigMap name being defined in the ChaosEngine OR the ChaosExperiment CR. It can be executed by setting <code>promProbe/inputs.queryPath</code> field.</p> <p><code>NOTE</code>: It is mutually exclusive with the <code>query</code> field. If <code>query</code> is set then it will use the query field otherwise, it will use the <code>queryPath</code> field.</p> <p>Use the following example to tune this:</p> <pre><code># contains the prom probe which execute the query and match for the expected criteria\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  engineState: \"active\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: pod-delete-sa\n  experiments:\n  - name: pod-delete\n    spec:\n      probe:\n      - name: \"check-probe-success\"\n        type: \"promProbe\"\n        promProbe/inputs:\n          # endpoint for the promethus service\n          endpoint: \"&lt;prometheus-endpoint&gt;\"\n          # the configMap should be mounted to the experiment which contains promql query\n          # use the mounted path here\n          queryPath: \"&lt;path of the query&gt;\"\n          comparator:\n            # criteria which should be followed by the actual output and the expected output\n            #supports &gt;=,&lt;=,&gt;,&lt;,==,!= comparision\n            criteria: \"==\" \n            # expected value, which should follow the specified criteria\n            value: \"&lt;value-for-criteria-match&gt;\"\n        mode: \"Edge\"\n        runProperties:\n          probeTimeout: 5\n          interval: 5\n          retry: 1\n</code></pre>"},{"location":"experiments/concepts/security/kyverno-policies/","title":"Kyverno Policies","text":"<p>Kyverno policies blocks configurations that don't match a policy (enforce mode) or can generate policy violations (audit mode). It scans existing configurations and reports violations in the cluster.  Litmus recommends using the provided policy configuration to enable the execution of all supported (out-of-the-box) experiments listed in the chaoshub. Having said that, this is recommendatory in nature and left to user discretion/choice depending upon experiments desired.  </p> <p>The details listed here are expected to aid users of Kyverno. If you are using alternate means to enforce runtime security, such as native Kubernetes PSPs (pod security policies), refer this section: refer</p>"},{"location":"experiments/concepts/security/kyverno-policies/#policies-in-litmus","title":"Policies in Litmus","text":"<p>Litmus recommends using the following policies:</p> <ol> <li>Add Capabilities: It restricts add capabilities except the <code>NET_ADMIN</code> and <code>SYS_ADMIN</code> for the pods that use runtime API</li> <li>Host Namespaces: It validates following host namespaces for the pods that use runtime API.<ol> <li>HostPID: It allows hostPID. It should be set to <code>true</code>.</li> <li>HostIPC: It restricts the host IPC. It should be set to <code>false</code>.</li> <li>HostNetwork: It restricts the hostNetwork. It should be set to <code>false</code>.</li> </ol> </li> <li>Host Paths: It restricts hostPath except the <code>socket-path</code> &amp; <code>container-path</code> host paths for the pods that uses runtime API. It allows hostPaths for service-kill experiments.</li> <li>Privilege Escalation: It restricts privilege escalation except for the pods that use runtime API</li> <li>Privilege Container: It restricts privileged containers except for the pods that use runtime API</li> <li>User Groups: It allows users groups for all the experiment pods</li> </ol>"},{"location":"experiments/concepts/security/kyverno-policies/#install-policies","title":"Install Policies","text":"<p>These Kyverno policies are based on the Kubernetes Pod Security Standards definitons. To apply all pod security policies (recommended) install Kyverno and kustomize, then run:</p> <pre><code>kustomize build https://github.com/litmuschaos/chaos-charts/security/kyverno-policies | kubectl apply -f -\n</code></pre>"},{"location":"experiments/concepts/security/kyverno-policies/#pod-security-policies-in-restricted-setup","title":"Pod Security Policies in restricted setup","text":"<p>If setup contains restricted policies which don't allow execution of litmus experiments by default. For Example deny-privilege-escalation policy doesn't allow privileged escalation. It deny all the pods to use privileged escalation.</p> <p>To allow litmus pods to use the privileged escalation. Add the litmus serviceAcccount or ClusterRole/Role inside the exclude block as :</p> <pre><code>apiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: deny-privilege-escalation\n  annotations:\n    policies.kyverno.io/category: Pod Security Standards (Restricted)\n    policies.kyverno.io/severity: medium\n    policies.kyverno.io/subject: Pod\n    policies.kyverno.io/description: &gt;-\n      Privilege escalation, such as via set-user-ID or set-group-ID file mode, should not be allowed.\n      This policy ensures the `allowPrivilegeEscalation` fields are either undefined\n      or set to `false`.      \nspec:\n  background: true\n  validationFailureAction: enforce\n  rules:\n  - name: deny-privilege-escalation\n    match:\n      resources:\n        kinds:\n        - Pod\n    exclude:\n      clusterRoles:\n      # add litmus cluster roles here\n      - litmus-admin\n      roles:\n      # add litmus roles here\n      - litmus-roles\n      subjects:\n      # add serviceAccount name here\n      - kind: ServiceAccount\n        name: pod-network-loss-sa\n    validate:\n      message: &gt;-\n        Privilege escalation is disallowed. The fields\n        spec.containers[*].securityContext.allowPrivilegeEscalation, and\n        spec.initContainers[*].securityContext.allowPrivilegeEscalation must\n        be undefined or set to `false`.        \n      pattern:\n        spec:\n          =(initContainers):\n          - =(securityContext):\n              =(allowPrivilegeEscalation): \"false\"\n          containers:\n          - =(securityContext):\n              =(allowPrivilegeEscalation): \"false\"\n</code></pre>"},{"location":"experiments/concepts/security/openshift-scc/","title":"OpenShift Security Context Constraint (SCC)","text":"<p>Security context constraints allow administrators to control permissions for pods in a cluster. A service account provides an identity for processes that run in a Pod. The service account within a project which applications would usually be run as is the <code>default</code> service account. You may run other applications in the same project, and don't necessarily want to override the privileges used for all applications, create a new service account which can be granted the special rights. In the project where the application is to run. For example run install litmus-admin service account.</p> <pre><code>$ oc apply -f https://litmuschaos.github.io/litmus/litmus-admin-rbac.yaml\n\nserviceaccount/litmus-admin created\nclusterrole.rbac.authorization.k8s.io/litmus-admin created\nclusterrolebinding.rbac.authorization.k8s.io/litmus-admin created\n</code></pre> <p>The next step is that which must be run as a cluster administrator. It is the granting of the appropriate rights to the service account. This is done by specifying that the service account should run with a specific security context constraint (SCC).</p> <p>As an administrator, you can see the list of SCCs that are defined in the cluster by running the oc get scc command.</p> <pre><code>$ oc get scc --as system:admin\n\nNAME               PRIV      CAPS      SELINUX     RUNASUSER          FSGROUP     SUPGROUP    PRIORITY   READONLYROOTFS   VOLUMES\nanyuid             false     []        MustRunAs   RunAsAny           RunAsAny    RunAsAny    10         false            [configMap downwardAPI emptyDir persistentVolumeClaim projected secret]\nhostaccess         false     []        MustRunAs   MustRunAsRange     MustRunAs   RunAsAny    &lt;none&gt;     false            [configMap downwardAPI emptyDir hostPath persistentVolumeClaim projected secret]\nhostmount-anyuid   false     []        MustRunAs   RunAsAny           RunAsAny    RunAsAny    &lt;none&gt;     false            [configMap downwardAPI emptyDir hostPath nfs persistentVolumeClaim projected secret]\nhostnetwork        false     []        MustRunAs   MustRunAsRange     MustRunAs   MustRunAs   &lt;none&gt;     false            [configMap downwardAPI emptyDir persistentVolumeClaim projected secret]\nnonroot            false     []        MustRunAs   MustRunAsNonRoot   RunAsAny    RunAsAny    &lt;none&gt;     false            [configMap downwardAPI emptyDir persistentVolumeClaim projected secret]\nprivileged         true      [*]       RunAsAny    RunAsAny           RunAsAny    RunAsAny    &lt;none&gt;     false            [*]\nrestricted         false     []        MustRunAs   MustRunAsRange     MustRunAs   RunAsAny    &lt;none&gt;     false            [configMap downwardAPI emptyDir persistentVolumeClaim projected secret]\n</code></pre> <p>By default applications would run under the <code>restricted</code> SCC. We can use make use of the default SCC or can create our own SCC to provide the litmus experiment service account (here litmus-admin) to run all the experiments. Here is one such SCC that can be used:</p> <p>litmus-scc.yaml <pre><code>apiVersion: security.openshift.io/v1\nkind: SecurityContextConstraints\n# To mount the socket path directory in helper pod\nallowHostDirVolumePlugin: true\nallowHostIPC: false\nallowHostNetwork: false\n# To run fault injection on a target container using pid namespace.\n# It is used in stress, network, dns and http experiments. \nallowHostPID: true\nallowHostPorts: false\nallowPrivilegeEscalation: true\n# To run some privileged modules in dns, stress and network chaos\nallowPrivilegedContainer: true\n# NET_ADMIN &amp; SYS_ADMIN: used in network chaos experiments to perform\n# network operations (running tc command in network ns of target container). \n# SYS_ADMIN: used in stress chaos experiment to perform cgroup operations.\nallowedCapabilities:\n- 'NET_ADMIN'\n- 'SYS_ADMIN'\ndefaultAddCapabilities: null\nfsGroup:\n  type: MustRunAs\ngroups: []\nmetadata:\n  name: litmus-scc\npriority: null\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities: null\nrunAsUser:\n  type: RunAsAny\nseLinuxContext:\n  type: MustRunAs\nsupplementalGroups:\n  type: RunAsAny\nusers:\n- system:serviceaccount:litmus:argo\nvolumes:\n# To allow configmaps mounts on upload scripts or envs.\n- configMap\n# To derive the experiment pod name in the experimemnt.\n- downwardAPI\n# used for chaos injection like io chaos.\n- emptyDir\n- hostPath\n- persistentVolumeClaim\n- projected\n# To authenticate with different cloud providers\n- secret\n</code></pre></p> <p>Install the SCC</p> <pre><code>$ oc create -f litmus-scc.yaml\nsecuritycontextconstraints.security.openshift.io/litmus-scc created\n</code></pre> <p>Now to associate the new service account with the SCC, run the given command</p> <pre><code>$ oc adm policy add-scc-to-user litmus-scc -z litmus-admin --as system:admin -n litmus\nclusterrole.rbac.authorization.k8s.io/system:openshift:scc:litmus-scc added: \"litmus-admin\"\n</code></pre> <p>The <code>-z</code> option indicates to apply the command to the service account in the current project. To <code>add-scc-to-user</code> add the name of SCC. Provide the namespace of the target service account after <code>-n</code>.</p>"},{"location":"experiments/concepts/security/psp/","title":"Using Pod Security Policies with Litmus","text":"<p>While working in environments (clusters) that have restrictive security policies, the default litmuschaos experiment execution procedure may be inhibited.  This is mainly due to the fact that the experiment pods running the chaos injection tasks in privileged mode. This, in turn, is necessitated due to the mounting  of container runtime-specific socket files from the Kubernetes nodes in order to invoke runtime APIs. While this is not needed for all experiments (a considerable  number of them use purely the K8s API), those involving injection of chaos processes into the network/process namespaces of other containers have this requirement  (ex: netem, stress).</p> <p>The restrictive policies are often enforced via pod security policies (PSP) today, with organizations opting for the default \"restricted\" policy. </p>"},{"location":"experiments/concepts/security/psp/#applying-pod-security-policies-to-litmus-chaos-pods","title":"Applying Pod Security Policies to Litmus Chaos Pods","text":"<ul> <li> <p>To run the litmus pods with operating characteristics described above, first create a custom PodSecurityPolicy that allows the same: </p> <pre><code>apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\nname: litmus\nannotations:\n    seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'\nspec:\nprivileged: true\n# Required to prevent escalations to root.\nallowPrivilegeEscalation: true\n# Allow core volume types.\nvolumes:\n    # To mount script files/templates like ssm-docs in experiment\n    - 'configMap'\n    # Used for chaos injection like io chaos\n    - 'emptyDir'\n    - 'projected'\n    # To authenticate with different cloud providers\n    - 'secret'\n    # To derive the experiment pod name in the experimemnt\n    - 'downwardAPI'\n    # Assume that persistentVolumes set up by the cluster admin are safe to use.\n    - 'persistentVolumeClaim'\n    # To mount the socket path directory used to perform container runtime operations\n    - 'hostPath'\n\nallowedHostPaths:\n    # substitutes this path with an appropriate socket path\n    # ex: '/run/containerd/containerd.sock', '/run/containerd/containerd.sock', '/run/crio/crio.sock'\n    - pathPrefix: \"/run/containerd/containerd.sock\"\n    # substitutes this path with an appropriate container path\n    # ex: '/var/lib/docker/containers', '/var/lib/containerd/io.containerd.runtime.v1.linux/k8s.io', '/var/lib/containers/storage/overlay/'\n    - pathPrefix: \"/var/lib/containerd/io.containerd.runtime.v1.linux/k8s.io\"\n\nallowedCapabilities:\n    # NET_ADMIN &amp; SYS_ADMIN: used in network chaos experiments to perform\n    # network operations (running tc command in network ns of target container). \n    - \"NET_ADMIN\"\n    # SYS_ADMIN: used in stress chaos experiment to perform cgroup operations.\n    - \"SYS_ADMIN\"\nhostNetwork: false\nhostIPC: false\n    # To run fault injection on a target container using pid namespace.\n    # It is used in stress, network, dns and http experiments. \nhostPID: true\nseLinux:\n    # This policy assumes the nodes are using AppArmor rather than SELinux.\n    rule: 'RunAsAny'\nsupplementalGroups:\n    rule: 'MustRunAs'\n    ranges:\n    # Forbid adding the root group.\n    - min: 1\n      max: 65535\nfsGroup:\n    rule: 'MustRunAs'\n    ranges:\n    # Forbid adding the root group.\n    - min: 1\n      max: 65535\nreadOnlyRootFilesystem: false\n</code></pre> <p>Note: This PodSecurityPolicy is a sample configuration which works for a majority of the usecases. It is left to the user's discretion to modify it based  on the environment. For example, if the experiment doesn't need the socket file to be mounted, <code>allowedHostPaths</code> can be excluded from the psp spec. On the other hand, in case of CRI-O runtime, network-chaos tests need the chaos pods executed in privileged mode. It is also possible that different PSP configs are used in different namespaces based on ChaosExperiments installed/executed in them. </p> </li> <li> <p>Subscribe to the created PSP in the experiment RBAC (or in the admin-mode rbac, as applicable).   For example, the pod-delete experiment rbac instrumented with the PSP is shown below:</p> <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: pod-delete-sa\nnamespace: default\nlabels:\n    name: pod-delete-sa\n    app.kubernetes.io/part-of: litmus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: pod-delete-sa\nnamespace: default\nlabels:\n    name: pod-delete-sa\n    app.kubernetes.io/part-of: litmus\nrules:\n- apiGroups: [\"\"]\nresources: [\"pods\",\"events\"]\nverbs: [\"create\",\"list\",\"get\",\"patch\",\"update\",\"delete\",\"deletecollection\"]\n- apiGroups: [\"\"]\nresources: [\"pods/exec\",\"pods/log\",\"replicationcontrollers\"]\nverbs: [\"create\",\"list\",\"get\"]\n- apiGroups: [\"batch\"]\nresources: [\"jobs\"]\nverbs: [\"create\",\"list\",\"get\",\"delete\",\"deletecollection\"]\n- apiGroups: [\"apps\"]\nresources: [\"deployments\",\"statefulsets\",\"daemonsets\",\"replicasets\"]\nverbs: [\"list\",\"get\"]\n- apiGroups: [\"apps.openshift.io\"]\nresources: [\"deploymentconfigs\"]\nverbs: [\"list\",\"get\"]\n- apiGroups: [\"argoproj.io\"]\nresources: [\"rollouts\"]\nverbs: [\"list\",\"get\"]\n- apiGroups: [\"litmuschaos.io\"]\nresources: [\"chaosengines\",\"chaosexperiments\",\"chaosresults\"]\nverbs: [\"create\",\"list\",\"get\",\"patch\",\"update\"]\n- apiGroups: [\"policy\"]\nresources: [\"podsecuritypolicies\"]\nverbs: [\"use\"]\nresourceNames: [\"litmus\"] \n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: pod-delete-sa\nnamespace: default\nlabels:\n    name: pod-delete-sa\n    app.kubernetes.io/part-of: litmus\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: pod-delete-sa\nsubjects:\n- kind: ServiceAccount\nname: pod-delete-sa\nnamespace: default\n</code></pre> </li> <li> <p>Execute the ChaosEngine and verify that the litmus experiment pods are created successfully.  </p> </li> </ul>"},{"location":"experiments/faq/ci-cd/","title":"CI/CD","text":""},{"location":"experiments/faq/ci-cd/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>Is there any use case to integrate Litmus into CI? Which experiment have you integrated as part of the CI? And what would you do if a microservice fails an experiment in the CI?</p> </li> <li> <p>Is there any way to use Litmus within GitHub? When someone submits a k8s deployment for a PR , We want to run a chaos Experiment on that to see whether it passes or not</p> </li> <li> <p>How can users integrate Litmuschaos in their environment with Gitops?</p> </li> <li> <p>How can we use Litmus in our DevOps pipeline/cycle?</p> </li> </ol>"},{"location":"experiments/faq/ci-cd/#is-there-any-use-case-to-integrate-litmus-into-ci-which-experiment-have-you-integrated-as-part-of-the-ci-and-what-would-you-do-if-a-microservice-fails-an-experiment-in-the-ci","title":"Is there any use case to integrate Litmus into CI? Which experiment have you integrated as part of the CI? And what would you do if a microservice fails an experiment in the CI?","text":"<p>We have integrated Litmus with a couple of CI tools, the major ones are:</p> <ul> <li>GitHub Actions using <code>litmuschaos</code> actions</li> <li>GitLab using remote templates</li> <li>Keptn</li> <li>Spinnaker templates</li> </ul> <p>By this, we induce chaos as part of the CI stage as Continuous Chaos allows us to automatically identify application failures over the development phase.</p> <p>Failure of an exp in CI should invariably fail the pipeline. The pass would be more subjective. Depends on what is the nature of the CI pipeline - what it is the tests being carried is like etc., If you are doing a simple pod-delete or cpu-hog on a microservice pod w/o traffic OR w/o running it in an env that doesn't need it to interact w/ other services then the insights are limited.</p>"},{"location":"experiments/faq/ci-cd/#is-there-any-way-to-use-litmus-within-github-when-someone-submits-a-k8s-deployment-for-a-pr-we-want-to-run-a-chaos-experiment-on-that-to-see-whether-it-passes-or-not","title":"Is there any way to use Litmus within GitHub? When someone submits a k8s deployment for a PR , We want to run a chaos Experiment on that to see whether it passes or not.","text":"<p>Yes, with the help of GitHub-chaos-action we can automate the chaos execution on an application in the same place where the code is stored. We can write individual tasks along with chaos actions and combine them to create a custom GitHub workflow. GitHub Workflows are custom automated processes that we can set up in our repository to build, test, package, or deploy any code project on GitHub. Including the GitHub chaos actions in our workflow YAML, We can test the performance/resiliency of our application in a much simpler and better way. To know more visit our Github chaos action repository.</p>"},{"location":"experiments/faq/ci-cd/#how-can-users-integrate-litmuschaos-in-their-environment-with-gitops","title":"How can users integrate Litmuschaos in their environment with Gitops?","text":"<p>GitOps feature in Litmus enables users to sync workflows from a configured git repo, any workflow inserts/updates made to the repo will be monitored and picked up by the Litmus portal and will be executed on the target cluster. Litmus portal GitOps also includes an event-driven chaos injection feature where users can annotate an application to be watched for changes and if and when the change happens chaos workflows can be triggered automatically. This integrates with other GitOps tools like Flux/Argo CD and enables users to automatically run chaos workflows whenever a new release happens or a particular change occurs in the application. To configure a git repo the user must provide the Git URL of the repository and the branch name and the authentication credentials which are of two types:</p> <ol> <li>Access Token</li> <li>SSH Key</li> </ol> <p>Once GitOps is enabled, any new workflows created will be stored in the configured repo in the path <code>litmus/&lt;project-id&gt;/&lt;workflow-name&gt;.yaml</code></p>"},{"location":"experiments/faq/ci-cd/#how-can-we-use-litmus-in-our-devops-pipelinecycle","title":"How can we use Litmus in our DevOps pipeline/cycle?","text":"<p>You can add Litmus to the CI/CD pipelines as part of an end-to-end testing approach due to its minimal pre-requisites and simple result mechanisms. It also provides utilities for quick setup of Kubernetes clusters on different platforms as well as installation of storage provider control plane components (operators). Openebs.ci is a reference implementation of how Litmus can be used in the DevOps pipeline.</p>"},{"location":"experiments/faq/content/","title":"Litmus FAQ","text":""},{"location":"experiments/faq/content/#faq","title":"FAQ","text":"Category Description References Install Questions related to litmus installation Install Experiments Questions related to litmus experiments Experiments Portal Questions related to litmus portal Portal Scheduler Questions related to litmus scheduler Scheduler Security Questions related to litmus security Security CI/CD Questions related to litmus CI/CD integration CI/CD"},{"location":"experiments/faq/content/#troubleshooting","title":"Troubleshooting","text":"Category Description References Install Troubleshooting related to litmus installation Install Experiments Troubleshooting related to litmus experiments Experiments Portal Troubleshooting related to litmus portal Portal Scheduler Troubleshooting related to litmus scheduler Scheduler"},{"location":"experiments/faq/experiments/","title":"Litmus Experiments","text":""},{"location":"experiments/faq/experiments/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>Node memory hog experiment's pod OOM Killed even before the kubelet sees the memory stress?</p> </li> <li> <p>Pod-network-corruption and pod-network-loss both experiments force network packet loss - is it worthwhile trying out both experiments in a scheduled chaos test?</p> </li> <li> <p>How is the packet loss achieved in pod-network loss and corruption experiments? What are the internals of it?</p> </li> <li> <p>What's the difference between pod-memory/cpu-hog vs pod-memory/cpu-hog-exec?</p> </li> <li> <p>What are the typical probes used for pod-network related experiments?</p> </li> <li> <p>Litmus provides multiple libs to run some chaos experiments like stress-chaos and network chaos so which library should be preferred to use?</p> </li> <li> <p>How to run chaos experiment programatically using apis?</p> </li> <li> <p>Kubernetes by default has built-in features like replicaset/deployment to prevent service unavailability (continuous curl from the httpProbe on litmus should not fail) in case of container kill, pod delete and OOM due to pod-memory-hog then why do we need CPU, IO and network related chaos experiments?</p> </li> <li> <p>The experiment is not targeting all pods with the given label, it just selects only one pod by default</p> </li> <li> <p>Do we have a way to see what pods are targeted when users use percentages?</p> </li> <li> <p>What is the function of spec.definition.scope of a ChaosExperiment CR?</p> </li> <li> <p>Pod network latency -- I have pod A talking to Pod B over Service B. and I want to introduce latency between Pod A and Service B. What would go into spec.appInfo section? Pod A namespace, label selector and kind? What will go into DESTINATION_IP and DESTINATION_HOST? Service B details? What are the TARGET_PODS?</p> </li> <li> <p>How to check the NETWORK_INTERFACE and SOCKET_PATH variable?</p> </li> <li> <p>What are the different ways to target the pods and nodes for chaos?</p> </li> <li> <p>Does the pod affected perc select the random set of pods from the total pods under chaos?</p> </li> <li> <p>How to extract the chaos start time and end time?</p> </li> <li> <p>How do we check the MTTR (Mean time to recovery) for an application post chaos?</p> </li> <li> <p>What is the difference between Ramp Time and Chaos Interval?</p> </li> <li> <p>Can the appkind be a pod?</p> </li> <li> <p>What type of chaos experiments are supported by Litmus?</p> </li> <li> <p>What are the permissions required to run Litmus Chaos Experiments?</p> </li> <li> <p>What is the scope of a Litmus Chaos Experiment?</p> </li> <li> <p>To get started with running chaos experiments using Litmus?</p> </li> <li> <p>How to view and interpret the results of a chaos experiment?</p> </li> <li> <p>Do chaos experiments run as a standard set of pods?</p> </li> <li> <p>Is it mandatory to annotate application deployments for chaos?</p> </li> <li> <p>How to add Custom Annotations as chaos filters?</p> </li> <li> <p>Is it mandatory for the chaosengine and chaos experiment resources to exist in the same namespace?</p> </li> <li> <p>How to get the chaos logs in Litmus?</p> </li> <li> <p>Does Litmus support generation of events during chaos?</p> </li> <li> <p>How to stop or abort a chaos experiment?</p> </li> <li> <p>Can a chaos experiment be resumed once stopped or aborted?</p> </li> <li> <p>How to restart chaosengine after graceful completion?</p> </li> <li> <p>Does Litmus support any chaos metrics for experiments?</p> </li> <li> <p>Does Litmus track any usage metrics on the test clusters?</p> </li> <li> <p>What to choose between minChaosInterval and instanceCount?</p> </li> </ol>"},{"location":"experiments/faq/experiments/#node-memory-hog-experiments-pod-oom-killed-even-before-the-kubelet-sees-the-memory-stress","title":"Node memory hog experiment's pod OOM Killed even before the kubelet sees the memory stress?","text":"<p>The experiment takes a percentage of the total memory capacity of the Node. The helper pod runs on the target node to stress the resources of that node. So The experiment will not consume/hog the memory resources greater than the total memory available on Node. In other words there will always be an upper limit for the amount of memory to be consumed, which equal to the total available memory. Please refer to this blog for more details.</p>"},{"location":"experiments/faq/experiments/#pod-network-corruption-and-pod-network-loss-both-experiments-force-network-packet-loss-is-it-worthwhile-trying-out-both-experiments-in-a-scheduled-chaos-test","title":"Pod-network-corruption and pod-network-loss both experiments force network packet loss - is it worthwhile trying out both experiments in a scheduled chaos test?","text":"<p>Yes, ultimately these are different ways to simulate a degraded network. Both cases are expected to typically cause retransmissions (for tcp). The extent of degradation depends on the percentage of loss/corruption</p>"},{"location":"experiments/faq/experiments/#how-is-the-packet-loss-achieved-in-pod-network-loss-and-corruption-experiments-what-are-the-internals-of-it","title":"How is the packet loss achieved in pod-network loss and corruption experiments? What are the internals of it?","text":"<p>The experiment causes network degradation without the pod being marked unhealthy/unworthy of traffic by kube-proxy (unless you have a liveness probe of sorts that measures latency and restarts/crashes the container) The idea of this exp is to simulate issues within your pod-network OR microservice communication across services in different availability zones/regions etc.., Mitigation (in this case keep the timeout i.e., access latency low) could be via some middleware that can switch traffic based on some SLOs/perf parameters. If such an arrangement is not available - the next best thing would be to verify if such a degradation is highlighted via notification/alerts etc,. so the admin/SRE has the opportunity to investigate and fix things. Another utility of the test would be to see what the extent of impact caused to the end-user OR the last point in the app stack on account of degradation in access to a downstream/dependent microservice. Whether it is acceptable OR breaks the system to an unacceptable degree.</p> <p>The args passed to the tc netem command run against the target container changes depending on the type of n/w fault</p>"},{"location":"experiments/faq/experiments/#whats-the-difference-between-pod-memorycpu-hog-vs-pod-memorycpu-hog-exec","title":"What's the difference between pod-memory/cpu-hog vs pod-memory/cpu-hog-exec?","text":"<p>The pod cpu and memory chaos experiment till now (version 1.13.7) was using an exec mode of execution which means - we were execing inside the specified target container and launching process like <code>md5sum</code> and <code>dd</code> to consume the cpu and memory respectively. This is done by providing <code>CHAOS_INJECT_COMMAND</code> and <code>CHAOS-KILL-COMMAND</code> in chaosengine CR. But we have some limitations of using this method. Those were:</p> <ul> <li>The chaos inject and kill command are highly dependent on the base image of the target container and may work for some and for others you may have to derive it manually and use it.</li> <li>For scratch images that don't expose shells we couldn't execute the chaos.</li> </ul> <p>To overcome this - The stress-chaos experiments (cpu, memory and io) are enhanced to use a non exec mode of chaos execution. It makes use of target container cgroup for the resource allocation and container pid namespace for showing the stress-ng process in target container. This <code>stress-ng</code> process will consume the resources on the target container without doing an exec. The new enhanced experiments are available from litmus 1.13.8 version.</p>"},{"location":"experiments/faq/experiments/#what-are-the-typical-probes-used-for-pod-network-related-experiments","title":"What are the typical probes used for pod-network related experiments?","text":"<p>Precisely the role of the experiment. Cause n/w degradation w/o the pod being marked unhealthy/unworthy of traffic by kube-proxy (unless you have a liveness probe of sorts that measures latency and restarts/crashes the container) The idea of this exp is to simulate issues within your pod-network OR microservice communication across services in diff availability zones/regions etc..,</p> <p>Mitigation (in this case keep the timeout i.e., access latency low) could be via some middleware that can switch traffic based on some SLOs/perf parameters. If such an arrangement is not available - the next best thing would be to verify if such a degradation is highlighted via notification/alerts etc,. so the admin/SRE has the opportunity to investigate and fix things.</p> <p>Another utility of the test would be to see what the extent of impact caused to the end-user OR the last point in the app stack on account of degradation in access to a downstream/dependent microservice. Whether it is acceptable OR breaks the system to an unacceptable degree</p>"},{"location":"experiments/faq/experiments/#litmus-provides-multiple-libs-to-run-some-chaos-experiments-like-stress-chaos-and-network-chaos-so-which-library-should-be-preferred-to-use","title":"Litmus provides multiple libs to run some chaos experiments like stress-chaos and network chaos so which library should be preferred to use?","text":"<p>The optional libs (like Pumba) is more of an illustration of how you can use 3<sup>rd</sup> party tools with litmus. Called the BYOC (Bring Your Own Chaos). The preferred LIB is <code>litmus</code>.</p>"},{"location":"experiments/faq/experiments/#how-to-run-chaos-experiment-programatically-using-apis","title":"How to run chaos experiment programatically using apis?","text":"<p>To directly consume/manipulate the chaos resources (i.e., chaosexperiment, chaosengine or chaosresults) via API - you can directly use the kube API. The CRDs by default provide us with an API endpoint. You can use any generic client implementation (go/python are most used ones) to access them. In case you use go, there is a clientset available as well: go-client</p> <p>Here are some simple CRUD ops against chaosresources you could construct with curl (I have used kubectl proxy, one could use an auth token instead)- just for illustration purposes.</p>"},{"location":"experiments/faq/experiments/#create-chaosengine","title":"Create ChaosEngine:","text":"<p>For example, assume this is the engine spec</p> <pre><code>curl -s http://localhost:8001/apis/litmuschaos.io/v1alpha1/namespaces/default/chaosengines -XPOST -H 'Content-Type: application/json' -d@pod-delete-chaosengine-trigger.json\n</code></pre>"},{"location":"experiments/faq/experiments/#read-chaosengine-status","title":"Read ChaosEngine status:","text":"<pre><code>curl -s http://localhost:8001/apis/litmuschaos.io/v1alpha1/namespaces/default/chaosengines/nginx-chaos | jq '.status.engineStatus, .status.experiments[].verdict'\n</code></pre>"},{"location":"experiments/faq/experiments/#update-chaosengine-spec","title":"Update ChaosEngine Spec:","text":"<p>(say, this is the patch: https://gist.github.com/ksatchit/be54955a1f4231314797f25361ac488d)</p> <pre><code>curl --header \"Content-Type: application/json-patch+json\" --request PATCH --data '[{\"op\": \"replace\", \"path\": \"/spec/engineState\", \"value\": \"stop\"}]' http://localhost:8001/apis/litmuschaos.io/v1alpha1/namespaces/default/chaosengines/nginx-chaos\n</code></pre>"},{"location":"experiments/faq/experiments/#delete-the-chaosengine-resource","title":"Delete the ChaosEngine resource:","text":"<pre><code>curl -X DELETE localhost:8001/apis/litmuschaos.io/v1alpha1/namespaces/default/chaosengines/nginx-chaos \\\n-d '{\"kind\":\"DeleteOptions\",\"apiVersion\":\"v1\",\"propagationPolicy\":\"Foreground\"}' \\\n-H \"Content-Type: application/json\"\n</code></pre>"},{"location":"experiments/faq/experiments/#similarly-to-check-the-resultsverdict-of-the-experiment-from-chaosresult-you-could-use","title":"Similarly, to check the results/verdict of the experiment from ChaosResult, you could use:","text":"<pre><code>curl -s http://localhost:8001/apis/litmuschaos.io/v1alpha1/namespaces/default/chaosresults/nginx-chaos-pod-delete | jq '.status.experimentStatus.verdict, .status.experimentStatus.probeSuccessPercentage'\n</code></pre>"},{"location":"experiments/faq/experiments/#kubernetes-by-default-has-built-in-features-like-replicasetdeployment-to-prevent-service-unavailability-continuous-curl-from-the-httpprobe-on-litmus-should-not-fail-in-case-of-container-kill-pod-delete-and-oom-due-to-pod-memory-hog-then-why-do-we-need-cpu-io-and-network-related-chaos-experiments","title":"Kubernetes by default has built-in features like replicaset/deployment to prevent service unavailability (continuous curl from the httpProbe on litmus should not fail) in case of container kill, pod delete and OOM due to pod-memory-hog then why do we need CPU, IO and network related chaos experiments?","text":"<p>There are some scenarios that can still occur despite whatever availability aids K8s provides. For example, take disk usage or CPU hogs -- problems you would generally refer to as \"Noisy Neighbour\"  problems. Stressing the disk w/ continuous and heavy I/O for example can cause degradation in reads and  writes performed by other microservices that use this shared disk - for example. (modern storage solutions for Kubernetes use the concept of storage pools out of which virtual volumes/devices are carved out).  Another issue is the amount of scratch space eaten up on a node - leading to lack of space for newer containers to get scheduled (kubernetes too gives up by applying an \"eviction\" taint like \"disk-pressure\") and causes a wholesale movement of all pods to other nodes. Similarly w/ CPU chaos -- by injecting a rogue process into a target container, we starve the main microservice process (typically pid 1) of the resources allocated to it (where limits are defined) causing slowness in app traffic OR in other cases unrestrained use can cause node to exhaust resources leading to eviction of all pods.</p>"},{"location":"experiments/faq/experiments/#the-experiment-is-not-targeting-all-pods-with-the-given-label-it-just-selects-only-one-pod-by-default","title":"The experiment is not targeting all pods with the given label, it just selects only one pod by default.","text":"<p>Yes. You can use either <code>the PODS_AFFECTED_PERCENTAGE</code> or <code>TARGET_PODS</code> env to select multiple pods. Refer: experiment tunable envs.</p>"},{"location":"experiments/faq/experiments/#do-we-have-a-way-to-see-what-pods-are-targeted-when-users-use-percentages","title":"Do we have a way to see what pods are targeted when users use percentages?","text":"<p>We can view the target pods from the experiment logs or inside chaos results.</p>"},{"location":"experiments/faq/experiments/#what-is-the-function-of-specdefinitionscope-of-a-chaosexperiment-cr","title":"What is the function of spec.definition.scope of a ChaosExperiment CR?","text":"<p>The <code>spec.definition.scope</code> &amp; <code>.spec.definition.permissions</code> is mostly for indicative/illustration purposes (for external tools to identify and validate what are the permissions associated to run the exp). By itself, it doesn't influence how and where an exp can be used.One could remove these fields if needed (of course along w/ the crd validation) and store these manifests if desired.</p>"},{"location":"experiments/faq/experiments/#in-pod-network-latency-i-have-pod-a-talking-to-pod-b-over-service-b-and-i-want-to-introduce-latency-between-pod-a-and-service-b-what-would-go-into-specappinfo-section-pod-a-namespace-label-selector-and-kind-what-will-go-into-destination_ip-and-destination_host-service-b-details-what-are-the-target_pods","title":"In Pod network latency - I have pod A talking to Pod B over Service B. and I want to introduce latency between Pod A and Service B. What would go into spec.appInfo section? Pod A namespace, label selector and kind? What will go into DESTINATION_IP and DESTINATION_HOST? Service B details? What are the TARGET_PODS?","text":"<p>It will target the <code>[1:total_replicas]</code>(based on PODS_AFFECTED_PERC) numbers of random pods with matching labels(appinfo.applabel) and namespace(appinfo.appns). But if you want to target a specific pod then you can provide their names as a comma separated list inside <code>TARGET_PODS</code>. Yes, you can provide service B details inside <code>DESTINATION_IPS</code> or <code>DESTINATION_HOSTS</code>. The <code>NETWORK_INTERFACE</code> should be <code>eth0</code>.</p>"},{"location":"experiments/faq/experiments/#how-to-check-the-network_interface-and-socket_path-variable","title":"How to check the NETWORK_INTERFACE and SOCKET_PATH variable?","text":"<p>The <code>NETWORK_INTERFACE</code> is the interface name inside the pod/container that needs to be targeted. You can find it by execing into the target pod and checking the available interfaces. You can try <code>ip link</code>, <code>iwconfig</code> , <code>ifconfig</code> depending on the tools installed in the pod either of those could work.</p> <p>The <code>SOCKET_PATH</code> by default takes the containerd socket path. If you are using something else like docker, crio or have a different socket path by any chance you can specify it. This is required to communicate with the container runtime of your cluster.  In addition to this if container-runtime is different then provide the name of container runtime inside <code>CONTAINER_RUNTIME</code> ENV. It supports <code>docker</code>, <code>containerd</code>, and <code>crio</code> runtimes.    </p>"},{"location":"experiments/faq/experiments/#what-are-the-different-ways-to-target-the-pods-and-nodes-for-chaos","title":"What are the different ways to target the pods and nodes for chaos?","text":"<p>The different ways are: </p> <p>Pod Chaos: </p> <ul> <li><code>Appinfo</code>: Provide the target pod labels in the chaos engine appinfo section.</li> <li><code>TARGET_PODS</code>: You can provide the target pod names as a Comma Separated Variable. Like pod1,pod2.</li> </ul> <p>Node Chaos:</p> <ul> <li><code>TARGET_NODE</code> or <code>TARGET_NODES</code>: Provide the target node or nodes in these envs.</li> <li><code>NODE_LABEL</code>: Provide the label of the target nodes.</li> </ul>"},{"location":"experiments/faq/experiments/#does-the-pod-affected-percentage-select-the-random-set-of-pods-from-the-total-pods-under-chaos","title":"Does the pod affected percentage select the random set of pods from the total pods under chaos?","text":"<p>Yes, it selects the random pods based on the <code>POD_AFFACTED_PERC</code> ENV. In pod-delete experiment it selects random pods for each iterations of chaos. But for rest of the experiments(if it supports iterations) then it will select random pods once and use the same set of pods for remaining iterations.</p>"},{"location":"experiments/faq/experiments/#how-to-extract-the-chaos-start-time-and-end-time","title":"How to extract the chaos start time and end time?","text":"<p>We can use the Chaos exporter metrics for the same. One can also visualise these events along with time in chaos engine events.</p>"},{"location":"experiments/faq/experiments/#how-do-we-check-the-mttr-mean-time-to-recovery-for-an-application-post-chaos","title":"How do we check the MTTR (Mean time to recovery) for an application post chaos?","text":"<p>The MTTR can be validated by using statusCheck Timeout in the chaos engine. By default its value will be 180 seconds. We can also overwrite this using ChaosEngine. For more details refer this</p>"},{"location":"experiments/faq/experiments/#what-is-the-difference-between-ramp-time-and-chaos-interval","title":"What is the difference between Ramp Time and Chaos Interval?","text":"<p>The ramp time is the time duration to wait before and after injection of chaos in seconds. While the chaos interval is the time interval (in second) between successive chaos iterations.</p>"},{"location":"experiments/faq/experiments/#can-the-appkind-be-a-pod","title":"Can the appkind be a pod?","text":"<p>The appkind as pod is not supported explicitly. The supported appkind are <code>deployment</code>, <code>statefulset</code>, <code>replicaset</code>, <code>daemonset</code>, <code>rollout</code>, and <code>deploymentconfig</code>.  But we can target the pods by following ways:</p> <ul> <li>provide labels and namespace at <code>spec.appinfo.applabel</code> and <code>spec.appinfo.appns</code> respectively and provide <code>spec.appinfo.appkind</code> as empty. </li> <li>provide pod names at <code>TARGET_PODS</code> ENV and provide <code>spec.appinfo</code> as nil</li> </ul> <p><code>NOTE</code>: The <code>annotationCheck</code> should be provided as false</p>"},{"location":"experiments/faq/experiments/#what-type-of-chaos-experiments-are-supported-by-litmus","title":"What type of chaos experiments are supported by Litmus?","text":"<p>Litmus broadly defines Kubernetes chaos experiments into two categories: application or pod-level chaos experiments and platform or infra-level chaos experiments. The former includes pod-delete, container-kill, pod-cpu-hog, pod-network-loss etc., while the latter includes node-drain, disk-loss, node-cpu-hog etc., The infra chaos experiments typically have a higher blast radius and impact more than one application deployed on the Kubernetes cluster. Litmus also categorizes experiments on the basis of the applications, with the experiments consisting of app-specific health checks. For a full list of supported chaos experiments, visit: https://hub.litmuschaos.io</p>"},{"location":"experiments/faq/experiments/#what-are-the-permissions-required-to-run-litmus-chaos-experiments","title":"What are the permissions required to run Litmus Chaos Experiments?","text":"<p>By default, the Litmus operator uses the \u201clitmus\u201d serviceaccount that is bound to a ClusterRole, in order to watch for the ChaosEngine resource across namespaces. However, the experiments themselves are associated with \u201cchaosServiceAccounts\u201d which are created by the developers with bare-minimum permissions necessary to execute the experiment in question. Visit the chaos-charts repo to view the experiment-specific rbac permissions. For example, here are the permissions for container-kill chaos.</p>"},{"location":"experiments/faq/experiments/#what-is-the-scope-of-a-litmus-chaos-experiment","title":"What is the scope of a Litmus Chaos Experiment?","text":"<p>The chaos CRs (chaosexperiment, chaosengine, chaosresults) themselves are namespace scoped and are installed in the same namespace as that of the target application. While most of the experiments can be executed with service accounts mapped to namespaced roles, some infra chaos experiments typically perform health checks of applications across namespaces &amp; therefore need their serviceaccounts mapped to ClusterRoles.</p>"},{"location":"experiments/faq/experiments/#to-get-started-with-running-chaos-experiments-using-litmus","title":"To get started with running chaos experiments using Litmus?","text":"<p>Litmus has a low entry barrier and is easy to install/use. Typically, it involves installing the chaos-operator, chaos experiment CRs from the charthub, annotating an application for chaos and creating a chaosengine CR to map your application instance with a desired chaos experiment. Refer to the getting started documentation to learn more on how to run a simple chaos experiment.</p>"},{"location":"experiments/faq/experiments/#how-to-view-and-interpret-the-results-of-a-chaos-experiment","title":"How to view and interpret the results of a chaos experiment?","text":"<p>The results of a chaos experiment can be obtained from the verdict property of the chaosresult custom resource. If the verdict is Pass, it means that the application under test is resilient to the chaos injected. Alternatively, Fail reflects that the application is not resilient enough to the injected chaos, and indicates the need for a relook into the deployment sanity or possible application bugs/issues.</p> <p><pre><code>kubectl describe chaosresult &lt;chaosengine-name&gt;-&lt;chaos-experiment&gt; -n &lt;namespace&gt;\n</code></pre> The status of the experiment can also be gauged by the \u201cstatus\u201d property of the ChaosEngine.</p> <pre><code>Kubectl describe chaosengine &lt;chaosengne-name&gt; -n &lt;namespace&gt;\n</code></pre>"},{"location":"experiments/faq/experiments/#do-chaos-experiments-run-as-a-standard-set-of-pods","title":"Do chaos experiments run as a standard set of pods?","text":"<p>The chaos experiment (triggered after creation of the ChaosEngine resource) workflow consists of launching the \u201cchaos-runner\u201d pod, which is an umbrella executor of different chaos experiments listed in the engine. The chaos-runner creates one pod (job) per each experiment to run the actual experiment business logic, and also manages the lifecycle of these experiment pods (performs functions such as experiment dependencies validation, job cleanup, patching of status back into ChaosEngine etc.,). Optionally, a monitor pod is created to export the chaos metrics. Together, these 3 pods are a standard set created upon execution of the experiment. The experiment job, in turn may spawn dependent (helper) resources if necessary to run the experiments, but this depends on the experiment selected, chaos libraries chosen etc.,</p>"},{"location":"experiments/faq/experiments/#is-it-mandatory-to-annotate-application-deployments-for-chaos","title":"Is it mandatory to annotate application deployments for chaos?","text":"<p>Typically applications are expected to be annotated with litmuschaos.io/chaos=\"true\" to lend themselves to chaos. This is in order to support selection of the right applications with similar labels in a namespaces, thereby isolating the application under test (AUT) &amp; reduce the blast radius. It is also helpful for supporting automated execution (say, via cron) as a background service. However, in cases where the app deployment specifications are sacrosanct and not expected to be modified, or in cases where annotating a single application for chaos when the experiment itself is known to have a higher blast radius doesn\u2019t make sense (ex: infra chaos), the annotationCheck can be disabled via the ChaosEngine tunable annotationCheck (<code>.spec.annotationCheck: false</code>).</p>"},{"location":"experiments/faq/experiments/#how-to-add-custom-annotations-as-chaos-filters","title":"How to add Custom Annotations as chaos filters?","text":"<p>Currently Litmus allows you to set your own/custom keys for Annotation filters, the value being true/false. To use your custom annotation, add this key under an ENV named as CUSTOM_ANNOTATION in ChaosOperator deployment. A sample chaos-operator deployment spec is provided here for reference:</p> view the manifest <pre><code>---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: chaos-operator-ce\nnamespace: litmus\nspec:\nreplicas: 1\nselector:\n    matchLabels:\n    name: chaos-operator\ntemplate:\n    metadata:\n    labels:\n        name: chaos-operator\n    spec:\n    serviceAccountName: litmus\n    containers:\n        - name: chaos-operator\n        # 'latest' tag corresponds to the latest released image\n        image: litmuschaos/chaos-operator:latest\n        command:\n        - chaos-operator\n        imagePullPolicy: Always\n        env:\n            - name: CUSTOM_ANNOTATION\n            value: \"mayadata.io/chaos\"\n            - name: CHAOS_RUNNER_IMAGE\n            value: \"litmuschaos/chaos-runner:latest\"\n            - name: WATCH_NAMESPACE\n            value: \n            - name: POD_NAME\n            valueFrom:\n                fieldRef:\n                fieldPath: metadata.name\n            - name: OPERATOR_NAME\n          value: \"chaos-operator\"\n</code></pre>"},{"location":"experiments/faq/experiments/#is-it-mandatory-for-the-chaosengine-and-chaos-experiment-resources-to-exist-in-the-same-namespace","title":"Is it mandatory for the chaosengine and chaos experiment resources to exist in the same namespace?","text":"<p>Yes. As of today, the chaos resources are expected to co-exist in the same namespace, which typically is also the application's (AUT) namespace.</p>"},{"location":"experiments/faq/experiments/#how-to-get-the-chaos-logs-in-litmus","title":"How to get the chaos logs in Litmus?","text":"<p>The chaos logs can be viewed in the following manner. To view the successful launch/removal of chaos resources upon engine creation, for identification of application under test (AUT) etc., view the chaos-operator logs: <pre><code>kubectl logs -f &lt;chaos-operator-(hash)-(hash)&gt; -n &lt;chaos_namespace&gt;\n</code></pre> To view lifecycle management logs of a given (or set of) chaos experiments, view the chaos-runner logs: <pre><code>kubectl logs -f &lt;chaosengine_name&gt;-runner -n &lt;chaos_namespace&gt;\n</code></pre> To view the chaos logs itself (details of experiment chaos injection, application health checks et al), view the experiment pod logs: <pre><code>kubectl logs -f &lt;experiment_name_(hash)_(hash)&gt; -n &lt;chaos_namespace&gt;\n</code></pre></p>"},{"location":"experiments/faq/experiments/#does-litmus-support-generation-of-events-during-chaos","title":"Does Litmus support generation of events during chaos?","text":"<p>The chaos-operator generates Kubernetes events to signify the creation of removal of chaos resources over the course of a chaos experiment, which can be obtained by running the following command: <pre><code>kubectl describe chaosengine &lt;chaosengine-name&gt; -n &lt;namespace&gt;\n</code></pre> <code>Note:</code> Efforts are underway to add more events around chaos injection in subsequent releases.</p>"},{"location":"experiments/faq/experiments/#how-to-stop-or-abort-a-chaos-experiment","title":"How to stop or abort a chaos experiment?","text":"<p>A chaos experiment can be stopped/aborted inflight by patching the .spec.engineState property of the chaosengine to stop . This will delete all the chaos resources associated with the engine/experiment at once. <pre><code>kubectl patch chaosengine &lt;chaosengine-name&gt; -n &lt;namespace&gt; --type merge --patch '{\"spec\":{\"engineState\":\"stop\"}}'\n</code></pre> The same effect will be caused by deleting the respective chaosengine resource.</p>"},{"location":"experiments/faq/experiments/#can-a-chaos-experiment-be-resumed-once-stopped-or-aborted","title":"Can a chaos experiment be resumed once stopped or aborted?","text":"<p>Once stopped/aborted, patching the chaosengine .spec.engineState with active causes the experiment to be re-executed. Another way is to re-apply the ChaosEngine YAML, this will delete all stale chaos resources, and restart ChaosEngine lifecycle. However, support is yet to be added for saving state and resuming an in-flight experiment (i.e., execute pending iterations etc.,) <pre><code>kubectl patch chaosengine &lt;chaosengine-name&gt; -n &lt;namespace&gt; --type merge --patch '{\"spec\":{\"engineState\":\"active\"}}'\n</code></pre></p>"},{"location":"experiments/faq/experiments/#how-to-restart-chaosengine-after-graceful-completion","title":"How to restart chaosengine after graceful completion?","text":"<p>To restart chaosengine, check the .spec.engineState, which should be equal to stop, which means your chaosengine has gracefully completed, or forcefully aborted. In this case, restart is quite easy, as you can re-apply the chaosengine YAML to restart it. This will remove all stale chaos resources linked to this chaosengine, and restart its own lifecycle.</p>"},{"location":"experiments/faq/experiments/#does-litmus-support-any-chaos-metrics-for-experiments","title":"Does Litmus support any chaos metrics for experiments?","text":"<p>Litmus provides a basic set of prometheus metrics indicating the total count of chaos experiments, passed/failed experiments and individual status of experiments specified in the ChaosEngine, which can be queried against the monitor pod. Work to enhance and improve this is underway.</p>"},{"location":"experiments/faq/experiments/#does-litmus-track-any-usage-metrics-on-the-test-clusters","title":"Does Litmus track any usage metrics on the test clusters?","text":"<p>By default, the installation count of chaos-operator &amp; run count of a given chaos experiment is collected as part of general analytics to gauge user adoption &amp; chaos trends. However, if you wish to inhibit this, please use the following ENV setting on the chaos-operator deployment: <pre><code>env: \n  name: ANALYTICS\n  value: 'FALSE'\n</code></pre></p>"},{"location":"experiments/faq/experiments/#what-to-choose-between-minchaosinterval-and-instancecount","title":"What to choose between minChaosInterval and instanceCount?","text":"<p>Only one should be chosen ideally between minChaosInterval and instanceCount. However if both are specified minChaosInterval will be given priority. minChaosInterval specifies the minimum interval that should be present between the launch of 2 chaosengines and instanceCount specifies the exact number of chaosengines to be launched between the range (start and end time). SO we can choose depending on our requirements.</p>"},{"location":"experiments/faq/install/","title":"Install","text":""},{"location":"experiments/faq/install/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>I encountered the concept of namespace and cluster scope during the installation. What is meant by the scopes, and how does it affect experiments to be performed outside or inside the litmus Namespace?</p> </li> <li> <p>Does Litmus 2.0 maintain backward compatibility with Kubernetes?</p> </li> <li> <p>Can I run LitmusChaos Outside of my Kubernetes clusters?</p> </li> <li> <p>What is the minimum system requirement to run Portal and agent together?</p> </li> <li> <p>Can I use LitmusChaos in Production?</p> </li> <li> <p>Why should I use Litmus? What is its distinctive feature?</p> </li> <li> <p>What licensing model does Litmus use?</p> </li> <li> <p>What are the prerequisites to get started with Litmus?</p> </li> <li> <p>How to Install Litmus on the Kubernetes Cluster?</p> </li> </ol>"},{"location":"experiments/faq/install/#i-encountered-the-concept-of-namespace-and-cluster-scope-during-the-installation-what-is-meant-by-the-scopes-and-how-does-it-affect-experiments-to-be-performed-outside-or-inside-the-litmus-namespace","title":"I encountered the concept of namespace and cluster scope during the installation. What is meant by the scopes, and how does it affect experiments to be performed outside or inside the litmus Namespace?","text":"<p>The scope of control plane (portal) installation can be tuned by the env 'PORTAL_SCOPE' in the 'litmusportal-server' deployment. Its value can be kept as a \u201cnamespace\u201d if you want to provide restricted access to litmus. It is useful in strictly multi-tenant environments in which users have namespace-level permissions and need to set up their own chaos-center instances. This is also the case in certain popular SaaS environments like Okteto cloud. </p> <p>This setting can be used in combination with a flag, 'AGENT_SCOPE' in the 'litmus-portal-admin-config' ConfigMap to limit the purview of the corresponding self-agent (the execution plane pods on the cluster/namespace where the control plane is installed) to the current namespace, which means the user can perform chaos experiments only in chosen installation namespace. By default, both are set up for cluster-wide access, by which microservices across the cluster can be subjected to chaos. </p> <p>In case of external-agents, i.e., the targets being connected to the chaos-center, you can choose the agent\u2019s scope to either cluster or namespace via a 'litmusctl' flag (when using it in non-interactive mode) or by providing the appropriate input (in interactive mode). </p>"},{"location":"experiments/faq/install/#does-litmus-20-maintain-backward-compatibility-with-kubernetes","title":"Does Litmus 2.0 maintain backward compatibility with Kubernetes?","text":"<p>Yes, Litmus maintains a separate CRD manifest to support backward compatibility.</p>"},{"location":"experiments/faq/install/#can-i-run-litmuschaos-outside-of-my-kubernetes-clusters","title":"Can I run LitmusChaos Outside of my Kubernetes clusters?","text":"<p>You can run the chaos experiments outside of the k8s cluster as a dockerized container. However, other components such as chaos-operator,chaos-exporter, and runner are Kubernetes native. They require k8s cluster to run on it.</p>"},{"location":"experiments/faq/install/#what-is-the-minimum-system-requirement-to-run-portal-and-agent-together","title":"What is the minimum system requirement to run Portal and agent together?","text":"<p>To run LitmusPortal you need to have a minimum of 1 GiB memory and 1 core of CPU free.</p>"},{"location":"experiments/faq/install/#can-i-use-litmuschaos-in-production","title":"Can I use LitmusChaos in Production?","text":"<p>Yes, you can use Litmuschaos in production. Litmus has a wide variety of experiments and is designed according to the principles of chaos engineering. However, if you are new to Chaos Engineering, we would recommend you to first try Litmus on your dev environment, and then after getting the confidence, you should use it in Production. </p>"},{"location":"experiments/faq/install/#why-should-i-use-litmus-what-is-its-distinctive-feature","title":"Why should I use Litmus? What is its distinctive feature?","text":"<p>Litmus is a toolset for performing cloud-native Chaos Engineering. Litmus provides tools to orchestrate chaos on Kubernetes to help developers and SREs find weaknesses in their application deployments. Litmus can be used to run chaos experiments initially in the staging environment and eventually in production to find bugs and vulnerabilities. Fixing the weaknesses leads to increased resilience of the system. Litmus adopts a \u201cKubernetes-native\u201d approach to define chaos intent in a declarative manner via custom resources.</p>"},{"location":"experiments/faq/install/#what-licensing-model-does-litmus-use","title":"What licensing model does Litmus use?","text":"<p>Litmus is developed under Apache License 2.0 license at the project level. Some components of the projects are derived from the other Open Source projects and are distributed under their respective licenses.</p>"},{"location":"experiments/faq/install/#what-are-the-prerequisites-to-get-started-with-litmus","title":"What are the prerequisites to get started with Litmus?","text":"<p>To get started with Litmus, the only prerequisites is to have Kubernetes 1.11+ cluster. While most pod/container level experiments are supported on any Kubernetes platform, some of the infrastructure chaos experiments are supported on specific platforms. To find the list of supported platforms for an experiment, view the \"Platforms\" section on the sidebar in the experiment page.</p>"},{"location":"experiments/faq/install/#how-to-install-litmus-on-the-kubernetes-cluster","title":"How to Install Litmus on the Kubernetes Cluster?","text":"<p>You can install/deploy stable litmus using this command:</p> <pre><code>kubectl apply -f https://litmuschaos.github.io/litmus/litmus-operator-latest.yaml\n</code></pre>"},{"location":"experiments/faq/portal/","title":"Litmus Portal","text":""},{"location":"experiments/faq/portal/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>Can we host MongoDB outside the cluster? What connection string is supported? Is SSL connection supported?</p> </li> <li> <p>What does failed status of workflow means in LitmusPortal?</p> </li> <li> <p>How can I setup a chaoshub of my gitlab repo in Litmus Portal?</p> </li> <li> <p>How to achieve High Availability of MongoDB and how can we add persistence to MongoDB?</p> </li> <li> <p>Can I create workflows without using a dashboard?</p> </li> <li> <p>Does Litmusctl support actions that are currently performed from the portal dashboard?</p> </li> <li> <p>How is resilience score is Calculated?</p> </li> </ol>"},{"location":"experiments/faq/portal/#can-we-host-mongodb-outside-the-cluster-what-connection-string-is-supported-is-ssl-connection-supported","title":"Can we host MongoDB outside the cluster? What connection string is supported? Is SSL connection supported?","text":"<p>Yes we can host Mongodb outside the cluster, the mongo string can be updated accordingly DataBaseServer: \"mongodb://mongo-service:27017\" We use the same connection string for both authentication server and graphql server containers in litmus portal-server deployment, also there are the db user and db password keys that can be tuned in the secrets like DB_USER: \"admin\" and DB_PASSWORD: \"1234\".  We can connect with SSL if the certificate is optional. If our requirement is ca.cert auth for the SSL connection, then this is not available on the portal</p>"},{"location":"experiments/faq/portal/#what-does-failed-status-of-workflow-means-in-litmusportal","title":"What does failed status of workflow means in LitmusPortal?","text":"<p>Failed status indicates that either there is some misconfiguration in the workflow or the default hypothesis of the experiment was disproved and some of the experiments in the workflow failed, In such case, the resiliency score will be less than 100.</p>"},{"location":"experiments/faq/portal/#how-can-i-setup-a-chaoshub-of-my-gitlab-repo-in-litmus-portal","title":"How can I setup a chaoshub of my gitlab repo in Litmus Portal?","text":"<p>In the litmus portal when you go to the chaoshub section and you click on connect new hub button, you can see that there are two modes of authentication i.e public mode and private mode. For public mode, you only have to provide the git URL and branch name. For private mode, we have two types of authentication; Access token and SSH key. For the access token, go to the settings of GitLab and in the Access token section, add a token with read repository permission. After getting the token, go to the Litmus portal and provide the GitLab URL and branch name along with the access token. After submitting, your own chaos hub is connected to the Litmus portal. For the second mode of authentication i.e; SSH key, In SSH key once you click on the SSH, It will generate a public key. You have to use the public key and put it in the GitLab setting. Just go to the settings of GitLab, you can see the SSH key section, go to the SSH key section and add your public key. After adding the public key. Get the ssh type URL of the git repository and put it in the Litmusportal along with the branch, after submitting your chaoshub is connected to the Litmus Portal.</p>"},{"location":"experiments/faq/portal/#how-to-achieve-high-availability-of-mongodb-and-how-can-we-add-persistence-to-mongodb","title":"How to achieve High Availability of MongoDB and how can we add persistence to MongoDB?","text":"<p>Currently, the MongoDB instance is not HA, we can install the MongoDB operator along with mongo to achieve HA. This MongoDB CRD allows for specifying the desired size and version as well as several other advanced options. Along with the MongoDB operator, we will use the MongoDB sts with PV to add persistence.</p>"},{"location":"experiments/faq/portal/#can-i-create-workflows-without-using-a-dashboard","title":"Can I create workflows without using a dashboard?","text":"<p>Currently, you can\u2019t.But We are working on it. Shortly we will publish samples for doing this via API/SDK and litmusctl.</p>"},{"location":"experiments/faq/portal/#does-litmusctl-support-actions-that-are-currently-performed-from-the-portal-dashboard","title":"Does Litmusctl support actions that are currently performed from the portal dashboard?","text":"<p>For now you can create agents and projects, also you can get the agents and project details by using litmusctl. To know more about litmusctl please refer to the documentation of litmusctl.</p>"},{"location":"experiments/faq/portal/#how-is-resilience-score-is-calculated","title":"How is resilience score is Calculated?","text":"<p>The Resilience score is calculated on the basis of the weightage and the Probe Success Percentage of the experiment. Resilience for one single experiment is the multiplication of the weight given to that experiment and the Probe Success Percentage. Then we get the total test result by adding the resilience score of all the experiments. The Final Resilience Score is calculated by dividing the total test result by the sum of the weights of all the experiments combined in the single workflow. For more detail refer to this blog.</p>"},{"location":"experiments/faq/scheduler/","title":"Chaos Scheduler","text":""},{"location":"experiments/faq/scheduler/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>What is ChaosScheduler?</p> </li> <li> <p>How is ChaosScheduler different from ChaosOperator?</p> </li> <li> <p>What are the pre-requisites for ChaosScheduler?</p> </li> <li> <p>How to install ChaosScheduler?</p> </li> <li> <p>How to schedule the chaos using ChaosScheduler?</p> </li> <li> <p>What are the different techniques of scheduling the chaos?</p> </li> <li> <p>What fields of spec.schedule are to be specified with spec.schedule.type=now?</p> </li> <li> <p>What fields of spec.schedule are to be specified with spec.schedule.type=once?</p> </li> <li> <p>What fields of spec.schedule are to be specified with spec.schedule.type=repeat?</p> </li> <li> <p>How to run ChaosScheduler in Namespaced mode?</p> </li> </ol>"},{"location":"experiments/faq/scheduler/#what-is-chaosscheduler","title":"What is ChaosScheduler?","text":"<p>ChaosScheduler is an operator built on top of the operator-sdk framework. It keeps on watching resources of kind ChaosSchedule and based on the scheduling parameters automates the formation of ChaosEngines, to be observed by ChaosOperator, instead of manually forming the ChaosEngine every time we wish to inject chaos in the cluster.</p>"},{"location":"experiments/faq/scheduler/#how-is-chaosscheduler-different-from-chaosoperator","title":"How is ChaosScheduler different from ChaosOperator?","text":"<p>ChaosOperator operates on chaosengines while ChaosScheduler operates on chaosschedules which in turn forms chaosengines, through some scheduling techniques, to be observed by ChaosOperator. So ChaosOperator is a basic building block used to inject chaos in a cluster while ChaosScheduler is just a scheduling strategy that injects chaos in some form of pattern using ChaosOperator only. ChaosScheduler can not be used independently of ChaosOperator.</p>"},{"location":"experiments/faq/scheduler/#what-are-the-pre-requisites-for-chaosscheduler","title":"What are the pre-requisites for ChaosScheduler?","text":"<p>For getting started with ChaosScheduler, we should just have ChaosOperator and all the litmus infrastructure components installed in the cluster beforehand.</p>"},{"location":"experiments/faq/scheduler/#how-to-install-chaosscheduler","title":"How to install ChaosScheduler?","text":"<p>Firstly install the rbac and crd - <pre><code>kubectl apply -f https://raw.githubusercontent.com/litmuschaos/chaos-scheduler/master/deploy/rbac.yaml\nkubectl apply -f https://raw.githubusercontent.com/litmuschaos/chaos-scheduler/master/deploy/crds/chaosschedule_crd.yaml\n</code></pre></p> <p>Install ChaosScheduler operator afterwards - <pre><code>kubectl apply -f https://raw.githubusercontent.com/litmuschaos/chaos-scheduler/master/deploy/chaos-scheduler.yaml\n</code></pre></p>"},{"location":"experiments/faq/scheduler/#how-to-schedule-the-chaos-using-chaosscheduler","title":"How to schedule the chaos using ChaosScheduler?","text":"<p>This depends on which type of schedule we want to use for injecting chaos. For basic understanding refer constructing schedule</p>"},{"location":"experiments/faq/scheduler/#what-are-the-different-techniques-of-scheduling-the-chaos","title":"What are the different techniques of scheduling the chaos?","text":"<p>As of now, there are 3 scheduling techniques which can be selected based on the parameter passed to spec.schedule.type</p> <ul> <li>type=now</li> <li>type=once</li> <li>type=repeat</li> </ul>"},{"location":"experiments/faq/scheduler/#what-fields-of-specschedule-are-to-be-specified-with-specscheduletypenow","title":"What fields of spec.schedule are to be specified with spec.schedule.type=now?","text":"<p>No fields are needed to be specified for this as it launches the desired chaosengine immediately.</p>"},{"location":"experiments/faq/scheduler/#what-fields-of-specschedule-are-to-be-specified-with-specscheduletypeonce","title":"What fields of spec.schedule are to be specified with spec.schedule.type=once?","text":"<p>We just need to pass spec.executionTime. Scheduler will launch the chaosengine exactly at the point of time mentioned in this parameter.</p>"},{"location":"experiments/faq/scheduler/#what-fields-of-specschedule-are-to-be-specified-with-specscheduletyperepeat","title":"What fields of spec.schedule are to be specified with spec.schedule.type=repeat?","text":"<p>All the fields of spec.schedule except spec.schedule.executionTime are needed to be specified.</p> <ul> <li>startTime</li> <li>endTime</li> <li>minChaosInterval</li> <li>includedHours</li> <li>includedDays</li> </ul> <p>It schedules chaosengines to be launched according to the parameters passed. It works just as a cronjob does, having superior functionalities such as we can control when the schedule will start and end.</p>"},{"location":"experiments/faq/scheduler/#how-to-run-chaosscheduler-in-namespaced-mode","title":"How to run ChaosScheduler in Namespaced mode?","text":"<p>Firstly install the crd - <pre><code>kubectl apply -f https://github.com/litmuschaos/litmus/tree/master/mkdocs/docs/litmus-namespaced-scope/litmus-scheduler-namespaced-crd.yaml\n</code></pre></p> <p>Secondly install the rbac in the desired Namespace - <pre><code>kubectl apply -f https://github.com/litmuschaos/litmus/tree/master/mkdocs/docs/litmus-namespaced-scope/litmus-scheduler-ns-rbac.yaml -n &lt;namespace&gt;\n</code></pre></p> <p>Install ChaosScheduler operator in the desired Namespace afterwards - <pre><code>kubectl apply -f https://github.com/litmuschaos/litmus/tree/master/mkdocs/docs/litmus-namespaced-scope/litmus-namespaced-scheduler.yaml -n &lt;namespace&gt;\n</code></pre></p> <p>Execute ChaosScheduler with an experiment in the desired Namespace afterward.</p> <p><code>Note</code>: The ChaosServiceAccount used within the embedded ChaosEngine template needs to be chosen appropriately depending on the experiment scope. -  ```yaml apiVersion: litmuschaos.io/v1alpha1 kind: ChaosSchedule metadata:   name: schedule-nginx   namespace:  spec:   schedule:     repeat:       timeRange:         startTime: \"2020-05-12T05:47:00Z\"   #should be modified according to current UTC Time, for type=repeat         endTime: \"2020-09-13T02:58:00Z\"   #should be modified according to current UTC Time, for type=repeat       properties:         minChaosInterval: \"2m\"   #format should be like \"10m\" or \"2h\" accordingly for minutes and hours, for type=repeat       workHours:         includedHours: 0-12       workDays:         includedDays: \"Mon,Tue,Wed,Sat,Sun\" #should be set for type=repeat   engineTemplateSpec:     appinfo:       appns: 'default'       applabel: 'app=nginx'       appkind: 'deployment'     # It can be true/false     annotationCheck: 'false'     # It can be active/stop     engineState: 'active'     #ex. values: ns1:name=percona,ns2:run=nginx     auxiliaryAppInfo: ''     chaosServiceAccount: pod-delete-sa     # It can be delete/retain     jobCleanUpPolicy: 'delete'     experiments:       - name: pod-delete         spec:           components:             env:               # set chaos duration (in sec) as desired               - name: TOTAL_CHAOS_DURATION                 value: '30' <pre><code>          # set chaos interval (in sec) as desired\n          - name: CHAOS_INTERVAL\n            value: '10'\n\n          # pod failures without '--force' &amp; default terminationGracePeriodSeconds\n          - name: FORCE\n            value: 'false'\n</code></pre>"},{"location":"experiments/troubleshooting/experiments/","title":"Litmus Experiments","text":""},{"location":"experiments/troubleshooting/experiments/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>When I\u2019m executing an experiment the experiment's pod failed with the exec format error</p> </li> <li> <p>Nothing happens (no pods created) when the chaosengine resource is created?</p> </li> <li> <p>The chaos-runner pod enters completed state seconds after getting created. No experiment jobs are created?</p> </li> <li> <p>The experiment pod enters completed state w/o the desired chaos being injected?</p> </li> <li> <p>Observing experiment results using describe chaosresult is showing NotFound error?</p> </li> <li> <p>The helper pod is getting in a failed state due to container runtime issue</p> </li> <li> <p>Disk Fill fail with the error message</p> </li> <li> <p>Disk Fill failed with error</p> </li> <li> <p>Disk fill experiment fails with an error pointing to the helper pods being unable to finish in the given duration</p> </li> <li> <p>The infra experiments like node drain, node taint, kubelet service kill to act on the litmus pods only</p> </li> <li> <p>AWS experiments failed with the following error</p> </li> <li> <p>In AWS SSM Chaos I have provided the aws in secret but still not able to inject the SSM chaos on the target instance</p> </li> <li> <p>GCP VM Disk Loss experiment fails unexpectedly where the disk gets detached successfully but fails to attach back to the instance. What can be the reason?</p> </li> <li> <p>In pod level stress chaos experiments like pod memory hog or pod io stress after the chaos is injected successfully the helper fails with an error message</p> </li> <li> <p>Experiment failed for the istio enabled namespaces</p> </li> </ol>"},{"location":"experiments/troubleshooting/experiments/#when-im-executing-an-experiment-the-experiments-pod-failed-with-the-exec-format-error","title":"When I\u2019m executing an experiment the experiment's pod failed with the exec format error","text":"View the error message <p>standard_init_linux.go:211: exec user process caused \"exec format error\":</p> <p>There could be multiple reasons for this. The most common one is mismatched in the binary and the platform on which it is running, try to check out the image binary you're using should have the support for the platform on which you\u2019re trying to run the experiment.</p>"},{"location":"experiments/troubleshooting/experiments/#nothing-happens-no-pods-created-when-the-chaosengine-resource-is-created","title":"Nothing happens (no pods created) when the chaosengine resource is created?","text":"<p>If the ChaosEngine creation results in no action at all, perform the following checks: </p> <ul> <li> <p>Check the Kubernetes events generated against the chaosengine resource.    <pre><code>kubectl describe chaosengine &lt;chaosengine-name&gt; -n &lt;namespace&gt;\n</code></pre>   Specifically look for the event reason ChaosResourcesOperationFailed. Typically, these events consist of messages pointing to the    problem. Some of the common messages include:</p> <ul> <li>Unable to filter app by specified info</li> <li>Unable to get chaos resources</li> <li>Unable to update chaosengine</li> </ul> </li> <li> <p>Check the logs of the chaos-operator pod using the following command to get more details (on failed creation of chaos resources).    The below example uses litmus namespace, which is the default mode of installation. Please provide the namespace into which the    operator has been deployed:      <pre><code>kubectl logs -f &lt;chaos-operator-(hash)-(hash)&gt;-runner -n litmus\n</code></pre></p> </li> </ul>"},{"location":"experiments/troubleshooting/experiments/#some-of-the-possible-reasons-for-these-errors-include","title":"Some of the possible reasons for these errors include:","text":"<ul> <li> <p>The annotationCheck is set to <code>true</code> in the ChaosEngine spec, but the application deployment (AUT) has not    been annotated for chaos. If so, please add it using the following command:      <pre><code>kubectl annotate &lt;deploy-type&gt;/&lt;application_name&gt; litmuschaos.io/chaos=\"true\"\n</code></pre></p> </li> <li> <p>The annotationCheck is set to <code>true</code> in the ChaosEngine spec and there are multiple chaos candidates that    share the same label (as provided in the <code>.spec.appinfo</code> of the ChaosEngine) and are also annotated for chaos.    If so, please provide a unique label for the AUT, or remove annotations on other applications with the same label.    Litmus, by default, doesn't allow selection of multiple applications. If this is a requirement, set the    annotationCheck to <code>false</code>.      <pre><code>kubectl annotate &lt;deploy-type&gt;/&lt;application_name&gt; litmuschaos.io/chaos-\n</code></pre></p> </li> <li> <p>The ChaosEngine has the <code>.spec.engineState</code> set to <code>stop</code>, which causes the operator to refrain from creating chaos    resources. While it is an unlikely scenario, it is possible to reuse a previously modified ChaosEngine manifest.</p> </li> <li> <p>Verify if the service account used by the Litmus ChaosOperator has enough permissions to launch pods/services    (this is available by default if the manifests suggested by the docs have been used).</p> </li> </ul>"},{"location":"experiments/troubleshooting/experiments/#the-chaos-runner-pod-enters-completed-state-seconds-after-getting-created-no-experiment-jobs-are-created","title":"The chaos-runner pod enters completed state seconds after getting created. No experiment jobs are created?","text":"<p>If the chaos-runner enters completed state immediately post creation, i.e., the creation of experiment resources is  unsuccessful, perform the following checks: </p> <ul> <li>Check the Kubernetes events generated against the chaosengine resource.      <pre><code>kubectl describe chaosengine &lt;chaosengine-name&gt; -n &lt;namespace&gt;\n</code></pre></li> </ul> <p>Look for one of these events: ExperimentNotFound, ExperimentDependencyCheck, EnvParseError </p> <ul> <li>Check the logs of the chaos-runner pod logs. <pre><code>kubectl logs -f &lt;chaosengine_name&gt;-runner -n &lt;namespace&gt;\n</code></pre></li> </ul>"},{"location":"experiments/troubleshooting/experiments/#some-of-the-possible-reasons-may-include","title":"Some of the possible reasons may include:","text":"<ul> <li> <p>The ChaosExperiment CR for the experiment (name) specified in the ChaosEngine .spec.experiments list is not installed.    If so, please install the desired experiment from the chaoshub</p> </li> <li> <p>The dependent resources for the ChaosExperiment, such as ConfigMap &amp; secret volumes (as specified in the ChaosExperiment CR    or the ChaosEngine CR) may not be present in the cluster (or in the desired namespace). The runner pod doesn\u2019t proceed    with creation of experiment resources if the dependencies are unavailable.  </p> </li> <li> <p>The values provided for the ENV variables in the ChaosExperiment or the ChaosEngines might be invalid</p> </li> <li> <p>The chaosServiceAccount specified in the ChaosEngine CR doesn\u2019t have sufficient permissions to create the experiment    resources (For existing experiments, appropriate rbac manifests are already provided in chaos-charts/docs).</p> </li> </ul>"},{"location":"experiments/troubleshooting/experiments/#the-experiment-pod-enters-completed-state-wo-the-desired-chaos-being-injected","title":"The experiment pod enters completed state w/o the desired chaos being injected?","text":"<p>If the experiment pod enters completed state immediately (or in a few seconds) after creation w/o injecting the desired chaos,  perform the following checks: </p> <ul> <li>Check the Kubernetes events generated against the ChaosEngine resource</li> </ul> <pre><code>kubectl describe chaosengine &lt;chaosengine-name&gt; -n &lt;namespace&gt;\n</code></pre> <p>Look for the event with reason Summary with message  experiment has been failed <ul> <li>Check the logs of the chaos-experiment pod. </li> </ul> <pre><code>kubectl logs -f &lt;experiment_name_(hash)_(hash)&gt; -n &lt;namespace&gt;\n</code></pre>"},{"location":"experiments/troubleshooting/experiments/#some-of-the-possible-reasons-may-include_1","title":"Some of the possible reasons may include:","text":"<ul> <li> <p>The ChaosExperiment CR or the ChaosEngine CR doesn\u2019t include mandatory ENVs  (or consists of incorrect values/info)    needed by the experiment. Note that each experiment (see docs) specifies a mandatory set of ENVs along with some    optional ones, which are necessary for successful execution of the experiment. </p> </li> <li> <p>The chaosServiceAccount specified in the ChaosEngine CR doesn\u2019t have sufficient permissions to create the experiment    helper-resources (i.e., some experiments in turn create other K8s resources like Jobs/Daemonsets/Deployments etc..,   For existing experiments, appropriate rbac manifests are already provided in chaos-charts/docs)</p> </li> <li> <p>The application's (AUT) unique label provided in the ChaosEngine is set only at the parent resource metadata but not    propagated to the pod template spec. Note that the Operator uses this label to filter chaos candidates at the parent    resource level (deployment/statefulset/daemonset) but the experiment pod uses this to pick application pods into    which the chaos is injected. </p> </li> <li> <p>The experiment pre-chaos checks have failed on account of application (AUT) or auxiliary application unavailability</p> </li> </ul>"},{"location":"experiments/troubleshooting/experiments/#observing-experiment-results-using-describe-chaosresult-is-showing-notfound-error","title":"Observing experiment results using <code>describe chaosresult</code> is showing <code>NotFound</code> error?","text":"<p>Upon observing the ChaosResults by executing the describe command given below, it may give a <code>NotFound</code> error. </p> <pre><code>kubectl describe chaosresult &lt;chaos-engine-name&gt;-&lt;chaos-experiment-name&gt;  -n &lt;namespace&gt;\n</code></pre> <p>Alternatively, running the describe command without specifying the expected ChaosResult name might execute successfully, but does may not show any output. </p> <pre><code>kubectl describe chaosresult  -n &lt;namespace&gt;`\n</code></pre> <p>This can occur sometimes due to the time taken in pulling the image starting the experiment pod (note that the ChaosResult resource is generated by the experiment).  For the above commands to execute successfully, you should simply wait for the experiment pod to be created. The waiting time will be based upon resource available (network bandwidth, space availability on the node filesyste</p>"},{"location":"experiments/troubleshooting/experiments/#the-helper-pod-is-getting-in-a-failed-state-due-to-container-runtime-issue","title":"The helper pod is getting in a failed state due to container runtime issue","text":"View the error message <p>time=\"2021-07-15T10:26:04Z\" level=fatal msg=\"helper pod failed, err: Unable to run command, err: exit status 1; error output: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\"</p> <p>OR</p> <p>time=\"2021-07-16T22:21:02Z\" level=error msg=\"[docker]: Failed to run docker inspect: []\\nError: No such object: 1807fec21ccad1101bbb63a7d412be15414f807316572f9e043b9f4a3e7c4acc\\n\" time=\"2021-07-16T22:21:02Z\" level=fatal msg=\"helper pod failed, err: exit status 1\"</p> <p>The default values for <code>CONTAINER_RUNTIME</code> &amp; <code>SOCKET_PATH</code> env is for <code>docker</code> runtime. Please check if the cluster runtime is other than docker i.e, containerd then update above ENVs as follow:</p> <ul> <li> <p>For containerd runtime: </p> <ul> <li><code>CONTAINER_RUNTIME</code>: containerd</li> <li><code>SOCKET_PATH</code>: /run/containerd/containerd.sock</li> </ul> </li> <li> <p>For CRIO runtime:</p> <ul> <li><code>CONTAINER_RUNTIME</code>: crio</li> <li><code>SOCKET_PATH</code>: /run/crio/crio.sock</li> </ul> </li> </ul> <p><code>NOTE</code>: The above values are the common ones and may vary based on the cluster you\u2019re using.</p>"},{"location":"experiments/troubleshooting/experiments/#disk-fill-fail-with-the-error-message","title":"Disk Fill fail with the error message","text":"View the error message <p>time=\"2021-08-12T05:27:39Z\" level=fatal msg=\"helper pod failed, err: either provide ephemeral storage limit inside target container or define EPHEMERAL_STORAGE_MEBIBYTES ENV\"</p> <p>The disk fill experiment needs to have either ephemeral storage limit defined in the application or you can provide the value in mebibytes using  <code>EPHEMERAL_STORAGE_MEBIBYTES</code> ENV in the chaos engine. Either of them is required. For more details refer: FILL_PERCENTAGE and EPHEMERAL_STORAGE_MEBIBYTES</p>"},{"location":"experiments/troubleshooting/experiments/#disk-fill-failed-with-error","title":"Disk Fill failed with error:","text":"View the error message <p>time=\"2021-08-12T05:41:45Z\" level=error msg=\"du: /diskfill/8a1088e3fd50a31d5f0d383ae2258d9975f1df152ff92b3efd570a44e952a732: No such file or directory\\n\" time=\"2021-08-12T05:41:45Z\" level=fatal msg=\"helper pod failed, err: exit status 1\"</p> <p>This could be due to multiple issues in filling the disk of a container the most common one is invalid CONTAINER_PATH env set in the chaosengine. The default container path env is common for most of the use-cases and that is <code>/var/lib/docker/containers</code> </p>"},{"location":"experiments/troubleshooting/experiments/#disk-fill-experiment-fails-with-an-error-pointing-to-the-helper-pods-being-unable-to-finish-in-the-given-duration","title":"Disk fill experiment fails with an error pointing to the helper pods being unable to finish in the given duration.","text":"<p>This could be possible when the provided block size is quite less and the empirical storage value is high. In this case, it may need more time than the given chaos duration to fill the disk.</p>"},{"location":"experiments/troubleshooting/experiments/#the-infra-experiments-like-node-drain-node-taint-kubelet-service-kill-to-act-on-the-litmus-pods-only","title":"The infra experiments like node drain, node taint, kubelet service kill to act on the litmus pods only.","text":"<p>Ans: These are the infra level experiments, we need to cordon the target node so that the application pods don\u2019t get scheduled on it and use node selector in the chaos engine to specify the nodes for the experiment pods. Refer to the this to know how to schedule experiments on a certain node.</p>"},{"location":"experiments/troubleshooting/experiments/#aws-experiments-failed-with-the-following-error","title":"AWS experiments failed with the following error","text":"View the error message <p>time=\"2021-08-12T10:25:57Z\" level=error msg=\"failed perform ssm api calls, err: UnrecognizedClientException: The security token included in the request is invalid.\\n\\tstatus code: 400, request id: 68f0c2e8-a7ed-4576-8c75-0a3ed497efb9\" </p> <p>The AWS experiment needs authentication to connect &amp; perform actions on the aws services we can provide this with the help of the secret as shown below:</p> View the secret manifest <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloud-secret\ntype: Opaque\nstringData:\n  cloud_config.yml: |-\n    # Add the cloud AWS credentials respectively\n    [default]\n    aws_access_key_id = XXXXXXXXXXXXXXXXXXX\n    aws_secret_access_key = XXXXXXXXXXXXXXX\n</code></pre> <p>Make sure you have all the required permissions attached with your IAM to perform the chaos operation on the given service. If you are running the experiment in an EKS cluster then you have one more option than creating a secret, you can map the IAM role with the service account refer to this for more details.</p>"},{"location":"experiments/troubleshooting/experiments/#in-aws-ssm-chaos-i-have-provided-the-aws-in-secret-but-still-not-able-to-inject-the-ssm-chaos-on-the-target-instance","title":"In AWS SSM Chaos I have provided the aws in secret but still not able to inject the SSM chaos on the target instance","text":"View the error message <p>time='2021-08-13T09:30:47Z' level=error msg='failed perform ssm api calls, err: error: the instance id-qqw2-123-12- might not have suitable permission or IAM attached to it. use \\'aws ssm describe-instance-information\\' to check the available instances'</p> <p>Ensure that you have the required AWS access and your target EC2 instances have attached an IAM instance profile. To know more checkout Systems Manager Docs</p>"},{"location":"experiments/troubleshooting/experiments/#gcp-vm-disk-loss-experiment-fails-unexpectedly-where-the-disk-gets-detached-successfully-but-fails-to-attach-back-to-the-instance-what-can-be-the-reason","title":"GCP VM Disk Loss experiment fails unexpectedly where the disk gets detached successfully but fails to attach back to the instance. What can be the reason?","text":"<p>The GCP VM Disk Loss experiment requires a GCP Service Account having a Project Editor or higher permission to execute. This could be because of an issue in the GCP GoLang Compute Engine API, which fails to attach the disk using the attachDisk method with a Compute Admin or lower permission.</p>"},{"location":"experiments/troubleshooting/experiments/#in-pod-level-stress-chaos-experiments-like-pod-memory-hog-or-pod-io-stress-after-the-chaos-is-injected-successfully-the-helper-fails-with-an-error-message","title":"In pod level stress chaos experiments like pod memory hog or pod io stress after the chaos is injected successfully the helper fails with an error message","text":"View the error message <p>Error: process exited before the actual cleanup</p> <p>The error message indicates that the stress process inside the target container is somehow removed before the actual cleanup. There could be multiple reasons for this: the target container might have just got restarted due to excessive load on the container which it can\u2019t handle and the kubelet terminated that replica and launches a new one (if applicable) and reports an OOM event on the older one.</p>"},{"location":"experiments/troubleshooting/experiments/#experiment-failed-for-the-istio-enabled-namespaces","title":"Experiment failed for the istio enabled namespaces","text":"View the error message <p>W0817 06:32:26.531145       1 client_config.go:541] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work. time=\"2021-08-17T06:32:26Z\" level=error msg=\"unable to get ChaosEngineUID, error: unable to get ChaosEngine name: pod-delete-chaos, in namespace: default, error: Get \\\"https://10.100.0.1:443/apis/litmuschaos.io/v1alpha1/namespaces/default/chaosengines/pod-delete-chaos\\\": dial tcp 10.100.0.1:443: connect: connection refused\"</p> <p>If istio is enabled for the <code>chaos-namespace</code>, it will launch the chaos-runner and chaos-experiment pods with the istio sidecar. Which may block/delay the external traffic of those pods for the intial few seconds. Which can fail the experiment.</p> <p>We can fix the above failure by avoiding istio sidecar for the chaos pods. Refer the following manifest:</p> View the ChaosEngine manifest with the required annotations <pre><code>apiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: engine-nginx\nspec:\n  components:\n    runner:\n      # annotation for the chaos-runner\n      runnerAnnotations:\n        sidecar.istio.io/inject: \"false\"\n  engineState: \"active\"\n  annotationCheck: \"false\"\n  appinfo:\n    appns: \"default\"\n    applabel: \"app=nginx\"\n    appkind: \"deployment\"\n  chaosServiceAccount: container-kill-sa\n  experiments:\n  - name: container-kill\n    spec:\n      components:\n        #annotations for the experiment pod \n        experimentAnnotations:\n          sidecar.istio.io/inject: \"false\"\n        env:\n        - name: TOTAL_CHAOS_DURATION\n          value: '60'\n</code></pre>"},{"location":"experiments/troubleshooting/install/","title":"Install","text":""},{"location":"experiments/troubleshooting/install/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>The Litmus ChaosOperator is seen to be in CrashLoopBackOff state immediately after installation?</p> </li> <li> <p>Litmus uninstallation is not successful and namespace is stuck in terminating state?</p> </li> </ol>"},{"location":"experiments/troubleshooting/install/#the-litmus-chaosoperator-is-seen-to-be-in-crashloopbackoff-state-immediately-after-installation","title":"The Litmus ChaosOperator is seen to be in CrashLoopBackOff state immediately after installation?","text":"<p>Verify if the ChaosEngine custom resource definition (CRD) has been installed in the cluster. This can be  verified with the following commands: </p> <p><pre><code>kubectl get crds | grep chaos\n</code></pre> <pre><code>kubectl api-resources | grep chaos\n</code></pre></p> <p>If not created, install it from here</p>"},{"location":"experiments/troubleshooting/install/#litmus-uninstallation-is-not-successful-and-namespace-is-stuck-in-terminating-state","title":"Litmus uninstallation is not successful and namespace is stuck in terminating state?","text":"<p>Under typical operating conditions, the ChaosOperator makes use of finalizers to ensure that the ChaosEngine is deleted  only after chaos resources (chaos-runner, experiment pod, any other helper pods) are removed. </p> <p>When uninstalling Litmus via the operator manifest, which contains the namespace, operator, and crd specifications in a single YAML, without deleting the existing chaosengine resources first, the ChaosOperator deployment may get deleted before the CRD removal  is attempted. Since the stale chaosengines have the finalizer present on them, their deletion (triggered by the CRD delete) and  by consequence, the deletion of the chaosengine CRD itself is \"stuck\". </p> <p>In such cases, manually remove the finalizer entries on the stale chaosengines to facilitate their successful delete.  To get the chaosengine, run:</p> <p><code>kubectl get chaosengine -n &lt;namespace&gt;</code></p> <p>followed by:</p> <p><code>kubectl edit chaosengine &lt;chaosengine-name&gt; -n &lt;namespace&gt;</code> and remove the finalizer entry <code>chaosengine.litmuschaos.io/finalizer</code></p> <p>Repeat this on all the stale chaosengine CRs to remove the CRDs successfully &amp; complete uninstallation process.</p> <p>If however, the <code>litmus</code> namespace deletion remains stuck despite the above actions, follow the procedure described  here to complete the uninstallation. </p>"},{"location":"experiments/troubleshooting/portal/","title":"Litmus Portal","text":""},{"location":"experiments/troubleshooting/portal/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>We were setting up a Litmus Portal, however, Self-Agent status is showing pending. Any idea why is happening?</p> </li> <li> <p>After logging in for the first time to the portal, /get-started page kept loading after I provided the new password</p> </li> <li> <p>Subscriber is crashing with the error dial:websocket: bad handshake</p> </li> <li> <p>Not able to connect to the LitmusChaos Control Plane hosted on GKE cluster</p> </li> <li> <p>I forgot my Litmus portal password. How can I reset my credentials?</p> </li> <li> <p>While Uninstalling Litmus portal using helm, some components like subscriber, exporter, event, workflows, etc, are not removed</p> </li> <li> <p>Unable to Install Litmus portal using helm. Server pod and mongo pod are in CrashLoopBackOff state. Got this error while checking the logs of mongo container chown: changing ownership of '/data/db/.snapshot': Read-only file system</p> </li> <li> <p>Pre-defined workflow Bank Of Anthos showing bus error for accounts-db or ledger-db pod?</p> </li> </ol>"},{"location":"experiments/troubleshooting/portal/#we-were-setting-up-a-litmus-portal-however-self-agent-status-is-showing-pending-any-idea-why-is-happening","title":"We were setting up a Litmus Portal, however, Self-Agent status is showing pending. Any idea why is happening?","text":"<p>The litmusportal-server-service might not be reachable due to inbound rules. You can enable the traffic to it if on GKE/EKS/AKS (by adding the port to inbound rules for traffic). You have to check the logs of the subscriber pod and expose the port mentioned for communication with the server.</p>"},{"location":"experiments/troubleshooting/portal/#after-logging-in-for-the-first-time-to-the-portal-get-started-page-kept-loading-after-i-provided-the-new-password","title":"After logging in for the first time to the portal, /get-started page kept loading after I provided the new password.","text":"<p>First, try to clear the browser cache and cookies and refresh the page, this might solve your problem. If your problem persists then delete all the cluster role bindings,PV, and PVC used by litmus and try to reinstall the litmus again.</p>"},{"location":"experiments/troubleshooting/portal/#subscriber-is-crashing-with-the-error-dialwebsocket-bad-handshake","title":"Subscriber is crashing with the error dial:websocket: bad handshake","text":"<p>It is a network issue. It seems your subscriber is unable to access the server. While installing the agent, It creates a config called agent-config to store some metadata like server endpoint, accesskey, etc. That server endpoint can be generated in many ways:</p> <ul> <li>Ingress (If INGRESS=true in server deployment envs)</li> <li>Loadbalancer (it generates lb type of IP based on the server svc type)</li> <li>NodePort (it generates nodeport type of IP based on the server svc type)</li> <li>ClusterIP (it generates clusterip type of IP based on the server svc type)</li> </ul> <p>So, you can edit the agent-config and update the node IP. Once edited, restart the subscriber. We suggest using ingress, so that if the endpoint IP changes, then it won't affect your agent.</p>"},{"location":"experiments/troubleshooting/portal/#not-able-to-connect-to-the-litmuschaos-control-plane-hosted-on-gke-cluster","title":"Not able to connect to the LitmusChaos Control Plane hosted on GKE cluster.","text":"<p>In GKE you have to setup a firewall rule to allow TCP traffic on the node port.You can use the following command: gcloud compute firewall-rules create test-node-port --allow tcp:port If this firewall rule is set up, it may be accessible on nodeIp:port where nodeIp is the external IP address of your node.</p>"},{"location":"experiments/troubleshooting/portal/#i-forgot-my-litmus-portal-password-how-can-i-reset-my-credentials","title":"I forgot my Litmus portal password. How can I reset my credentials?","text":"<p>You can reset by running the followin command: <pre><code>kubectl exec -it mongo-0 -n litmus -- mongo -u admin -p 1234 &lt;&lt;&lt; $'use auth\\ndb.usercredentials.update({username:\"admin\"},{$set:{password:\"$2a$15$sNuQl9y/Ok92N19UORcro.3wulEyFi0FfJrnN/akOQe3uxTZAzQ0C\"}})\\nexit\\n'\n</code></pre> Make sure to update the namespace and mongo pod name according to your setup,the rest should remain the same. This command will update the password to litmus.</p>"},{"location":"experiments/troubleshooting/portal/#while-uninstalling-litmus-portal-using-helm-some-components-like-subscriber-exporter-event-workflows-etc-are-not-removed","title":"While Uninstalling Litmus portal using helm, some components like subscriber, exporter, event, workflows, etc, are not removed.","text":"<p>These are agent components, which are launched by the control plane server, so first disconnect the agent from the portal then uninstall the portal using helm.</p>"},{"location":"experiments/troubleshooting/portal/#unable-to-install-litmus-portal-using-helm-server-pod-and-mongo-pod-are-in-crashloopbackoff-state-got-this-error-while-checking-the-logs-of-mongo-container-chown-changing-ownership-of-datadbsnapshot-read-only-file-system","title":"Unable to Install Litmus portal using helm. Server pod and mongo pod are in CrashLoopBackOff state. Got this error while checking the logs of mongo container chown: changing ownership of '/data/db/.snapshot': Read-only file system","text":"<p>It seems the directory somehow existed before litmus installation and might be used by some other application. You have to change the mount path from /consul/config to /consul/myconfig in mongo statefulset then you can successfully deploy the litmus.</p>"},{"location":"experiments/troubleshooting/portal/#pre-defined-workflow-bank-of-anthos-showing-bus-error-for-accounts-db-or-ledger-db-pod","title":"Pre-defined workflow Bank Of Anthos showing bus error for accounts-db or ledger-db pod?","text":"<p>Bank of anthos is using PostgreSQL and wouldn't fall back properly to not using huge pages.  With given possible solution if same scenario occur can be resolve.</p> <ul> <li>Modify the docker image to be able to set\u00a0huge_pages = off\u00a0in /usr/share/postgresql/postgresql.conf.sample before initdb was ran (this is what I did).</li> <li>Turn off huge page support on the system (vm.nr_hugepages = 0\u00a0in /etc/sysctl.conf).</li> <li>Fix Postgres's fallback mechanism when\u00a0huge_pages = try\u00a0is set (the default).</li> <li>Modify the k8s manifest to enable huge page support (https://kubernetes.io/docs/tasks/manage-hugepages/scheduling-hugepages/).</li> <li>Modify k8s to show that huge pages are not supported on the system, when they are not enabled for a specific container.</li> </ul>"},{"location":"experiments/troubleshooting/scheduler/","title":"Chaos Scheduler","text":""},{"location":"experiments/troubleshooting/scheduler/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Scheduler not creating chaosengines for type=repeat?</li> </ol>"},{"location":"experiments/troubleshooting/scheduler/#scheduler-not-creating-chaosengines-for-typerepeat","title":"Scheduler not creating chaosengines for type=repeat?","text":"<p>If the ChaosSchedule has been created successfully created in the cluster and ChaosEngine is not being formed, the most common problem is that either start or  end time has been wrongly specified. We should verify the times. We can identify if this is the problem or not by changing to <code>type=now</code>. If the ChaosEngine is  formed successfully then the problem is with the specified time ranges, if ChaosEngine is still not formed, then the problem is with <code>engineSpec</code>. </p>"},{"location":"graphql/v3.10.0/error_response_guide/","title":"Error response guide","text":"<p>All error responses follow the structure outlined below.</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\": \"Error message\",\n      \"path\": [\n        \"Request path\"\n      ]\n    }\n  ],\n  \"data\": {}\n}\n</code></pre>"},{"location":"graphql/v3.10.0/error_response_guide/#field-descriptions","title":"Field Descriptions:","text":"<ul> <li>errors:    An array of error objects. Multiple errors can occur, and each error contains a message and a path field.  Type: <code>Array</code> <ul> <li>message:    A description of the error.  Type: <code>String</code> </li> <li>path:    Indicates the GraphQL or API operation path where the error occurred. It helps in identifying which operation or resolver triggered the error.  Type: <code>Array of Strings</code> </li> </ul> </li> <li>data:    This field contains the data returned from the request. In the event of an error, the field corresponding to the failed operation will be null, while other successful operations (if any) will still return valid data.  Type: <code>Object</code> </li> </ul>"},{"location":"graphql/v3.10.x/error_response_guide/","title":"Error response guide","text":"<p>All error responses follow the structure outlined below.</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\": \"Error message\",\n      \"path\": [\n        \"Request path\"\n      ]\n    }\n  ],\n  \"data\": {}\n}\n</code></pre>"},{"location":"graphql/v3.10.x/error_response_guide/#field-descriptions","title":"Field Descriptions:","text":"<ul> <li>errors:    An array of error objects. Multiple errors can occur, and each error contains a message and a path field.  Type: <code>Array</code> <ul> <li>message:    A description of the error.  Type: <code>String</code> </li> <li>path:    Indicates the GraphQL or API operation path where the error occurred. It helps in identifying which operation or resolver triggered the error.  Type: <code>Array of Strings</code> </li> </ul> </li> <li>data:    This field contains the data returned from the request. In the event of an error, the field corresponding to the failed operation will be null, while other successful operations (if any) will still return valid data.  Type: <code>Object</code> </li> </ul>"},{"location":"graphql/v3.11.0/error_response_guide/","title":"Error response guide","text":"<p>All error responses follow the structure outlined below.</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\": \"Error message\",\n      \"path\": [\n        \"Request path\"\n      ]\n    }\n  ],\n  \"data\": {}\n}\n</code></pre>"},{"location":"graphql/v3.11.0/error_response_guide/#field-descriptions","title":"Field Descriptions:","text":"<ul> <li>errors:    An array of error objects. Multiple errors can occur, and each error contains a message and a path field.  Type: <code>Array</code> <ul> <li>message:    A description of the error.  Type: <code>String</code> </li> <li>path:    Indicates the GraphQL or API operation path where the error occurred. It helps in identifying which operation or resolver triggered the error.  Type: <code>Array of Strings</code> </li> </ul> </li> <li>data:    This field contains the data returned from the request. In the event of an error, the field corresponding to the failed operation will be null, while other successful operations (if any) will still return valid data.  Type: <code>Object</code> </li> </ul>"},{"location":"graphql/v3.11.x/error_response_guide/","title":"Error response guide","text":"<p>All error responses follow the structure outlined below.</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\": \"Error message\",\n      \"path\": [\n        \"Request path\"\n      ]\n    }\n  ],\n  \"data\": {}\n}\n</code></pre>"},{"location":"graphql/v3.11.x/error_response_guide/#field-descriptions","title":"Field Descriptions:","text":"<ul> <li>errors:    An array of error objects. Multiple errors can occur, and each error contains a message and a path field.  Type: <code>Array</code> <ul> <li>message:    A description of the error.  Type: <code>String</code> </li> <li>path:    Indicates the GraphQL or API operation path where the error occurred. It helps in identifying which operation or resolver triggered the error.  Type: <code>Array of Strings</code> </li> </ul> </li> <li>data:    This field contains the data returned from the request. In the event of an error, the field corresponding to the failed operation will be null, while other successful operations (if any) will still return valid data.  Type: <code>Object</code> </li> </ul>"},{"location":"graphql/v3.9.0/error_response_guide/","title":"Error response guide","text":"<p>All error responses follow the structure outlined below.</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\": \"Error message\",\n      \"path\": [\n        \"Request path\"\n      ]\n    }\n  ],\n  \"data\": {}\n}\n</code></pre>"},{"location":"graphql/v3.9.0/error_response_guide/#field-descriptions","title":"Field Descriptions:","text":"<ul> <li>errors:    An array of error objects. Multiple errors can occur, and each error contains a message and a path field.  Type: <code>Array</code> <ul> <li>message:    A description of the error.  Type: <code>String</code> </li> <li>path:    Indicates the GraphQL or API operation path where the error occurred. It helps in identifying which operation or resolver triggered the error.  Type: <code>Array of Strings</code> </li> </ul> </li> <li>data:    This field contains the data returned from the request. In the event of an error, the field corresponding to the failed operation will be null, while other successful operations (if any) will still return valid data.  Type: <code>Object</code> </li> </ul>"}]}