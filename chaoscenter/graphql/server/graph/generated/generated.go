// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Authorized func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Internal   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	ActionPayload struct {
		ExternalData func(childComplexity int) int
		K8sManifest  func(childComplexity int) int
		Namespace    func(childComplexity int) int
		RequestID    func(childComplexity int) int
		RequestType  func(childComplexity int) int
		Username     func(childComplexity int) int
	}

	Annotation struct {
		Categories       func(childComplexity int) int
		ChartDescription func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Repository       func(childComplexity int) int
		Support          func(childComplexity int) int
		Vendor           func(childComplexity int) int
	}

	ChaosExperimentResponse struct {
		CronSyntax            func(childComplexity int) int
		ExperimentDescription func(childComplexity int) int
		ExperimentID          func(childComplexity int) int
		ExperimentName        func(childComplexity int) int
		IsCustomExperiment    func(childComplexity int) int
		ProjectID             func(childComplexity int) int
		Tags                  func(childComplexity int) int
	}

	ChaosHub struct {
		AuthType      func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		CreatedBy     func(childComplexity int) int
		Description   func(childComplexity int) int
		HubType       func(childComplexity int) int
		ID            func(childComplexity int) int
		IsDefault     func(childComplexity int) int
		IsPrivate     func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		LastSyncedAt  func(childComplexity int) int
		Name          func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoBranch    func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Tags          func(childComplexity int) int
		Token         func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UpdatedBy     func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ChaosHubStatus struct {
		AuthType         func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		Description      func(childComplexity int) int
		HubType          func(childComplexity int) int
		ID               func(childComplexity int) int
		IsAvailable      func(childComplexity int) int
		IsDefault        func(childComplexity int) int
		IsPrivate        func(childComplexity int) int
		IsRemoved        func(childComplexity int) int
		LastSyncedAt     func(childComplexity int) int
		Name             func(childComplexity int) int
		Password         func(childComplexity int) int
		RepoBranch       func(childComplexity int) int
		RepoURL          func(childComplexity int) int
		SSHPrivateKey    func(childComplexity int) int
		SSHPublicKey     func(childComplexity int) int
		Tags             func(childComplexity int) int
		Token            func(childComplexity int) int
		TotalExperiments func(childComplexity int) int
		TotalFaults      func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		UpdatedBy        func(childComplexity int) int
		UserName         func(childComplexity int) int
	}

	Chart struct {
		APIVersion  func(childComplexity int) int
		Kind        func(childComplexity int) int
		Metadata    func(childComplexity int) int
		PackageInfo func(childComplexity int) int
		Spec        func(childComplexity int) int
	}

	ConfirmInfraRegistrationResponse struct {
		InfraID          func(childComplexity int) int
		IsInfraConfirmed func(childComplexity int) int
		NewAccessKey     func(childComplexity int) int
	}

	Environment struct {
		CreatedAt     func(childComplexity int) int
		CreatedBy     func(childComplexity int) int
		Description   func(childComplexity int) int
		EnvironmentID func(childComplexity int) int
		InfraIDs      func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		Name          func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		Tags          func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UpdatedBy     func(childComplexity int) int
	}

	EventMetadata struct {
		EnvironmentIdentifier func(childComplexity int) int
		FaultName             func(childComplexity int) int
		ServiceIdentifier     func(childComplexity int) int
	}

	Experiment struct {
		CreatedAt                  func(childComplexity int) int
		CreatedBy                  func(childComplexity int) int
		CronSyntax                 func(childComplexity int) int
		Description                func(childComplexity int) int
		ExperimentID               func(childComplexity int) int
		ExperimentManifest         func(childComplexity int) int
		ExperimentType             func(childComplexity int) int
		Infra                      func(childComplexity int) int
		IsCustomExperiment         func(childComplexity int) int
		IsRemoved                  func(childComplexity int) int
		Name                       func(childComplexity int) int
		ProjectID                  func(childComplexity int) int
		RecentExperimentRunDetails func(childComplexity int) int
		Tags                       func(childComplexity int) int
		UpdatedAt                  func(childComplexity int) int
		UpdatedBy                  func(childComplexity int) int
		Weightages                 func(childComplexity int) int
	}

	ExperimentDetails struct {
		EngineDetails     func(childComplexity int) int
		ExperimentDetails func(childComplexity int) int
	}

	ExperimentRun struct {
		CreatedAt          func(childComplexity int) int
		CreatedBy          func(childComplexity int) int
		ExecutionData      func(childComplexity int) int
		ExperimentID       func(childComplexity int) int
		ExperimentManifest func(childComplexity int) int
		ExperimentName     func(childComplexity int) int
		ExperimentRunID    func(childComplexity int) int
		ExperimentType     func(childComplexity int) int
		FaultsAwaited      func(childComplexity int) int
		FaultsFailed       func(childComplexity int) int
		FaultsNa           func(childComplexity int) int
		FaultsPassed       func(childComplexity int) int
		FaultsStopped      func(childComplexity int) int
		Infra              func(childComplexity int) int
		IsRemoved          func(childComplexity int) int
		Phase              func(childComplexity int) int
		ProjectID          func(childComplexity int) int
		ResiliencyScore    func(childComplexity int) int
		TotalFaults        func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		UpdatedBy          func(childComplexity int) int
		Weightages         func(childComplexity int) int
	}

	Experiments struct {
		Csv  func(childComplexity int) int
		Desc func(childComplexity int) int
		Name func(childComplexity int) int
	}

	FaultDetails struct {
		Csv    func(childComplexity int) int
		Engine func(childComplexity int) int
		Fault  func(childComplexity int) int
	}

	FaultList struct {
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Plan        func(childComplexity int) int
	}

	GetChaosHubStatsResponse struct {
		TotalChaosHubs func(childComplexity int) int
	}

	GetExperimentResponse struct {
		AverageResiliencyScore func(childComplexity int) int
		ExperimentDetails      func(childComplexity int) int
	}

	GetExperimentRunStatsResponse struct {
		TotalCompletedExperimentRuns  func(childComplexity int) int
		TotalErroredExperimentRuns    func(childComplexity int) int
		TotalExperimentRuns           func(childComplexity int) int
		TotalRunningExperimentRuns    func(childComplexity int) int
		TotalStoppedExperimentRuns    func(childComplexity int) int
		TotalTerminatedExperimentRuns func(childComplexity int) int
	}

	GetExperimentStatsResponse struct {
		TotalExpCategorizedByResiliencyScore func(childComplexity int) int
		TotalExperiments                     func(childComplexity int) int
	}

	GetInfraStatsResponse struct {
		TotalActiveInfrastructure        func(childComplexity int) int
		TotalConfirmedInfrastructure     func(childComplexity int) int
		TotalInactiveInfrastructures     func(childComplexity int) int
		TotalInfrastructures             func(childComplexity int) int
		TotalNonConfirmedInfrastructures func(childComplexity int) int
	}

	GitConfigResponse struct {
		AuthType      func(childComplexity int) int
		Branch        func(childComplexity int) int
		Enabled       func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Token         func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ImageRegistry struct {
		EnableRegistry    func(childComplexity int) int
		ImageRegistryName func(childComplexity int) int
		ImageRegistryType func(childComplexity int) int
		ImageRepoName     func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		SecretName        func(childComplexity int) int
		SecretNamespace   func(childComplexity int) int
	}

	ImageRegistryResponse struct {
		CreatedAt         func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		ImageRegistryID   func(childComplexity int) int
		ImageRegistryInfo func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		IsRemoved         func(childComplexity int) int
		ProjectID         func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UpdatedBy         func(childComplexity int) int
	}

	Infra struct {
		CreatedAt               func(childComplexity int) int
		CreatedBy               func(childComplexity int) int
		Description             func(childComplexity int) int
		EnvironmentID           func(childComplexity int) int
		InfraID                 func(childComplexity int) int
		InfraNamespace          func(childComplexity int) int
		InfraNsExists           func(childComplexity int) int
		InfraSaExists           func(childComplexity int) int
		InfraScope              func(childComplexity int) int
		InfraType               func(childComplexity int) int
		IsActive                func(childComplexity int) int
		IsInfraConfirmed        func(childComplexity int) int
		IsRemoved               func(childComplexity int) int
		LastExperimentTimestamp func(childComplexity int) int
		Name                    func(childComplexity int) int
		NoOfExperimentRuns      func(childComplexity int) int
		NoOfExperiments         func(childComplexity int) int
		PlatformName            func(childComplexity int) int
		ProjectID               func(childComplexity int) int
		ServiceAccount          func(childComplexity int) int
		StartTime               func(childComplexity int) int
		Tags                    func(childComplexity int) int
		Token                   func(childComplexity int) int
		UpdateStatus            func(childComplexity int) int
		UpdatedAt               func(childComplexity int) int
		UpdatedBy               func(childComplexity int) int
		Version                 func(childComplexity int) int
	}

	InfraActionResponse struct {
		Action    func(childComplexity int) int
		ProjectID func(childComplexity int) int
	}

	InfraEventResponse struct {
		Description func(childComplexity int) int
		EventID     func(childComplexity int) int
		EventName   func(childComplexity int) int
		EventType   func(childComplexity int) int
		Infra       func(childComplexity int) int
	}

	InfraVersionDetails struct {
		CompatibleVersions func(childComplexity int) int
		LatestVersion      func(childComplexity int) int
	}

	KubeObject struct {
		Data      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	KubeObjectResponse struct {
		InfraID func(childComplexity int) int
		KubeObj func(childComplexity int) int
	}

	Link struct {
		Name func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	ListEnvironmentResponse struct {
		Environments          func(childComplexity int) int
		TotalNoOfEnvironments func(childComplexity int) int
	}

	ListExperimentResponse struct {
		Experiments          func(childComplexity int) int
		TotalNoOfExperiments func(childComplexity int) int
	}

	ListExperimentRunResponse struct {
		ExperimentRuns          func(childComplexity int) int
		TotalNoOfExperimentRuns func(childComplexity int) int
	}

	ListInfraResponse struct {
		Infras          func(childComplexity int) int
		TotalNoOfInfras func(childComplexity int) int
	}

	Maintainer struct {
		Email func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	Metadata struct {
		Annotations func(childComplexity int) int
		Name        func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	Mutation struct {
		AddChaosHub              func(childComplexity int, projectID string, request model.CreateChaosHubRequest) int
		AddRemoteChaosHub        func(childComplexity int, projectID string, request model.CreateRemoteChaosHub) int
		ChaosExperimentRun       func(childComplexity int, request model.ExperimentRunRequest) int
		ConfirmInfraRegistration func(childComplexity int, request model.InfraIdentity) int
		CreateChaosExperiment    func(childComplexity int, request model.ChaosExperimentRequest, projectID string) int
		CreateEnvironment        func(childComplexity int, projectID string, request *model.CreateEnvironmentRequest) int
		CreateImageRegistry      func(childComplexity int, projectID string, imageRegistryInfo model.ImageRegistryInput) int
		DeleteChaosExperiment    func(childComplexity int, experimentID string, experimentRunID *string, projectID string) int
		DeleteChaosHub           func(childComplexity int, projectID string, hubID string) int
		DeleteEnvironment        func(childComplexity int, projectID string, environmentID string) int
		DeleteImageRegistry      func(childComplexity int, imageRegistryID string, projectID string) int
		DeleteInfra              func(childComplexity int, projectID string, infraID string) int
		DisableGitOps            func(childComplexity int, projectID string) int
		EnableGitOps             func(childComplexity int, configurations model.GitConfig) int
		GenerateSSHKey           func(childComplexity int) int
		GetManifestWithInfraID   func(childComplexity int, projectID string, infraID string, accessKey string) int
		GitopsNotifier           func(childComplexity int, clusterInfo model.InfraIdentity, workflowID string) int
		KubeObj                  func(childComplexity int, request model.KubeObjectData) int
		PodLog                   func(childComplexity int, request model.PodLog) int
		RegisterInfra            func(childComplexity int, projectID string, request model.RegisterInfraRequest) int
		RunChaosExperiment       func(childComplexity int, experimentID string, projectID string) int
		SaveChaosExperiment      func(childComplexity int, request model.SaveChaosExperimentRequest, projectID string) int
		SaveChaosHub             func(childComplexity int, projectID string, request model.CreateChaosHubRequest) int
		SyncChaosHub             func(childComplexity int, id string, projectID string) int
		UpdateChaosExperiment    func(childComplexity int, request *model.ChaosExperimentRequest, projectID string) int
		UpdateChaosHub           func(childComplexity int, projectID string, request model.UpdateChaosHubRequest) int
		UpdateEnvironment        func(childComplexity int, projectID string, request *model.UpdateEnvironmentRequest) int
		UpdateGitOps             func(childComplexity int, configurations model.GitConfig) int
		UpdateImageRegistry      func(childComplexity int, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) int
	}

	ObjectData struct {
		Labels func(childComplexity int) int
		Name   func(childComplexity int) int
	}

	PackageInformation struct {
		Experiments func(childComplexity int) int
		PackageName func(childComplexity int) int
	}

	PodLogResponse struct {
		ExperimentRunID func(childComplexity int) int
		Log             func(childComplexity int) int
		PodName         func(childComplexity int) int
		PodType         func(childComplexity int) int
	}

	PredefinedExperimentList struct {
		ExperimentCsv      func(childComplexity int) int
		ExperimentManifest func(childComplexity int) int
		ExperimentName     func(childComplexity int) int
	}

	Provider struct {
		Name func(childComplexity int) int
	}

	Query struct {
		GetChaosFault             func(childComplexity int, projectID string, request model.ExperimentRequest) int
		GetChaosHub               func(childComplexity int, projectID string, chaosHubID string) int
		GetChaosHubStats          func(childComplexity int, projectID string) int
		GetEnvironment            func(childComplexity int, projectID string, environmentID string) int
		GetExperiment             func(childComplexity int, projectID string, experimentID string) int
		GetExperimentRun          func(childComplexity int, projectID string, experimentRunID string) int
		GetExperimentRunStats     func(childComplexity int, projectID string) int
		GetExperimentStats        func(childComplexity int, projectID string) int
		GetGitOpsDetails          func(childComplexity int, projectID string) int
		GetImageRegistry          func(childComplexity int, imageRegistryID string, projectID string) int
		GetInfra                  func(childComplexity int, projectID string, infraID string) int
		GetInfraDetails           func(childComplexity int, infraID string, projectID string) int
		GetInfraManifest          func(childComplexity int, infraID string, upgrade bool, projectID string) int
		GetInfraStats             func(childComplexity int, projectID string) int
		GetPredefinedExperiment   func(childComplexity int, hubID string, experimentName []string, projectID string) int
		GetServerVersion          func(childComplexity int) int
		GetVersionDetails         func(childComplexity int, projectID string) int
		ListChaosFaults           func(childComplexity int, hubID string, projectID string) int
		ListChaosHub              func(childComplexity int, projectID string, request *model.ListChaosHubRequest) int
		ListEnvironments          func(childComplexity int, projectID string, request *model.ListEnvironmentRequest) int
		ListExperiment            func(childComplexity int, projectID string, request model.ListExperimentRequest) int
		ListExperimentRun         func(childComplexity int, projectID string, request model.ListExperimentRunRequest) int
		ListImageRegistry         func(childComplexity int, projectID string) int
		ListInfras                func(childComplexity int, projectID string, request *model.ListInfraRequest) int
		ListPredefinedExperiments func(childComplexity int, hubID string, projectID string) int
	}

	RecentExperimentRun struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		ExperimentRunID func(childComplexity int) int
		Phase           func(childComplexity int) int
		ResiliencyScore func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
	}

	RegisterInfraResponse struct {
		InfraID  func(childComplexity int) int
		Manifest func(childComplexity int) int
		Name     func(childComplexity int) int
		Token    func(childComplexity int) int
	}

	ResilienceScoreCategory struct {
		Count func(childComplexity int) int
		ID    func(childComplexity int) int
	}

	RunChaosExperimentResponse struct {
		NotifyID func(childComplexity int) int
	}

	SSHKey struct {
		PrivateKey func(childComplexity int) int
		PublicKey  func(childComplexity int) int
	}

	ServerVersionResponse struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Spec struct {
		CategoryDescription func(childComplexity int) int
		ChaosExpCRDLink     func(childComplexity int) int
		ChaosType           func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		Experiments         func(childComplexity int) int
		Faults              func(childComplexity int) int
		Keywords            func(childComplexity int) int
		Links               func(childComplexity int) int
		Maintainers         func(childComplexity int) int
		Maturity            func(childComplexity int) int
		MinKubeVersion      func(childComplexity int) int
		Platforms           func(childComplexity int) int
		Provider            func(childComplexity int) int
	}

	StopExperimentRunsRequest struct {
		ExperimentID    func(childComplexity int) int
		ExperimentRunID func(childComplexity int) int
		ProjectID       func(childComplexity int) int
	}

	Subscription struct {
		GetInfraEvents func(childComplexity int, projectID string) int
		GetKubeObject  func(childComplexity int, request model.KubeObjectRequest) int
		GetPodLog      func(childComplexity int, request model.PodLogRequest) int
		InfraConnect   func(childComplexity int, request model.InfraIdentity) int
	}

	UserDetails struct {
		Email    func(childComplexity int) int
		UserID   func(childComplexity int) int
		Username func(childComplexity int) int
	}

	Weightages struct {
		FaultName func(childComplexity int) int
		Weightage func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateChaosExperiment(ctx context.Context, request model.ChaosExperimentRequest, projectID string) (*model.ChaosExperimentResponse, error)
	SaveChaosExperiment(ctx context.Context, request model.SaveChaosExperimentRequest, projectID string) (string, error)
	RunChaosExperiment(ctx context.Context, experimentID string, projectID string) (*model.RunChaosExperimentResponse, error)
	UpdateChaosExperiment(ctx context.Context, request *model.ChaosExperimentRequest, projectID string) (*model.ChaosExperimentResponse, error)
	DeleteChaosExperiment(ctx context.Context, experimentID string, experimentRunID *string, projectID string) (bool, error)
	ChaosExperimentRun(ctx context.Context, request model.ExperimentRunRequest) (string, error)
	RegisterInfra(ctx context.Context, projectID string, request model.RegisterInfraRequest) (*model.RegisterInfraResponse, error)
	ConfirmInfraRegistration(ctx context.Context, request model.InfraIdentity) (*model.ConfirmInfraRegistrationResponse, error)
	DeleteInfra(ctx context.Context, projectID string, infraID string) (string, error)
	GetManifestWithInfraID(ctx context.Context, projectID string, infraID string, accessKey string) (string, error)
	PodLog(ctx context.Context, request model.PodLog) (string, error)
	KubeObj(ctx context.Context, request model.KubeObjectData) (string, error)
	AddChaosHub(ctx context.Context, projectID string, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	AddRemoteChaosHub(ctx context.Context, projectID string, request model.CreateRemoteChaosHub) (*model.ChaosHub, error)
	SaveChaosHub(ctx context.Context, projectID string, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	SyncChaosHub(ctx context.Context, id string, projectID string) (string, error)
	GenerateSSHKey(ctx context.Context) (*model.SSHKey, error)
	UpdateChaosHub(ctx context.Context, projectID string, request model.UpdateChaosHubRequest) (*model.ChaosHub, error)
	DeleteChaosHub(ctx context.Context, projectID string, hubID string) (bool, error)
	CreateEnvironment(ctx context.Context, projectID string, request *model.CreateEnvironmentRequest) (*model.Environment, error)
	UpdateEnvironment(ctx context.Context, projectID string, request *model.UpdateEnvironmentRequest) (string, error)
	DeleteEnvironment(ctx context.Context, projectID string, environmentID string) (string, error)
	GitopsNotifier(ctx context.Context, clusterInfo model.InfraIdentity, workflowID string) (string, error)
	EnableGitOps(ctx context.Context, configurations model.GitConfig) (bool, error)
	DisableGitOps(ctx context.Context, projectID string) (bool, error)
	UpdateGitOps(ctx context.Context, configurations model.GitConfig) (bool, error)
	CreateImageRegistry(ctx context.Context, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	UpdateImageRegistry(ctx context.Context, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	DeleteImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (string, error)
}
type QueryResolver interface {
	GetExperimentRun(ctx context.Context, projectID string, experimentRunID string) (*model.ExperimentRun, error)
	ListExperimentRun(ctx context.Context, projectID string, request model.ListExperimentRunRequest) (*model.ListExperimentRunResponse, error)
	GetExperiment(ctx context.Context, projectID string, experimentID string) (*model.GetExperimentResponse, error)
	ListExperiment(ctx context.Context, projectID string, request model.ListExperimentRequest) (*model.ListExperimentResponse, error)
	GetExperimentRunStats(ctx context.Context, projectID string) (*model.GetExperimentRunStatsResponse, error)
	GetExperimentStats(ctx context.Context, projectID string) (*model.GetExperimentStatsResponse, error)
	GetInfra(ctx context.Context, projectID string, infraID string) (*model.Infra, error)
	ListInfras(ctx context.Context, projectID string, request *model.ListInfraRequest) (*model.ListInfraResponse, error)
	GetInfraDetails(ctx context.Context, infraID string, projectID string) (*model.Infra, error)
	GetInfraManifest(ctx context.Context, infraID string, upgrade bool, projectID string) (string, error)
	GetInfraStats(ctx context.Context, projectID string) (*model.GetInfraStatsResponse, error)
	GetVersionDetails(ctx context.Context, projectID string) (*model.InfraVersionDetails, error)
	GetServerVersion(ctx context.Context) (*model.ServerVersionResponse, error)
	ListChaosFaults(ctx context.Context, hubID string, projectID string) ([]*model.Chart, error)
	GetChaosFault(ctx context.Context, projectID string, request model.ExperimentRequest) (*model.FaultDetails, error)
	ListChaosHub(ctx context.Context, projectID string, request *model.ListChaosHubRequest) ([]*model.ChaosHubStatus, error)
	GetChaosHub(ctx context.Context, projectID string, chaosHubID string) (*model.ChaosHubStatus, error)
	ListPredefinedExperiments(ctx context.Context, hubID string, projectID string) ([]*model.PredefinedExperimentList, error)
	GetPredefinedExperiment(ctx context.Context, hubID string, experimentName []string, projectID string) ([]*model.PredefinedExperimentList, error)
	GetChaosHubStats(ctx context.Context, projectID string) (*model.GetChaosHubStatsResponse, error)
	GetEnvironment(ctx context.Context, projectID string, environmentID string) (*model.Environment, error)
	ListEnvironments(ctx context.Context, projectID string, request *model.ListEnvironmentRequest) (*model.ListEnvironmentResponse, error)
	GetGitOpsDetails(ctx context.Context, projectID string) (*model.GitConfigResponse, error)
	ListImageRegistry(ctx context.Context, projectID string) ([]*model.ImageRegistryResponse, error)
	GetImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (*model.ImageRegistryResponse, error)
}
type SubscriptionResolver interface {
	GetInfraEvents(ctx context.Context, projectID string) (<-chan *model.InfraEventResponse, error)
	InfraConnect(ctx context.Context, request model.InfraIdentity) (<-chan *model.InfraActionResponse, error)
	GetPodLog(ctx context.Context, request model.PodLogRequest) (<-chan *model.PodLogResponse, error)
	GetKubeObject(ctx context.Context, request model.KubeObjectRequest) (<-chan *model.KubeObjectResponse, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ActionPayload.externalData":
		if e.complexity.ActionPayload.ExternalData == nil {
			break
		}

		return e.complexity.ActionPayload.ExternalData(childComplexity), true

	case "ActionPayload.k8sManifest":
		if e.complexity.ActionPayload.K8sManifest == nil {
			break
		}

		return e.complexity.ActionPayload.K8sManifest(childComplexity), true

	case "ActionPayload.namespace":
		if e.complexity.ActionPayload.Namespace == nil {
			break
		}

		return e.complexity.ActionPayload.Namespace(childComplexity), true

	case "ActionPayload.requestID":
		if e.complexity.ActionPayload.RequestID == nil {
			break
		}

		return e.complexity.ActionPayload.RequestID(childComplexity), true

	case "ActionPayload.requestType":
		if e.complexity.ActionPayload.RequestType == nil {
			break
		}

		return e.complexity.ActionPayload.RequestType(childComplexity), true

	case "ActionPayload.username":
		if e.complexity.ActionPayload.Username == nil {
			break
		}

		return e.complexity.ActionPayload.Username(childComplexity), true

	case "Annotation.categories":
		if e.complexity.Annotation.Categories == nil {
			break
		}

		return e.complexity.Annotation.Categories(childComplexity), true

	case "Annotation.chartDescription":
		if e.complexity.Annotation.ChartDescription == nil {
			break
		}

		return e.complexity.Annotation.ChartDescription(childComplexity), true

	case "Annotation.createdAt":
		if e.complexity.Annotation.CreatedAt == nil {
			break
		}

		return e.complexity.Annotation.CreatedAt(childComplexity), true

	case "Annotation.repository":
		if e.complexity.Annotation.Repository == nil {
			break
		}

		return e.complexity.Annotation.Repository(childComplexity), true

	case "Annotation.support":
		if e.complexity.Annotation.Support == nil {
			break
		}

		return e.complexity.Annotation.Support(childComplexity), true

	case "Annotation.vendor":
		if e.complexity.Annotation.Vendor == nil {
			break
		}

		return e.complexity.Annotation.Vendor(childComplexity), true

	case "ChaosExperimentResponse.cronSyntax":
		if e.complexity.ChaosExperimentResponse.CronSyntax == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.CronSyntax(childComplexity), true

	case "ChaosExperimentResponse.experimentDescription":
		if e.complexity.ChaosExperimentResponse.ExperimentDescription == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ExperimentDescription(childComplexity), true

	case "ChaosExperimentResponse.experimentID":
		if e.complexity.ChaosExperimentResponse.ExperimentID == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ExperimentID(childComplexity), true

	case "ChaosExperimentResponse.experimentName":
		if e.complexity.ChaosExperimentResponse.ExperimentName == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ExperimentName(childComplexity), true

	case "ChaosExperimentResponse.isCustomExperiment":
		if e.complexity.ChaosExperimentResponse.IsCustomExperiment == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.IsCustomExperiment(childComplexity), true

	case "ChaosExperimentResponse.projectID":
		if e.complexity.ChaosExperimentResponse.ProjectID == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ProjectID(childComplexity), true

	case "ChaosExperimentResponse.tags":
		if e.complexity.ChaosExperimentResponse.Tags == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.Tags(childComplexity), true

	case "ChaosHub.authType":
		if e.complexity.ChaosHub.AuthType == nil {
			break
		}

		return e.complexity.ChaosHub.AuthType(childComplexity), true

	case "ChaosHub.createdAt":
		if e.complexity.ChaosHub.CreatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.CreatedAt(childComplexity), true

	case "ChaosHub.createdBy":
		if e.complexity.ChaosHub.CreatedBy == nil {
			break
		}

		return e.complexity.ChaosHub.CreatedBy(childComplexity), true

	case "ChaosHub.description":
		if e.complexity.ChaosHub.Description == nil {
			break
		}

		return e.complexity.ChaosHub.Description(childComplexity), true

	case "ChaosHub.hubType":
		if e.complexity.ChaosHub.HubType == nil {
			break
		}

		return e.complexity.ChaosHub.HubType(childComplexity), true

	case "ChaosHub.id":
		if e.complexity.ChaosHub.ID == nil {
			break
		}

		return e.complexity.ChaosHub.ID(childComplexity), true

	case "ChaosHub.isDefault":
		if e.complexity.ChaosHub.IsDefault == nil {
			break
		}

		return e.complexity.ChaosHub.IsDefault(childComplexity), true

	case "ChaosHub.isPrivate":
		if e.complexity.ChaosHub.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHub.IsPrivate(childComplexity), true

	case "ChaosHub.isRemoved":
		if e.complexity.ChaosHub.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHub.IsRemoved(childComplexity), true

	case "ChaosHub.lastSyncedAt":
		if e.complexity.ChaosHub.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHub.LastSyncedAt(childComplexity), true

	case "ChaosHub.name":
		if e.complexity.ChaosHub.Name == nil {
			break
		}

		return e.complexity.ChaosHub.Name(childComplexity), true

	case "ChaosHub.password":
		if e.complexity.ChaosHub.Password == nil {
			break
		}

		return e.complexity.ChaosHub.Password(childComplexity), true

	case "ChaosHub.projectID":
		if e.complexity.ChaosHub.ProjectID == nil {
			break
		}

		return e.complexity.ChaosHub.ProjectID(childComplexity), true

	case "ChaosHub.repoBranch":
		if e.complexity.ChaosHub.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHub.RepoBranch(childComplexity), true

	case "ChaosHub.repoURL":
		if e.complexity.ChaosHub.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHub.RepoURL(childComplexity), true

	case "ChaosHub.sshPrivateKey":
		if e.complexity.ChaosHub.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHub.SSHPrivateKey(childComplexity), true

	case "ChaosHub.tags":
		if e.complexity.ChaosHub.Tags == nil {
			break
		}

		return e.complexity.ChaosHub.Tags(childComplexity), true

	case "ChaosHub.token":
		if e.complexity.ChaosHub.Token == nil {
			break
		}

		return e.complexity.ChaosHub.Token(childComplexity), true

	case "ChaosHub.updatedAt":
		if e.complexity.ChaosHub.UpdatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.UpdatedAt(childComplexity), true

	case "ChaosHub.updatedBy":
		if e.complexity.ChaosHub.UpdatedBy == nil {
			break
		}

		return e.complexity.ChaosHub.UpdatedBy(childComplexity), true

	case "ChaosHub.userName":
		if e.complexity.ChaosHub.UserName == nil {
			break
		}

		return e.complexity.ChaosHub.UserName(childComplexity), true

	case "ChaosHubStatus.authType":
		if e.complexity.ChaosHubStatus.AuthType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.AuthType(childComplexity), true

	case "ChaosHubStatus.createdAt":
		if e.complexity.ChaosHubStatus.CreatedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.CreatedAt(childComplexity), true

	case "ChaosHubStatus.createdBy":
		if e.complexity.ChaosHubStatus.CreatedBy == nil {
			break
		}

		return e.complexity.ChaosHubStatus.CreatedBy(childComplexity), true

	case "ChaosHubStatus.description":
		if e.complexity.ChaosHubStatus.Description == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Description(childComplexity), true

	case "ChaosHubStatus.hubType":
		if e.complexity.ChaosHubStatus.HubType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.HubType(childComplexity), true

	case "ChaosHubStatus.id":
		if e.complexity.ChaosHubStatus.ID == nil {
			break
		}

		return e.complexity.ChaosHubStatus.ID(childComplexity), true

	case "ChaosHubStatus.isAvailable":
		if e.complexity.ChaosHubStatus.IsAvailable == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsAvailable(childComplexity), true

	case "ChaosHubStatus.isDefault":
		if e.complexity.ChaosHubStatus.IsDefault == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsDefault(childComplexity), true

	case "ChaosHubStatus.isPrivate":
		if e.complexity.ChaosHubStatus.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsPrivate(childComplexity), true

	case "ChaosHubStatus.isRemoved":
		if e.complexity.ChaosHubStatus.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsRemoved(childComplexity), true

	case "ChaosHubStatus.lastSyncedAt":
		if e.complexity.ChaosHubStatus.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.LastSyncedAt(childComplexity), true

	case "ChaosHubStatus.name":
		if e.complexity.ChaosHubStatus.Name == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Name(childComplexity), true

	case "ChaosHubStatus.password":
		if e.complexity.ChaosHubStatus.Password == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Password(childComplexity), true

	case "ChaosHubStatus.repoBranch":
		if e.complexity.ChaosHubStatus.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoBranch(childComplexity), true

	case "ChaosHubStatus.repoURL":
		if e.complexity.ChaosHubStatus.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoURL(childComplexity), true

	case "ChaosHubStatus.sshPrivateKey":
		if e.complexity.ChaosHubStatus.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPrivateKey(childComplexity), true

	case "ChaosHubStatus.sshPublicKey":
		if e.complexity.ChaosHubStatus.SSHPublicKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPublicKey(childComplexity), true

	case "ChaosHubStatus.tags":
		if e.complexity.ChaosHubStatus.Tags == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Tags(childComplexity), true

	case "ChaosHubStatus.token":
		if e.complexity.ChaosHubStatus.Token == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Token(childComplexity), true

	case "ChaosHubStatus.totalExperiments":
		if e.complexity.ChaosHubStatus.TotalExperiments == nil {
			break
		}

		return e.complexity.ChaosHubStatus.TotalExperiments(childComplexity), true

	case "ChaosHubStatus.totalFaults":
		if e.complexity.ChaosHubStatus.TotalFaults == nil {
			break
		}

		return e.complexity.ChaosHubStatus.TotalFaults(childComplexity), true

	case "ChaosHubStatus.updatedAt":
		if e.complexity.ChaosHubStatus.UpdatedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UpdatedAt(childComplexity), true

	case "ChaosHubStatus.updatedBy":
		if e.complexity.ChaosHubStatus.UpdatedBy == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UpdatedBy(childComplexity), true

	case "ChaosHubStatus.userName":
		if e.complexity.ChaosHubStatus.UserName == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UserName(childComplexity), true

	case "Chart.apiVersion":
		if e.complexity.Chart.APIVersion == nil {
			break
		}

		return e.complexity.Chart.APIVersion(childComplexity), true

	case "Chart.kind":
		if e.complexity.Chart.Kind == nil {
			break
		}

		return e.complexity.Chart.Kind(childComplexity), true

	case "Chart.metadata":
		if e.complexity.Chart.Metadata == nil {
			break
		}

		return e.complexity.Chart.Metadata(childComplexity), true

	case "Chart.packageInfo":
		if e.complexity.Chart.PackageInfo == nil {
			break
		}

		return e.complexity.Chart.PackageInfo(childComplexity), true

	case "Chart.spec":
		if e.complexity.Chart.Spec == nil {
			break
		}

		return e.complexity.Chart.Spec(childComplexity), true

	case "ConfirmInfraRegistrationResponse.infraID":
		if e.complexity.ConfirmInfraRegistrationResponse.InfraID == nil {
			break
		}

		return e.complexity.ConfirmInfraRegistrationResponse.InfraID(childComplexity), true

	case "ConfirmInfraRegistrationResponse.isInfraConfirmed":
		if e.complexity.ConfirmInfraRegistrationResponse.IsInfraConfirmed == nil {
			break
		}

		return e.complexity.ConfirmInfraRegistrationResponse.IsInfraConfirmed(childComplexity), true

	case "ConfirmInfraRegistrationResponse.newAccessKey":
		if e.complexity.ConfirmInfraRegistrationResponse.NewAccessKey == nil {
			break
		}

		return e.complexity.ConfirmInfraRegistrationResponse.NewAccessKey(childComplexity), true

	case "Environment.createdAt":
		if e.complexity.Environment.CreatedAt == nil {
			break
		}

		return e.complexity.Environment.CreatedAt(childComplexity), true

	case "Environment.createdBy":
		if e.complexity.Environment.CreatedBy == nil {
			break
		}

		return e.complexity.Environment.CreatedBy(childComplexity), true

	case "Environment.description":
		if e.complexity.Environment.Description == nil {
			break
		}

		return e.complexity.Environment.Description(childComplexity), true

	case "Environment.environmentID":
		if e.complexity.Environment.EnvironmentID == nil {
			break
		}

		return e.complexity.Environment.EnvironmentID(childComplexity), true

	case "Environment.infraIDs":
		if e.complexity.Environment.InfraIDs == nil {
			break
		}

		return e.complexity.Environment.InfraIDs(childComplexity), true

	case "Environment.isRemoved":
		if e.complexity.Environment.IsRemoved == nil {
			break
		}

		return e.complexity.Environment.IsRemoved(childComplexity), true

	case "Environment.name":
		if e.complexity.Environment.Name == nil {
			break
		}

		return e.complexity.Environment.Name(childComplexity), true

	case "Environment.projectID":
		if e.complexity.Environment.ProjectID == nil {
			break
		}

		return e.complexity.Environment.ProjectID(childComplexity), true

	case "Environment.tags":
		if e.complexity.Environment.Tags == nil {
			break
		}

		return e.complexity.Environment.Tags(childComplexity), true

	case "Environment.type":
		if e.complexity.Environment.Type == nil {
			break
		}

		return e.complexity.Environment.Type(childComplexity), true

	case "Environment.updatedAt":
		if e.complexity.Environment.UpdatedAt == nil {
			break
		}

		return e.complexity.Environment.UpdatedAt(childComplexity), true

	case "Environment.updatedBy":
		if e.complexity.Environment.UpdatedBy == nil {
			break
		}

		return e.complexity.Environment.UpdatedBy(childComplexity), true

	case "EventMetadata.environmentIdentifier":
		if e.complexity.EventMetadata.EnvironmentIdentifier == nil {
			break
		}

		return e.complexity.EventMetadata.EnvironmentIdentifier(childComplexity), true

	case "EventMetadata.faultName":
		if e.complexity.EventMetadata.FaultName == nil {
			break
		}

		return e.complexity.EventMetadata.FaultName(childComplexity), true

	case "EventMetadata.serviceIdentifier":
		if e.complexity.EventMetadata.ServiceIdentifier == nil {
			break
		}

		return e.complexity.EventMetadata.ServiceIdentifier(childComplexity), true

	case "Experiment.createdAt":
		if e.complexity.Experiment.CreatedAt == nil {
			break
		}

		return e.complexity.Experiment.CreatedAt(childComplexity), true

	case "Experiment.createdBy":
		if e.complexity.Experiment.CreatedBy == nil {
			break
		}

		return e.complexity.Experiment.CreatedBy(childComplexity), true

	case "Experiment.cronSyntax":
		if e.complexity.Experiment.CronSyntax == nil {
			break
		}

		return e.complexity.Experiment.CronSyntax(childComplexity), true

	case "Experiment.description":
		if e.complexity.Experiment.Description == nil {
			break
		}

		return e.complexity.Experiment.Description(childComplexity), true

	case "Experiment.experimentID":
		if e.complexity.Experiment.ExperimentID == nil {
			break
		}

		return e.complexity.Experiment.ExperimentID(childComplexity), true

	case "Experiment.experimentManifest":
		if e.complexity.Experiment.ExperimentManifest == nil {
			break
		}

		return e.complexity.Experiment.ExperimentManifest(childComplexity), true

	case "Experiment.experimentType":
		if e.complexity.Experiment.ExperimentType == nil {
			break
		}

		return e.complexity.Experiment.ExperimentType(childComplexity), true

	case "Experiment.infra":
		if e.complexity.Experiment.Infra == nil {
			break
		}

		return e.complexity.Experiment.Infra(childComplexity), true

	case "Experiment.isCustomExperiment":
		if e.complexity.Experiment.IsCustomExperiment == nil {
			break
		}

		return e.complexity.Experiment.IsCustomExperiment(childComplexity), true

	case "Experiment.isRemoved":
		if e.complexity.Experiment.IsRemoved == nil {
			break
		}

		return e.complexity.Experiment.IsRemoved(childComplexity), true

	case "Experiment.name":
		if e.complexity.Experiment.Name == nil {
			break
		}

		return e.complexity.Experiment.Name(childComplexity), true

	case "Experiment.projectID":
		if e.complexity.Experiment.ProjectID == nil {
			break
		}

		return e.complexity.Experiment.ProjectID(childComplexity), true

	case "Experiment.recentExperimentRunDetails":
		if e.complexity.Experiment.RecentExperimentRunDetails == nil {
			break
		}

		return e.complexity.Experiment.RecentExperimentRunDetails(childComplexity), true

	case "Experiment.tags":
		if e.complexity.Experiment.Tags == nil {
			break
		}

		return e.complexity.Experiment.Tags(childComplexity), true

	case "Experiment.updatedAt":
		if e.complexity.Experiment.UpdatedAt == nil {
			break
		}

		return e.complexity.Experiment.UpdatedAt(childComplexity), true

	case "Experiment.updatedBy":
		if e.complexity.Experiment.UpdatedBy == nil {
			break
		}

		return e.complexity.Experiment.UpdatedBy(childComplexity), true

	case "Experiment.weightages":
		if e.complexity.Experiment.Weightages == nil {
			break
		}

		return e.complexity.Experiment.Weightages(childComplexity), true

	case "ExperimentDetails.engineDetails":
		if e.complexity.ExperimentDetails.EngineDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.EngineDetails(childComplexity), true

	case "ExperimentDetails.experimentDetails":
		if e.complexity.ExperimentDetails.ExperimentDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.ExperimentDetails(childComplexity), true

	case "ExperimentRun.createdAt":
		if e.complexity.ExperimentRun.CreatedAt == nil {
			break
		}

		return e.complexity.ExperimentRun.CreatedAt(childComplexity), true

	case "ExperimentRun.createdBy":
		if e.complexity.ExperimentRun.CreatedBy == nil {
			break
		}

		return e.complexity.ExperimentRun.CreatedBy(childComplexity), true

	case "ExperimentRun.executionData":
		if e.complexity.ExperimentRun.ExecutionData == nil {
			break
		}

		return e.complexity.ExperimentRun.ExecutionData(childComplexity), true

	case "ExperimentRun.experimentID":
		if e.complexity.ExperimentRun.ExperimentID == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentID(childComplexity), true

	case "ExperimentRun.experimentManifest":
		if e.complexity.ExperimentRun.ExperimentManifest == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentManifest(childComplexity), true

	case "ExperimentRun.experimentName":
		if e.complexity.ExperimentRun.ExperimentName == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentName(childComplexity), true

	case "ExperimentRun.experimentRunID":
		if e.complexity.ExperimentRun.ExperimentRunID == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentRunID(childComplexity), true

	case "ExperimentRun.experimentType":
		if e.complexity.ExperimentRun.ExperimentType == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentType(childComplexity), true

	case "ExperimentRun.faultsAwaited":
		if e.complexity.ExperimentRun.FaultsAwaited == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsAwaited(childComplexity), true

	case "ExperimentRun.faultsFailed":
		if e.complexity.ExperimentRun.FaultsFailed == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsFailed(childComplexity), true

	case "ExperimentRun.faultsNa":
		if e.complexity.ExperimentRun.FaultsNa == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsNa(childComplexity), true

	case "ExperimentRun.faultsPassed":
		if e.complexity.ExperimentRun.FaultsPassed == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsPassed(childComplexity), true

	case "ExperimentRun.faultsStopped":
		if e.complexity.ExperimentRun.FaultsStopped == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsStopped(childComplexity), true

	case "ExperimentRun.infra":
		if e.complexity.ExperimentRun.Infra == nil {
			break
		}

		return e.complexity.ExperimentRun.Infra(childComplexity), true

	case "ExperimentRun.isRemoved":
		if e.complexity.ExperimentRun.IsRemoved == nil {
			break
		}

		return e.complexity.ExperimentRun.IsRemoved(childComplexity), true

	case "ExperimentRun.phase":
		if e.complexity.ExperimentRun.Phase == nil {
			break
		}

		return e.complexity.ExperimentRun.Phase(childComplexity), true

	case "ExperimentRun.projectID":
		if e.complexity.ExperimentRun.ProjectID == nil {
			break
		}

		return e.complexity.ExperimentRun.ProjectID(childComplexity), true

	case "ExperimentRun.resiliencyScore":
		if e.complexity.ExperimentRun.ResiliencyScore == nil {
			break
		}

		return e.complexity.ExperimentRun.ResiliencyScore(childComplexity), true

	case "ExperimentRun.totalFaults":
		if e.complexity.ExperimentRun.TotalFaults == nil {
			break
		}

		return e.complexity.ExperimentRun.TotalFaults(childComplexity), true

	case "ExperimentRun.updatedAt":
		if e.complexity.ExperimentRun.UpdatedAt == nil {
			break
		}

		return e.complexity.ExperimentRun.UpdatedAt(childComplexity), true

	case "ExperimentRun.updatedBy":
		if e.complexity.ExperimentRun.UpdatedBy == nil {
			break
		}

		return e.complexity.ExperimentRun.UpdatedBy(childComplexity), true

	case "ExperimentRun.weightages":
		if e.complexity.ExperimentRun.Weightages == nil {
			break
		}

		return e.complexity.ExperimentRun.Weightages(childComplexity), true

	case "Experiments.CSV":
		if e.complexity.Experiments.Csv == nil {
			break
		}

		return e.complexity.Experiments.Csv(childComplexity), true

	case "Experiments.desc":
		if e.complexity.Experiments.Desc == nil {
			break
		}

		return e.complexity.Experiments.Desc(childComplexity), true

	case "Experiments.name":
		if e.complexity.Experiments.Name == nil {
			break
		}

		return e.complexity.Experiments.Name(childComplexity), true

	case "FaultDetails.csv":
		if e.complexity.FaultDetails.Csv == nil {
			break
		}

		return e.complexity.FaultDetails.Csv(childComplexity), true

	case "FaultDetails.engine":
		if e.complexity.FaultDetails.Engine == nil {
			break
		}

		return e.complexity.FaultDetails.Engine(childComplexity), true

	case "FaultDetails.fault":
		if e.complexity.FaultDetails.Fault == nil {
			break
		}

		return e.complexity.FaultDetails.Fault(childComplexity), true

	case "FaultList.description":
		if e.complexity.FaultList.Description == nil {
			break
		}

		return e.complexity.FaultList.Description(childComplexity), true

	case "FaultList.displayName":
		if e.complexity.FaultList.DisplayName == nil {
			break
		}

		return e.complexity.FaultList.DisplayName(childComplexity), true

	case "FaultList.name":
		if e.complexity.FaultList.Name == nil {
			break
		}

		return e.complexity.FaultList.Name(childComplexity), true

	case "FaultList.plan":
		if e.complexity.FaultList.Plan == nil {
			break
		}

		return e.complexity.FaultList.Plan(childComplexity), true

	case "GetChaosHubStatsResponse.totalChaosHubs":
		if e.complexity.GetChaosHubStatsResponse.TotalChaosHubs == nil {
			break
		}

		return e.complexity.GetChaosHubStatsResponse.TotalChaosHubs(childComplexity), true

	case "GetExperimentResponse.averageResiliencyScore":
		if e.complexity.GetExperimentResponse.AverageResiliencyScore == nil {
			break
		}

		return e.complexity.GetExperimentResponse.AverageResiliencyScore(childComplexity), true

	case "GetExperimentResponse.experimentDetails":
		if e.complexity.GetExperimentResponse.ExperimentDetails == nil {
			break
		}

		return e.complexity.GetExperimentResponse.ExperimentDetails(childComplexity), true

	case "GetExperimentRunStatsResponse.totalCompletedExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalCompletedExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalCompletedExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalErroredExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalErroredExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalErroredExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalRunningExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalRunningExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalRunningExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalStoppedExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalStoppedExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalStoppedExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalTerminatedExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalTerminatedExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalTerminatedExperimentRuns(childComplexity), true

	case "GetExperimentStatsResponse.totalExpCategorizedByResiliencyScore":
		if e.complexity.GetExperimentStatsResponse.TotalExpCategorizedByResiliencyScore == nil {
			break
		}

		return e.complexity.GetExperimentStatsResponse.TotalExpCategorizedByResiliencyScore(childComplexity), true

	case "GetExperimentStatsResponse.totalExperiments":
		if e.complexity.GetExperimentStatsResponse.TotalExperiments == nil {
			break
		}

		return e.complexity.GetExperimentStatsResponse.TotalExperiments(childComplexity), true

	case "GetInfraStatsResponse.totalActiveInfrastructure":
		if e.complexity.GetInfraStatsResponse.TotalActiveInfrastructure == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalActiveInfrastructure(childComplexity), true

	case "GetInfraStatsResponse.totalConfirmedInfrastructure":
		if e.complexity.GetInfraStatsResponse.TotalConfirmedInfrastructure == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalConfirmedInfrastructure(childComplexity), true

	case "GetInfraStatsResponse.totalInactiveInfrastructures":
		if e.complexity.GetInfraStatsResponse.TotalInactiveInfrastructures == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalInactiveInfrastructures(childComplexity), true

	case "GetInfraStatsResponse.totalInfrastructures":
		if e.complexity.GetInfraStatsResponse.TotalInfrastructures == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalInfrastructures(childComplexity), true

	case "GetInfraStatsResponse.totalNonConfirmedInfrastructures":
		if e.complexity.GetInfraStatsResponse.TotalNonConfirmedInfrastructures == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalNonConfirmedInfrastructures(childComplexity), true

	case "GitConfigResponse.authType":
		if e.complexity.GitConfigResponse.AuthType == nil {
			break
		}

		return e.complexity.GitConfigResponse.AuthType(childComplexity), true

	case "GitConfigResponse.branch":
		if e.complexity.GitConfigResponse.Branch == nil {
			break
		}

		return e.complexity.GitConfigResponse.Branch(childComplexity), true

	case "GitConfigResponse.enabled":
		if e.complexity.GitConfigResponse.Enabled == nil {
			break
		}

		return e.complexity.GitConfigResponse.Enabled(childComplexity), true

	case "GitConfigResponse.password":
		if e.complexity.GitConfigResponse.Password == nil {
			break
		}

		return e.complexity.GitConfigResponse.Password(childComplexity), true

	case "GitConfigResponse.projectID":
		if e.complexity.GitConfigResponse.ProjectID == nil {
			break
		}

		return e.complexity.GitConfigResponse.ProjectID(childComplexity), true

	case "GitConfigResponse.repoURL":
		if e.complexity.GitConfigResponse.RepoURL == nil {
			break
		}

		return e.complexity.GitConfigResponse.RepoURL(childComplexity), true

	case "GitConfigResponse.sshPrivateKey":
		if e.complexity.GitConfigResponse.SSHPrivateKey == nil {
			break
		}

		return e.complexity.GitConfigResponse.SSHPrivateKey(childComplexity), true

	case "GitConfigResponse.token":
		if e.complexity.GitConfigResponse.Token == nil {
			break
		}

		return e.complexity.GitConfigResponse.Token(childComplexity), true

	case "GitConfigResponse.userName":
		if e.complexity.GitConfigResponse.UserName == nil {
			break
		}

		return e.complexity.GitConfigResponse.UserName(childComplexity), true

	case "ImageRegistry.enableRegistry":
		if e.complexity.ImageRegistry.EnableRegistry == nil {
			break
		}

		return e.complexity.ImageRegistry.EnableRegistry(childComplexity), true

	case "ImageRegistry.imageRegistryName":
		if e.complexity.ImageRegistry.ImageRegistryName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryName(childComplexity), true

	case "ImageRegistry.imageRegistryType":
		if e.complexity.ImageRegistry.ImageRegistryType == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryType(childComplexity), true

	case "ImageRegistry.imageRepoName":
		if e.complexity.ImageRegistry.ImageRepoName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRepoName(childComplexity), true

	case "ImageRegistry.isDefault":
		if e.complexity.ImageRegistry.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistry.IsDefault(childComplexity), true

	case "ImageRegistry.secretName":
		if e.complexity.ImageRegistry.SecretName == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretName(childComplexity), true

	case "ImageRegistry.secretNamespace":
		if e.complexity.ImageRegistry.SecretNamespace == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretNamespace(childComplexity), true

	case "ImageRegistryResponse.createdAt":
		if e.complexity.ImageRegistryResponse.CreatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.CreatedAt(childComplexity), true

	case "ImageRegistryResponse.createdBy":
		if e.complexity.ImageRegistryResponse.CreatedBy == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.CreatedBy(childComplexity), true

	case "ImageRegistryResponse.imageRegistryID":
		if e.complexity.ImageRegistryResponse.ImageRegistryID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryID(childComplexity), true

	case "ImageRegistryResponse.imageRegistryInfo":
		if e.complexity.ImageRegistryResponse.ImageRegistryInfo == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryInfo(childComplexity), true

	case "ImageRegistryResponse.isDefault":
		if e.complexity.ImageRegistryResponse.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsDefault(childComplexity), true

	case "ImageRegistryResponse.isRemoved":
		if e.complexity.ImageRegistryResponse.IsRemoved == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsRemoved(childComplexity), true

	case "ImageRegistryResponse.projectID":
		if e.complexity.ImageRegistryResponse.ProjectID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ProjectID(childComplexity), true

	case "ImageRegistryResponse.updatedAt":
		if e.complexity.ImageRegistryResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.UpdatedAt(childComplexity), true

	case "ImageRegistryResponse.updatedBy":
		if e.complexity.ImageRegistryResponse.UpdatedBy == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.UpdatedBy(childComplexity), true

	case "Infra.createdAt":
		if e.complexity.Infra.CreatedAt == nil {
			break
		}

		return e.complexity.Infra.CreatedAt(childComplexity), true

	case "Infra.createdBy":
		if e.complexity.Infra.CreatedBy == nil {
			break
		}

		return e.complexity.Infra.CreatedBy(childComplexity), true

	case "Infra.description":
		if e.complexity.Infra.Description == nil {
			break
		}

		return e.complexity.Infra.Description(childComplexity), true

	case "Infra.environmentID":
		if e.complexity.Infra.EnvironmentID == nil {
			break
		}

		return e.complexity.Infra.EnvironmentID(childComplexity), true

	case "Infra.infraID":
		if e.complexity.Infra.InfraID == nil {
			break
		}

		return e.complexity.Infra.InfraID(childComplexity), true

	case "Infra.infraNamespace":
		if e.complexity.Infra.InfraNamespace == nil {
			break
		}

		return e.complexity.Infra.InfraNamespace(childComplexity), true

	case "Infra.infraNsExists":
		if e.complexity.Infra.InfraNsExists == nil {
			break
		}

		return e.complexity.Infra.InfraNsExists(childComplexity), true

	case "Infra.infraSaExists":
		if e.complexity.Infra.InfraSaExists == nil {
			break
		}

		return e.complexity.Infra.InfraSaExists(childComplexity), true

	case "Infra.infraScope":
		if e.complexity.Infra.InfraScope == nil {
			break
		}

		return e.complexity.Infra.InfraScope(childComplexity), true

	case "Infra.infraType":
		if e.complexity.Infra.InfraType == nil {
			break
		}

		return e.complexity.Infra.InfraType(childComplexity), true

	case "Infra.isActive":
		if e.complexity.Infra.IsActive == nil {
			break
		}

		return e.complexity.Infra.IsActive(childComplexity), true

	case "Infra.isInfraConfirmed":
		if e.complexity.Infra.IsInfraConfirmed == nil {
			break
		}

		return e.complexity.Infra.IsInfraConfirmed(childComplexity), true

	case "Infra.isRemoved":
		if e.complexity.Infra.IsRemoved == nil {
			break
		}

		return e.complexity.Infra.IsRemoved(childComplexity), true

	case "Infra.lastExperimentTimestamp":
		if e.complexity.Infra.LastExperimentTimestamp == nil {
			break
		}

		return e.complexity.Infra.LastExperimentTimestamp(childComplexity), true

	case "Infra.name":
		if e.complexity.Infra.Name == nil {
			break
		}

		return e.complexity.Infra.Name(childComplexity), true

	case "Infra.noOfExperimentRuns":
		if e.complexity.Infra.NoOfExperimentRuns == nil {
			break
		}

		return e.complexity.Infra.NoOfExperimentRuns(childComplexity), true

	case "Infra.noOfExperiments":
		if e.complexity.Infra.NoOfExperiments == nil {
			break
		}

		return e.complexity.Infra.NoOfExperiments(childComplexity), true

	case "Infra.platformName":
		if e.complexity.Infra.PlatformName == nil {
			break
		}

		return e.complexity.Infra.PlatformName(childComplexity), true

	case "Infra.projectID":
		if e.complexity.Infra.ProjectID == nil {
			break
		}

		return e.complexity.Infra.ProjectID(childComplexity), true

	case "Infra.serviceAccount":
		if e.complexity.Infra.ServiceAccount == nil {
			break
		}

		return e.complexity.Infra.ServiceAccount(childComplexity), true

	case "Infra.startTime":
		if e.complexity.Infra.StartTime == nil {
			break
		}

		return e.complexity.Infra.StartTime(childComplexity), true

	case "Infra.tags":
		if e.complexity.Infra.Tags == nil {
			break
		}

		return e.complexity.Infra.Tags(childComplexity), true

	case "Infra.token":
		if e.complexity.Infra.Token == nil {
			break
		}

		return e.complexity.Infra.Token(childComplexity), true

	case "Infra.updateStatus":
		if e.complexity.Infra.UpdateStatus == nil {
			break
		}

		return e.complexity.Infra.UpdateStatus(childComplexity), true

	case "Infra.updatedAt":
		if e.complexity.Infra.UpdatedAt == nil {
			break
		}

		return e.complexity.Infra.UpdatedAt(childComplexity), true

	case "Infra.updatedBy":
		if e.complexity.Infra.UpdatedBy == nil {
			break
		}

		return e.complexity.Infra.UpdatedBy(childComplexity), true

	case "Infra.version":
		if e.complexity.Infra.Version == nil {
			break
		}

		return e.complexity.Infra.Version(childComplexity), true

	case "InfraActionResponse.action":
		if e.complexity.InfraActionResponse.Action == nil {
			break
		}

		return e.complexity.InfraActionResponse.Action(childComplexity), true

	case "InfraActionResponse.projectID":
		if e.complexity.InfraActionResponse.ProjectID == nil {
			break
		}

		return e.complexity.InfraActionResponse.ProjectID(childComplexity), true

	case "InfraEventResponse.description":
		if e.complexity.InfraEventResponse.Description == nil {
			break
		}

		return e.complexity.InfraEventResponse.Description(childComplexity), true

	case "InfraEventResponse.eventID":
		if e.complexity.InfraEventResponse.EventID == nil {
			break
		}

		return e.complexity.InfraEventResponse.EventID(childComplexity), true

	case "InfraEventResponse.eventName":
		if e.complexity.InfraEventResponse.EventName == nil {
			break
		}

		return e.complexity.InfraEventResponse.EventName(childComplexity), true

	case "InfraEventResponse.eventType":
		if e.complexity.InfraEventResponse.EventType == nil {
			break
		}

		return e.complexity.InfraEventResponse.EventType(childComplexity), true

	case "InfraEventResponse.infra":
		if e.complexity.InfraEventResponse.Infra == nil {
			break
		}

		return e.complexity.InfraEventResponse.Infra(childComplexity), true

	case "InfraVersionDetails.compatibleVersions":
		if e.complexity.InfraVersionDetails.CompatibleVersions == nil {
			break
		}

		return e.complexity.InfraVersionDetails.CompatibleVersions(childComplexity), true

	case "InfraVersionDetails.latestVersion":
		if e.complexity.InfraVersionDetails.LatestVersion == nil {
			break
		}

		return e.complexity.InfraVersionDetails.LatestVersion(childComplexity), true

	case "KubeObject.data":
		if e.complexity.KubeObject.Data == nil {
			break
		}

		return e.complexity.KubeObject.Data(childComplexity), true

	case "KubeObject.namespace":
		if e.complexity.KubeObject.Namespace == nil {
			break
		}

		return e.complexity.KubeObject.Namespace(childComplexity), true

	case "KubeObjectResponse.infraID":
		if e.complexity.KubeObjectResponse.InfraID == nil {
			break
		}

		return e.complexity.KubeObjectResponse.InfraID(childComplexity), true

	case "KubeObjectResponse.kubeObj":
		if e.complexity.KubeObjectResponse.KubeObj == nil {
			break
		}

		return e.complexity.KubeObjectResponse.KubeObj(childComplexity), true

	case "Link.name":
		if e.complexity.Link.Name == nil {
			break
		}

		return e.complexity.Link.Name(childComplexity), true

	case "Link.url":
		if e.complexity.Link.URL == nil {
			break
		}

		return e.complexity.Link.URL(childComplexity), true

	case "ListEnvironmentResponse.environments":
		if e.complexity.ListEnvironmentResponse.Environments == nil {
			break
		}

		return e.complexity.ListEnvironmentResponse.Environments(childComplexity), true

	case "ListEnvironmentResponse.totalNoOfEnvironments":
		if e.complexity.ListEnvironmentResponse.TotalNoOfEnvironments == nil {
			break
		}

		return e.complexity.ListEnvironmentResponse.TotalNoOfEnvironments(childComplexity), true

	case "ListExperimentResponse.experiments":
		if e.complexity.ListExperimentResponse.Experiments == nil {
			break
		}

		return e.complexity.ListExperimentResponse.Experiments(childComplexity), true

	case "ListExperimentResponse.totalNoOfExperiments":
		if e.complexity.ListExperimentResponse.TotalNoOfExperiments == nil {
			break
		}

		return e.complexity.ListExperimentResponse.TotalNoOfExperiments(childComplexity), true

	case "ListExperimentRunResponse.experimentRuns":
		if e.complexity.ListExperimentRunResponse.ExperimentRuns == nil {
			break
		}

		return e.complexity.ListExperimentRunResponse.ExperimentRuns(childComplexity), true

	case "ListExperimentRunResponse.totalNoOfExperimentRuns":
		if e.complexity.ListExperimentRunResponse.TotalNoOfExperimentRuns == nil {
			break
		}

		return e.complexity.ListExperimentRunResponse.TotalNoOfExperimentRuns(childComplexity), true

	case "ListInfraResponse.infras":
		if e.complexity.ListInfraResponse.Infras == nil {
			break
		}

		return e.complexity.ListInfraResponse.Infras(childComplexity), true

	case "ListInfraResponse.totalNoOfInfras":
		if e.complexity.ListInfraResponse.TotalNoOfInfras == nil {
			break
		}

		return e.complexity.ListInfraResponse.TotalNoOfInfras(childComplexity), true

	case "Maintainer.email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Metadata.annotations":
		if e.complexity.Metadata.Annotations == nil {
			break
		}

		return e.complexity.Metadata.Annotations(childComplexity), true

	case "Metadata.name":
		if e.complexity.Metadata.Name == nil {
			break
		}

		return e.complexity.Metadata.Name(childComplexity), true

	case "Metadata.version":
		if e.complexity.Metadata.Version == nil {
			break
		}

		return e.complexity.Metadata.Version(childComplexity), true

	case "Mutation.addChaosHub":
		if e.complexity.Mutation.AddChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.addRemoteChaosHub":
		if e.complexity.Mutation.AddRemoteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addRemoteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRemoteChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.CreateRemoteChaosHub)), true

	case "Mutation.chaosExperimentRun":
		if e.complexity.Mutation.ChaosExperimentRun == nil {
			break
		}

		args, err := ec.field_Mutation_chaosExperimentRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChaosExperimentRun(childComplexity, args["request"].(model.ExperimentRunRequest)), true

	case "Mutation.confirmInfraRegistration":
		if e.complexity.Mutation.ConfirmInfraRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_confirmInfraRegistration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmInfraRegistration(childComplexity, args["request"].(model.InfraIdentity)), true

	case "Mutation.createChaosExperiment":
		if e.complexity.Mutation.CreateChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_createChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChaosExperiment(childComplexity, args["request"].(model.ChaosExperimentRequest), args["projectID"].(string)), true

	case "Mutation.createEnvironment":
		if e.complexity.Mutation.CreateEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_createEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEnvironment(childComplexity, args["projectID"].(string), args["request"].(*model.CreateEnvironmentRequest)), true

	case "Mutation.createImageRegistry":
		if e.complexity.Mutation.CreateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_createImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateImageRegistry(childComplexity, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "Mutation.deleteChaosExperiment":
		if e.complexity.Mutation.DeleteChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosExperiment(childComplexity, args["experimentID"].(string), args["experimentRunID"].(*string), args["projectID"].(string)), true

	case "Mutation.deleteChaosHub":
		if e.complexity.Mutation.DeleteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosHub(childComplexity, args["projectID"].(string), args["hubID"].(string)), true

	case "Mutation.deleteEnvironment":
		if e.complexity.Mutation.DeleteEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEnvironment(childComplexity, args["projectID"].(string), args["environmentID"].(string)), true

	case "Mutation.deleteImageRegistry":
		if e.complexity.Mutation.DeleteImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_deleteImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Mutation.deleteInfra":
		if e.complexity.Mutation.DeleteInfra == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInfra_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInfra(childComplexity, args["projectID"].(string), args["infraID"].(string)), true

	case "Mutation.disableGitOps":
		if e.complexity.Mutation.DisableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_disableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableGitOps(childComplexity, args["projectID"].(string)), true

	case "Mutation.enableGitOps":
		if e.complexity.Mutation.EnableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_enableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableGitOps(childComplexity, args["configurations"].(model.GitConfig)), true

	case "Mutation.generateSSHKey":
		if e.complexity.Mutation.GenerateSSHKey == nil {
			break
		}

		return e.complexity.Mutation.GenerateSSHKey(childComplexity), true

	case "Mutation.getManifestWithInfraID":
		if e.complexity.Mutation.GetManifestWithInfraID == nil {
			break
		}

		args, err := ec.field_Mutation_getManifestWithInfraID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetManifestWithInfraID(childComplexity, args["projectID"].(string), args["infraID"].(string), args["accessKey"].(string)), true

	case "Mutation.gitopsNotifier":
		if e.complexity.Mutation.GitopsNotifier == nil {
			break
		}

		args, err := ec.field_Mutation_gitopsNotifier_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GitopsNotifier(childComplexity, args["clusterInfo"].(model.InfraIdentity), args["workflowID"].(string)), true

	case "Mutation.kubeObj":
		if e.complexity.Mutation.KubeObj == nil {
			break
		}

		args, err := ec.field_Mutation_kubeObj_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.KubeObj(childComplexity, args["request"].(model.KubeObjectData)), true

	case "Mutation.podLog":
		if e.complexity.Mutation.PodLog == nil {
			break
		}

		args, err := ec.field_Mutation_podLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PodLog(childComplexity, args["request"].(model.PodLog)), true

	case "Mutation.registerInfra":
		if e.complexity.Mutation.RegisterInfra == nil {
			break
		}

		args, err := ec.field_Mutation_registerInfra_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterInfra(childComplexity, args["projectID"].(string), args["request"].(model.RegisterInfraRequest)), true

	case "Mutation.runChaosExperiment":
		if e.complexity.Mutation.RunChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_runChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RunChaosExperiment(childComplexity, args["experimentID"].(string), args["projectID"].(string)), true

	case "Mutation.saveChaosExperiment":
		if e.complexity.Mutation.SaveChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_saveChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveChaosExperiment(childComplexity, args["request"].(model.SaveChaosExperimentRequest), args["projectID"].(string)), true

	case "Mutation.saveChaosHub":
		if e.complexity.Mutation.SaveChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_saveChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.syncChaosHub":
		if e.complexity.Mutation.SyncChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_syncChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncChaosHub(childComplexity, args["id"].(string), args["projectID"].(string)), true

	case "Mutation.updateChaosExperiment":
		if e.complexity.Mutation.UpdateChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosExperiment(childComplexity, args["request"].(*model.ChaosExperimentRequest), args["projectID"].(string)), true

	case "Mutation.updateChaosHub":
		if e.complexity.Mutation.UpdateChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.UpdateChaosHubRequest)), true

	case "Mutation.updateEnvironment":
		if e.complexity.Mutation.UpdateEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_updateEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEnvironment(childComplexity, args["projectID"].(string), args["request"].(*model.UpdateEnvironmentRequest)), true

	case "Mutation.updateGitOps":
		if e.complexity.Mutation.UpdateGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_updateGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGitOps(childComplexity, args["configurations"].(model.GitConfig)), true

	case "Mutation.updateImageRegistry":
		if e.complexity.Mutation.UpdateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_updateImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "ObjectData.labels":
		if e.complexity.ObjectData.Labels == nil {
			break
		}

		return e.complexity.ObjectData.Labels(childComplexity), true

	case "ObjectData.name":
		if e.complexity.ObjectData.Name == nil {
			break
		}

		return e.complexity.ObjectData.Name(childComplexity), true

	case "PackageInformation.experiments":
		if e.complexity.PackageInformation.Experiments == nil {
			break
		}

		return e.complexity.PackageInformation.Experiments(childComplexity), true

	case "PackageInformation.packageName":
		if e.complexity.PackageInformation.PackageName == nil {
			break
		}

		return e.complexity.PackageInformation.PackageName(childComplexity), true

	case "PodLogResponse.experimentRunID":
		if e.complexity.PodLogResponse.ExperimentRunID == nil {
			break
		}

		return e.complexity.PodLogResponse.ExperimentRunID(childComplexity), true

	case "PodLogResponse.log":
		if e.complexity.PodLogResponse.Log == nil {
			break
		}

		return e.complexity.PodLogResponse.Log(childComplexity), true

	case "PodLogResponse.podName":
		if e.complexity.PodLogResponse.PodName == nil {
			break
		}

		return e.complexity.PodLogResponse.PodName(childComplexity), true

	case "PodLogResponse.podType":
		if e.complexity.PodLogResponse.PodType == nil {
			break
		}

		return e.complexity.PodLogResponse.PodType(childComplexity), true

	case "PredefinedExperimentList.experimentCSV":
		if e.complexity.PredefinedExperimentList.ExperimentCsv == nil {
			break
		}

		return e.complexity.PredefinedExperimentList.ExperimentCsv(childComplexity), true

	case "PredefinedExperimentList.experimentManifest":
		if e.complexity.PredefinedExperimentList.ExperimentManifest == nil {
			break
		}

		return e.complexity.PredefinedExperimentList.ExperimentManifest(childComplexity), true

	case "PredefinedExperimentList.experimentName":
		if e.complexity.PredefinedExperimentList.ExperimentName == nil {
			break
		}

		return e.complexity.PredefinedExperimentList.ExperimentName(childComplexity), true

	case "Provider.name":
		if e.complexity.Provider.Name == nil {
			break
		}

		return e.complexity.Provider.Name(childComplexity), true

	case "Query.getChaosFault":
		if e.complexity.Query.GetChaosFault == nil {
			break
		}

		args, err := ec.field_Query_getChaosFault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChaosFault(childComplexity, args["projectID"].(string), args["request"].(model.ExperimentRequest)), true

	case "Query.getChaosHub":
		if e.complexity.Query.GetChaosHub == nil {
			break
		}

		args, err := ec.field_Query_getChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChaosHub(childComplexity, args["projectID"].(string), args["chaosHubID"].(string)), true

	case "Query.getChaosHubStats":
		if e.complexity.Query.GetChaosHubStats == nil {
			break
		}

		args, err := ec.field_Query_getChaosHubStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChaosHubStats(childComplexity, args["projectID"].(string)), true

	case "Query.getEnvironment":
		if e.complexity.Query.GetEnvironment == nil {
			break
		}

		args, err := ec.field_Query_getEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEnvironment(childComplexity, args["projectID"].(string), args["environmentID"].(string)), true

	case "Query.getExperiment":
		if e.complexity.Query.GetExperiment == nil {
			break
		}

		args, err := ec.field_Query_getExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperiment(childComplexity, args["projectID"].(string), args["experimentID"].(string)), true

	case "Query.getExperimentRun":
		if e.complexity.Query.GetExperimentRun == nil {
			break
		}

		args, err := ec.field_Query_getExperimentRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentRun(childComplexity, args["projectID"].(string), args["experimentRunID"].(string)), true

	case "Query.getExperimentRunStats":
		if e.complexity.Query.GetExperimentRunStats == nil {
			break
		}

		args, err := ec.field_Query_getExperimentRunStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentRunStats(childComplexity, args["projectID"].(string)), true

	case "Query.getExperimentStats":
		if e.complexity.Query.GetExperimentStats == nil {
			break
		}

		args, err := ec.field_Query_getExperimentStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentStats(childComplexity, args["projectID"].(string)), true

	case "Query.getGitOpsDetails":
		if e.complexity.Query.GetGitOpsDetails == nil {
			break
		}

		args, err := ec.field_Query_getGitOpsDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGitOpsDetails(childComplexity, args["projectID"].(string)), true

	case "Query.getImageRegistry":
		if e.complexity.Query.GetImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_getImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Query.getInfra":
		if e.complexity.Query.GetInfra == nil {
			break
		}

		args, err := ec.field_Query_getInfra_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfra(childComplexity, args["projectID"].(string), args["infraID"].(string)), true

	case "Query.getInfraDetails":
		if e.complexity.Query.GetInfraDetails == nil {
			break
		}

		args, err := ec.field_Query_getInfraDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfraDetails(childComplexity, args["infraID"].(string), args["projectID"].(string)), true

	case "Query.getInfraManifest":
		if e.complexity.Query.GetInfraManifest == nil {
			break
		}

		args, err := ec.field_Query_getInfraManifest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfraManifest(childComplexity, args["infraID"].(string), args["upgrade"].(bool), args["projectID"].(string)), true

	case "Query.getInfraStats":
		if e.complexity.Query.GetInfraStats == nil {
			break
		}

		args, err := ec.field_Query_getInfraStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfraStats(childComplexity, args["projectID"].(string)), true

	case "Query.getPredefinedExperiment":
		if e.complexity.Query.GetPredefinedExperiment == nil {
			break
		}

		args, err := ec.field_Query_getPredefinedExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPredefinedExperiment(childComplexity, args["hubID"].(string), args["experimentName"].([]string), args["projectID"].(string)), true

	case "Query.getServerVersion":
		if e.complexity.Query.GetServerVersion == nil {
			break
		}

		return e.complexity.Query.GetServerVersion(childComplexity), true

	case "Query.getVersionDetails":
		if e.complexity.Query.GetVersionDetails == nil {
			break
		}

		args, err := ec.field_Query_getVersionDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVersionDetails(childComplexity, args["projectID"].(string)), true

	case "Query.listChaosFaults":
		if e.complexity.Query.ListChaosFaults == nil {
			break
		}

		args, err := ec.field_Query_listChaosFaults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListChaosFaults(childComplexity, args["hubID"].(string), args["projectID"].(string)), true

	case "Query.listChaosHub":
		if e.complexity.Query.ListChaosHub == nil {
			break
		}

		args, err := ec.field_Query_listChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListChaosHub(childComplexity, args["projectID"].(string), args["request"].(*model.ListChaosHubRequest)), true

	case "Query.listEnvironments":
		if e.complexity.Query.ListEnvironments == nil {
			break
		}

		args, err := ec.field_Query_listEnvironments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListEnvironments(childComplexity, args["projectID"].(string), args["request"].(*model.ListEnvironmentRequest)), true

	case "Query.listExperiment":
		if e.complexity.Query.ListExperiment == nil {
			break
		}

		args, err := ec.field_Query_listExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListExperiment(childComplexity, args["projectID"].(string), args["request"].(model.ListExperimentRequest)), true

	case "Query.listExperimentRun":
		if e.complexity.Query.ListExperimentRun == nil {
			break
		}

		args, err := ec.field_Query_listExperimentRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListExperimentRun(childComplexity, args["projectID"].(string), args["request"].(model.ListExperimentRunRequest)), true

	case "Query.listImageRegistry":
		if e.complexity.Query.ListImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_listImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListImageRegistry(childComplexity, args["projectID"].(string)), true

	case "Query.listInfras":
		if e.complexity.Query.ListInfras == nil {
			break
		}

		args, err := ec.field_Query_listInfras_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListInfras(childComplexity, args["projectID"].(string), args["request"].(*model.ListInfraRequest)), true

	case "Query.listPredefinedExperiments":
		if e.complexity.Query.ListPredefinedExperiments == nil {
			break
		}

		args, err := ec.field_Query_listPredefinedExperiments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPredefinedExperiments(childComplexity, args["hubID"].(string), args["projectID"].(string)), true

	case "RecentExperimentRun.createdAt":
		if e.complexity.RecentExperimentRun.CreatedAt == nil {
			break
		}

		return e.complexity.RecentExperimentRun.CreatedAt(childComplexity), true

	case "RecentExperimentRun.createdBy":
		if e.complexity.RecentExperimentRun.CreatedBy == nil {
			break
		}

		return e.complexity.RecentExperimentRun.CreatedBy(childComplexity), true

	case "RecentExperimentRun.experimentRunID":
		if e.complexity.RecentExperimentRun.ExperimentRunID == nil {
			break
		}

		return e.complexity.RecentExperimentRun.ExperimentRunID(childComplexity), true

	case "RecentExperimentRun.phase":
		if e.complexity.RecentExperimentRun.Phase == nil {
			break
		}

		return e.complexity.RecentExperimentRun.Phase(childComplexity), true

	case "RecentExperimentRun.resiliencyScore":
		if e.complexity.RecentExperimentRun.ResiliencyScore == nil {
			break
		}

		return e.complexity.RecentExperimentRun.ResiliencyScore(childComplexity), true

	case "RecentExperimentRun.updatedAt":
		if e.complexity.RecentExperimentRun.UpdatedAt == nil {
			break
		}

		return e.complexity.RecentExperimentRun.UpdatedAt(childComplexity), true

	case "RecentExperimentRun.updatedBy":
		if e.complexity.RecentExperimentRun.UpdatedBy == nil {
			break
		}

		return e.complexity.RecentExperimentRun.UpdatedBy(childComplexity), true

	case "RegisterInfraResponse.infraID":
		if e.complexity.RegisterInfraResponse.InfraID == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.InfraID(childComplexity), true

	case "RegisterInfraResponse.manifest":
		if e.complexity.RegisterInfraResponse.Manifest == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.Manifest(childComplexity), true

	case "RegisterInfraResponse.name":
		if e.complexity.RegisterInfraResponse.Name == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.Name(childComplexity), true

	case "RegisterInfraResponse.token":
		if e.complexity.RegisterInfraResponse.Token == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.Token(childComplexity), true

	case "ResilienceScoreCategory.count":
		if e.complexity.ResilienceScoreCategory.Count == nil {
			break
		}

		return e.complexity.ResilienceScoreCategory.Count(childComplexity), true

	case "ResilienceScoreCategory.id":
		if e.complexity.ResilienceScoreCategory.ID == nil {
			break
		}

		return e.complexity.ResilienceScoreCategory.ID(childComplexity), true

	case "RunChaosExperimentResponse.notifyID":
		if e.complexity.RunChaosExperimentResponse.NotifyID == nil {
			break
		}

		return e.complexity.RunChaosExperimentResponse.NotifyID(childComplexity), true

	case "SSHKey.privateKey":
		if e.complexity.SSHKey.PrivateKey == nil {
			break
		}

		return e.complexity.SSHKey.PrivateKey(childComplexity), true

	case "SSHKey.publicKey":
		if e.complexity.SSHKey.PublicKey == nil {
			break
		}

		return e.complexity.SSHKey.PublicKey(childComplexity), true

	case "ServerVersionResponse.key":
		if e.complexity.ServerVersionResponse.Key == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Key(childComplexity), true

	case "ServerVersionResponse.value":
		if e.complexity.ServerVersionResponse.Value == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Value(childComplexity), true

	case "Spec.categoryDescription":
		if e.complexity.Spec.CategoryDescription == nil {
			break
		}

		return e.complexity.Spec.CategoryDescription(childComplexity), true

	case "Spec.chaosExpCRDLink":
		if e.complexity.Spec.ChaosExpCRDLink == nil {
			break
		}

		return e.complexity.Spec.ChaosExpCRDLink(childComplexity), true

	case "Spec.chaosType":
		if e.complexity.Spec.ChaosType == nil {
			break
		}

		return e.complexity.Spec.ChaosType(childComplexity), true

	case "Spec.displayName":
		if e.complexity.Spec.DisplayName == nil {
			break
		}

		return e.complexity.Spec.DisplayName(childComplexity), true

	case "Spec.experiments":
		if e.complexity.Spec.Experiments == nil {
			break
		}

		return e.complexity.Spec.Experiments(childComplexity), true

	case "Spec.faults":
		if e.complexity.Spec.Faults == nil {
			break
		}

		return e.complexity.Spec.Faults(childComplexity), true

	case "Spec.keywords":
		if e.complexity.Spec.Keywords == nil {
			break
		}

		return e.complexity.Spec.Keywords(childComplexity), true

	case "Spec.links":
		if e.complexity.Spec.Links == nil {
			break
		}

		return e.complexity.Spec.Links(childComplexity), true

	case "Spec.maintainers":
		if e.complexity.Spec.Maintainers == nil {
			break
		}

		return e.complexity.Spec.Maintainers(childComplexity), true

	case "Spec.maturity":
		if e.complexity.Spec.Maturity == nil {
			break
		}

		return e.complexity.Spec.Maturity(childComplexity), true

	case "Spec.minKubeVersion":
		if e.complexity.Spec.MinKubeVersion == nil {
			break
		}

		return e.complexity.Spec.MinKubeVersion(childComplexity), true

	case "Spec.platforms":
		if e.complexity.Spec.Platforms == nil {
			break
		}

		return e.complexity.Spec.Platforms(childComplexity), true

	case "Spec.provider":
		if e.complexity.Spec.Provider == nil {
			break
		}

		return e.complexity.Spec.Provider(childComplexity), true

	case "StopExperimentRunsRequest.experimentID":
		if e.complexity.StopExperimentRunsRequest.ExperimentID == nil {
			break
		}

		return e.complexity.StopExperimentRunsRequest.ExperimentID(childComplexity), true

	case "StopExperimentRunsRequest.experimentRunID":
		if e.complexity.StopExperimentRunsRequest.ExperimentRunID == nil {
			break
		}

		return e.complexity.StopExperimentRunsRequest.ExperimentRunID(childComplexity), true

	case "StopExperimentRunsRequest.projectID":
		if e.complexity.StopExperimentRunsRequest.ProjectID == nil {
			break
		}

		return e.complexity.StopExperimentRunsRequest.ProjectID(childComplexity), true

	case "Subscription.getInfraEvents":
		if e.complexity.Subscription.GetInfraEvents == nil {
			break
		}

		args, err := ec.field_Subscription_getInfraEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetInfraEvents(childComplexity, args["projectID"].(string)), true

	case "Subscription.getKubeObject":
		if e.complexity.Subscription.GetKubeObject == nil {
			break
		}

		args, err := ec.field_Subscription_getKubeObject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetKubeObject(childComplexity, args["request"].(model.KubeObjectRequest)), true

	case "Subscription.getPodLog":
		if e.complexity.Subscription.GetPodLog == nil {
			break
		}

		args, err := ec.field_Subscription_getPodLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetPodLog(childComplexity, args["request"].(model.PodLogRequest)), true

	case "Subscription.infraConnect":
		if e.complexity.Subscription.InfraConnect == nil {
			break
		}

		args, err := ec.field_Subscription_infraConnect_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.InfraConnect(childComplexity, args["request"].(model.InfraIdentity)), true

	case "UserDetails.email":
		if e.complexity.UserDetails.Email == nil {
			break
		}

		return e.complexity.UserDetails.Email(childComplexity), true

	case "UserDetails.userID":
		if e.complexity.UserDetails.UserID == nil {
			break
		}

		return e.complexity.UserDetails.UserID(childComplexity), true

	case "UserDetails.username":
		if e.complexity.UserDetails.Username == nil {
			break
		}

		return e.complexity.UserDetails.Username(childComplexity), true

	case "Weightages.faultName":
		if e.complexity.Weightages.FaultName == nil {
			break
		}

		return e.complexity.Weightages.FaultName(childComplexity), true

	case "Weightages.weightage":
		if e.complexity.Weightages.Weightage == nil {
			break
		}

		return e.complexity.Weightages.Weightage(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "../definitions/shared/chaos_experiment.graphqls", Input: `"""
Defines the details of the weightages of each chaos fault in the experiment
"""
input WeightagesInput {
  """
  Name of the fault
  """
  faultName: String!
  """
  Weightage of the fault
  """
  weightage: Int!
}

input EventMetadataInput{
  faultName: String!
  serviceIdentifier: [String!]!
  environmentIdentifier: [String!]!
}

enum ExperimentType{
  All
  Experiment
  CronExperiment
  ChaosEngine
  ChaosSchedule
}

enum ExperimentRunStatus {
  All
  Running
  Completed
  Completed_With_Error
  Stopped
  Skipped
  Error
  Timeout
  NA
}

enum ScheduleType {
  CRON
  NON_CRON
  ALL
}

"""
Defines the details for a chaos experiment
"""
input SaveChaosExperimentRequest {
  """
  ID of the experiment
  """
  id: String!
  """
  Type of the experiment
  """
  type: ExperimentType
  """
  Name of the experiment
  """
  name: String!
  """
  Description of the experiment
  """
  description: String!
  """
  Manifest of the experiment
  """
  manifest: String!
  """
  ID of the target infrastructure in which the experiment will run
  """
  infraID: ID!
  """
  Tags of the infrastructure
  """
  tags: [String!]

}

"""
Defines the details for a chaos experiment
"""
input ChaosExperimentRequest {
  """
  ID of the experiment
  """
  experimentID: String
  """
  Boolean check indicating if the created scenario will be executed or not
  """
  runExperiment: Boolean
  """
  Manifest of the experiment
  """
  experimentManifest: String!
  """
  Type of the experiment
  """
  experimentType: ExperimentType
  """
  Cron syntax of the experiment schedule
  """
  cronSyntax: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Description of the experiment
  """
  experimentDescription: String!
  """
  Array containing weightage and name of each chaos experiment in the experiment
  """
  weightages: [WeightagesInput!]!
  """
  Bool value indicating whether the experiment is a custom experiment or not
  """
  isCustomExperiment: Boolean!
  """
  ID of the target infra in which the experiment will run
  """
  infraID: ID!
  """
  Tags of the infra
  """
  tags: [String!]
}

"""
Defines the response received for querying the details of chaos experiment
"""
type ChaosExperimentResponse {
  """
  ID of the experiment
  """
  experimentID: String!
  projectID:ID!
  """
  Cron syntax of the experiment schedule
  """
  cronSyntax: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Description of the experiment
  """
  experimentDescription: String!
  """
  Bool value indicating whether the experiment is a custom experiment or not
  """
  isCustomExperiment: Boolean!
  """
  Tags of the infra
  """
  tags: [String!]
}

"""
Defines the details for a experiment run
"""
input ExperimentRunRequest {
  """
  ID of the experiment
  """
  experimentID: String!
  """
  notifyID is required to give an ack for non cron experiment execution
  """
  notifyID: String
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Stores all the experiment run details related to the nodes of DAG graph and chaos results of the experiments
  """
  executionData: String!
  """
  ID of the infra infra in which the experiment is running
  """
  infraID: InfraIdentity!
  """
  ID of the revision which consists manifest details
  """
  revisionID: String!
  """
  Bool value indicating if the experiment run has completed
  """
  completed: Boolean!
  """
  Bool value indicating if the experiment run has removed
  """
  isRemoved: Boolean
  """
  User who has updated the experiment
  """
  updatedBy: String!
}

"""
Defines the start date and end date for the filtering the data
"""
input DateRange {
  """
  Start date
  """
  startDate: String!
  """
  End date
  """
  endDate: String
}

"""
Defines input type for experiment run filter
"""
input ExperimentRunFilterInput {
  """
  Name of the experiment
  """
  experimentName: String
  """
  Name of the infra infra
  """
  infraID: String
  """
  Type of the experiment
  """
  experimentType: ScheduleType
  """
  Status of the experiment run
  """
  experimentStatus: ExperimentRunStatus
  """
  Date range for filtering purpose
  """
  dateRange: DateRange
  """
  ID of experiment run
  """
  experimentRunID: String
  """
  Array of experiment run status
  """
  experimentRunStatus:[String]
  """
  Type of infras
  """
  infraTypes: [InfrastructureType]
}

"""
Defines data required to fetch paginated data
"""
input Pagination {
  """
  Page number for which data will be fetched
  """
  page: Int!
  """
  Number of data to be fetched
  """
  limit: Int!
}

enum ExperimentSortingField {
  NAME
  TIME
}

"""
Defines sorting options for experiment runs
"""
input ExperimentRunSortInput {
  """
  Field in which sorting will be done
  """
  field: ExperimentSortingField!
  """
  Bool value indicating whether the sorting will be done in ascending order
  """
  ascending: Boolean
}

"""
Defines the details for experiment runs
"""
input ListExperimentRunRequest {
  """
  Array of experiment run IDs for which details will be fetched
  """
  experimentRunIDs: [ID]
  """
  Array of experiment IDs for which details will be fetched
  """
  experimentIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: ExperimentRunSortInput
  """
  Details for fetching filtered data
  """
  filter: ExperimentRunFilterInput
}

"""
Defines the details of the weightages of each chaos fault in the experiment
"""
type Weightages {
  """
  Name of the fault
  """
  faultName: String!
  """
  Weightage of the experiment
  """
  weightage: Int!
}

type EventMetadata{
  faultName: String!
  serviceIdentifier: [String!]!
  environmentIdentifier: [String!]!
}

"""
Defines the details of a experiment run
"""
type ExperimentRun implements Audit{
  projectID: ID!
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: ID!
  """
  Type of the experiment
  """
  experimentType: String
  """
  ID of the experiment
  """
  experimentID: ID!
  """
  Array containing weightage and name of each chaos fault in the experiment
  """
  weightages: [Weightages!]!
  """
  Timestamp at which experiment run was last updated
  """
  updatedAt: String!
  """
  Timestamp at which experiment run was created
  """
  createdAt: String!
  """
  Target infra in which the experiment will run
  """
  infra: Infra!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Manifest of the experiment run
  """
  experimentManifest: String!
  """
  Phase of the experiment run
  """
  phase: ExperimentRunStatus!
  """
  Resiliency score of the experiment
  """
  resiliencyScore: Float
  """
  Number of faults passed
  """
  faultsPassed: Int
  """
  Number of faults failed
  """
  faultsFailed: Int
  """
  Number of faults awaited
  """
  faultsAwaited: Int
  """
  Number of faults stopped
  """
  faultsStopped: Int
  """
  Number of faults which are not available
  """
  faultsNa: Int
  """
  Total number of faults
  """
  totalFaults: Int
  """
  Stores all the experiment run details related to the nodes of DAG graph and chaos results of the faults
  """
  executionData: String!
  """
  Bool value indicating if the experiment run has removed
  """
  isRemoved: Boolean
  """
  User who has updated the experiment
  """
  updatedBy: UserDetails
  """
  User who has created the experiment run
  """
  createdBy: UserDetails
}

"""
Defines the details of a experiment to sent as response
"""
type ListExperimentRunResponse {
  """
  Total number of experiment runs
  """
  totalNoOfExperimentRuns: Int!
  """
  Defines details of experiment runs
  """
  experimentRuns: [ExperimentRun]!
}

"""
Defines filter options for experiments
"""
input ExperimentFilterInput {
  """
  Name of the experiment
  """
  experimentName: String
  """
  Name of the infra in which the experiment is running
  """
  infraName: String
  """
  ID of the infra in which the experiment is running
  """
  infraID: String
"""
  Bool value indicating if Chaos Infrastructure is active
  """
  infraActive: Boolean
  """
  Scenario type of the experiment i.e. CRON or NON_CRON
  """
  scheduleType: ScheduleType
  """
  Status of the latest experiment run
  """
  status: String
  """
  Date range for filtering purpose
  """
  dateRange: DateRange
  """
  Type of infras
  """
  infraTypes: [InfrastructureType]
}

"""
Defines the details for a experiment
"""
input ListExperimentRequest {
  """
  Array of experiment IDs for which details will be fetched
  """
  experimentIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: ExperimentSortInput
  """
  Details for fetching filtered data
  """
  filter: ExperimentFilterInput
}

"""
Defines sorting options for experiment
"""
input ExperimentSortInput {
  """
  Field in which sorting will be done
  """
  field: ExperimentSortingField!
  """
  Bool value indicating whether the sorting will be done in ascending order
  """
  ascending: Boolean
}

type RecentExperimentRun implements Audit{
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: ID!
  """
  Phase of the experiment run
  """
  phase: String!
  """
  Resiliency score of the experiment
  """
  resiliencyScore: Float
  """
  Timestamp when the experiment was last updated
  """
  updatedAt: String!
  """
  Timestamp when the experiment was created
  """
  createdAt: String!
  """
  User who created the experiment run
  """
  createdBy: UserDetails
  """
  User who updated the experiment run
  """
  updatedBy: UserDetails

}

"""
Defines the details for a experiment
"""
type Experiment implements ResourceDetails & Audit{
  projectID:ID!
  """
  ID of the experiment
  """
  experimentID: String!
  """
  Type of the experiment
  """
  experimentType: String
  """
  Manifest of the experiment
  """
  experimentManifest: String!
  """
  Cron syntax of the experiment schedule
  """
  cronSyntax: String!
  """
  Name of the experiment
  """
  name: String!
  """
  Description of the experiment
  """
  description: String!
  """
  Array containing weightage and name of each chaos fault in the experiment
  """
  weightages: [Weightages!]!
  """
  Bool value indicating whether the experiment is a custom experiment or not
  """
  isCustomExperiment: Boolean!
  """
  Timestamp when the experiment was last updated
  """
  updatedAt: String!
  """
  Timestamp when the experiment was created
  """
  createdAt: String!
  """
  Target infra in which the experiment will run
  """
  infra: Infra
  """
  Bool value indicating if the experiment has removed
  """
  isRemoved: Boolean!
  """
  Tags of the experiment
  """
  tags: [String!]
  """
  User who created the experiment
  """
  createdBy: UserDetails
  """
  Array of object containing details of recent experiment runs
  """
  recentExperimentRunDetails: [RecentExperimentRun]
  """
  Details of the user who updated the experiment
  """
  updatedBy: UserDetails
}

"""
Defines the details for a given experiment with some additional data
"""
type GetExperimentResponse {
  """
  Details of experiment
  """
  experimentDetails: Experiment!
  """
  Average resiliency score of the experiment
  """
  averageResiliencyScore: Float
}

"""
Defines the details for a experiment with total experiment count
"""
type ListExperimentResponse {
  """
  Total number of experiments
  """
  totalNoOfExperiments: Int!
  """
  Details related to the experiments
  """
  experiments: [Experiment]!
}

"""
Defines the request for stopping a experiment
"""
type StopExperimentRunsRequest {
  projectID:ID!
  """
  ID of the experiment to be stopped
  """
  experimentID: String!
  """
  ID of the experiment run to be stopped
  """
  experimentRunID: String
}

type RunChaosExperimentResponse {
  notifyID: ID!
}

type GetExperimentRunStatsResponse{
  """
  Total number of experiment runs
  """
  totalExperimentRuns: Int!
  """
  Total number of completed experiments runs
  """
  totalCompletedExperimentRuns: Int!
  """
  Total number of stopped experiment runs
  """
  totalTerminatedExperimentRuns: Int!
  """
  Total number of running experiment runs
  """
  totalRunningExperimentRuns: Int!
  """
  Total number of stopped experiment runs
  """
  totalStoppedExperimentRuns: Int!
  """
  Total number of errored experiment runs
  """
  totalErroredExperimentRuns: Int!
}

type ResilienceScoreCategory{
  """
  Lower bound of the range(inclusive)
  """
  id:Int!
  """
  total experiments with avg resilience score between lower bound and upper bound(exclusive)
  """
  count:Int!
}

type GetExperimentStatsResponse{
  """
  Total number of experiments
  """
  totalExperiments:Int!
  """
  Total number of cron experiments
  """
  totalExpCategorizedByResiliencyScore:[ResilienceScoreCategory]!

}

extend type Query {
  """
  Returns experiment run based on experiment run ID
  """
  getExperimentRun(
    projectID:ID!
    experimentRunID: String!
  ): ExperimentRun!

  """
  Returns the list of experiment run based on various filter parameters
  """
  listExperimentRun(
    projectID:ID!
    request: ListExperimentRunRequest!
  ): ListExperimentRunResponse!

  """
  Returns the experiment based on experiment ID
  """
  getExperiment(
    projectID:ID!
    experimentID: String!
  ): GetExperimentResponse!

  """
  Returns the list of experiments based on various filter parameters
  """
  listExperiment(
    projectID:ID!
    request: ListExperimentRequest!
  ): ListExperimentResponse!

  """
  Query to get experiment run stats
  """
  getExperimentRunStats(projectID:ID!): GetExperimentRunStatsResponse!
  """
  Query to get experiment stats
  """
  getExperimentStats(projectID:ID!): GetExperimentStatsResponse!
}

extend type Mutation {
  """
  Creates a new experiment and applies its manifest
  """
  createChaosExperiment(
    request: ChaosExperimentRequest!
    projectID:ID!
  ): ChaosExperimentResponse!

  """
  Saves a new experiment or updates if already exists
  """
  saveChaosExperiment(
    request: SaveChaosExperimentRequest!
    projectID:ID!
  ): String!

  """
  Run the chaos experiment (used by frontend)
  """
  runChaosExperiment(
    experimentID: String!
    projectID:ID!
  ): RunChaosExperimentResponse!

  """
  Updates the experiment
  """
  updateChaosExperiment(
    request: ChaosExperimentRequest
    projectID:ID!
  ): ChaosExperimentResponse!

  """
  Removes a experiment from infra
  """
  deleteChaosExperiment(
    experimentID: String!
    experimentRunID: String
    projectID:ID!
  ): Boolean!
#  """
#  Manually sync the status of the experiment run
#  """
#  syncExperimentRun(
#    experimentID: String!
#    experimentRunID: String!
#    projectID:ID!
#  ): Boolean!

  """
  Creates a new experiment run and sends it to subscriber
  """
  # authorized directive not required
  chaosExperimentRun(request: ExperimentRunRequest!): String!
}

`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/chaos_infrastructure.graphqls", Input: `directive @authorized on FIELD_DEFINITION
directive @internal on FIELD_DEFINITION

"""
UpdateStatus represents if infra needs to be updated
"""
enum UpdateStatus {
  AVAILABLE
  MANDATORY
  NOT_REQUIRED
}

"""
Defines the details for a infra
"""
type Infra implements ResourceDetails & Audit {
  projectID: ID!
  """
  ID of the infra
  """
  infraID: ID!
  """
  Name of the infra
  """
  name: String!
  """
  Description of the infra
  """
  description: String
  """
  Tags of the infra
  """
  tags: [String!]
  """
  Environment ID for the infra
  """
  environmentID: String!
  """
  Infra Platform Name eg. GKE,AWS, Others
  """
  platformName: String!
  """
  Boolean value indicating if chaos infrastructure is active or not
  """
  isActive: Boolean!
  """
  Boolean value indicating if chaos infrastructure is confirmed or not
  """
  isInfraConfirmed: Boolean!
  """
  Boolean value indicating if chaos infrastructure is removed or not
  """
  isRemoved: Boolean!
  """
  Timestamp when the infra was last updated
  """
  updatedAt: String!
  """
  Timestamp when the infra was created
  """
  createdAt: String!
  """
  Number of schedules created in the infra
  """
  noOfExperiments: Int
  """
  Number of experiments run in the infra
  """
  noOfExperimentRuns: Int
  """
  Token used to verify and retrieve the infra manifest
  """
  token: String!
  """
  Namespace where the infra is being installed
  """
  infraNamespace: String
  """
  Name of service account used by infra
  """
  serviceAccount: String
  """
  Scope of the infra : ns or cluster
  """
  infraScope: String!
  """
  Bool value indicating whether infra ns used already exists on infra or not
  """
  infraNsExists: Boolean
  """
  Bool value indicating whether service account used already exists on infra or not
  """
  infraSaExists: Boolean
  """
  Timestamp of the last experiment run in the infra
  """
  lastExperimentTimestamp: String
  """
  Timestamp when the infra got connected
  """
  startTime: String!
  """
  Version of the infra
  """
  version: String!
  """
  User who created the infra
  """
  createdBy: UserDetails
  """
  User who has updated the infra
  """
  updatedBy: UserDetails
  """
  Type of the infrastructure
  """
  infraType: InfrastructureType
  """
  update status of infra
  """
  updateStatus: UpdateStatus!
}

enum InfrastructureType{
  INTERNAL
  EXTERNAL
}

"""
Defines the details for the new infra being connected
"""
input RegisterInfraRequest {
  """
  Name of the infra
  """
  name: String!
  """
  Environment ID for the infra
  """
  environmentID: String!
  """
  Type of Infra : internal/external
  """
  infrastructureType: InfrastructureType!
  """
  Description of the infra
  """
  description: String
  """
  Infra Platform Name eg. GKE,AWS, Others
  """
  platformName: String!
  """
  Namespace where the infra is being installed
  """
  infraNamespace: String
  """
  Name of service account used by infra
  """
  serviceAccount: String
  """
  Scope of the infra : ns or infra
  """
  infraScope: String!
  """
  Bool value indicating whether infra ns used already exists on infra or not
  """
  infraNsExists: Boolean
  """
  Bool value indicating whether service account used already exists on infra or not
  """
  infraSaExists: Boolean
  """
  Bool value indicating whether infra will skip ssl checks or not
  """
  skipSsl: Boolean
  """
  Node selectors used by infra
  """
  nodeSelector: String
  """
  Node tolerations used by infra
  """
  tolerations: [Toleration]
  """
  Tags of the infra
  """
  tags: [String!]
}

input Toleration {
  tolerationSeconds: Int
  key: String
  operator: String
  effect: String
  value: String
}

type InfraEventResponse {
  eventID: ID!
  eventType: String!
  eventName: String!
  description: String!
  infra: Infra!
}

type ActionPayload {
  requestID: String!
  requestType: String!
  k8sManifest: String!
  namespace: String!
  externalData: String
  username: String
}

type InfraActionResponse {
  projectID: String!
  action: ActionPayload!
}

input NewInfraEventRequest {
  eventName: String!
  description: String!
  infraID: String!
  accessKey: String!
}



type ConfirmInfraRegistrationResponse {
  isInfraConfirmed: Boolean!
  newAccessKey: String
  infraID: String
}

"""
Response received for registering a new infra
"""
type RegisterInfraResponse {
  """
  Token used to verify and retrieve the infra manifest
  """
  token: String!
  """
  Unique ID for the newly registered infra
  """
  infraID: String!
  """
  Infra name as sent in request
  """
  name: String!
  """
  Infra Manifest
  """
  manifest: String!
}

"""
Defines the response received for querying querying the pod logs
"""
type PodLogResponse {
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: ID!
  """
  Name of the pod for which logs are queried
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

input InfraIdentity {
  infraID: String!
  accessKey: String!
  version: String!
}

"""
Defines the details for fetching the pod logs
"""
input PodLogRequest {
  """
  ID of the cluster
  """
  infraID: ID!
  """
  ID of a experiment run
  """
  experimentRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Namespace where the pod is running
  """
  podNamespace: String!
  """
  Type of the pod: chaosEngine or not pod
  """
  podType: String!
  """
  Name of the experiment pod fetched from execution data
  """
  expPod: String
  """
  Name of the runner pod fetched from execution data
  """
  runnerPod: String
  """
  Namespace where the experiment is executing
  """
  chaosNamespace: String
}

"""
Response received for querying pod logs
"""
input PodLog {
  """
  ID of the cluster
  """
  infraID: InfraIdentity!
  """
  Unique request ID of a particular node which is being queried
  """
  requestID: ID!
  """
  ID of a experiment run
  """
  experimentRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

"""
Response received for querying Kubernetes Object
"""
type KubeObjectResponse {
  """
  ID of the infra in which the Kubernetes object is present
  """
  infraID: ID!
  """
  Type of the Kubernetes object
  """
  kubeObj: [KubeObject]!
}

"""
KubeObject consists of the namespace and the available resources in the same
"""
type KubeObject {
  """
  Namespace of the resource
  """
  namespace: String!
  """
  Details of the resource
  """
  data: [ObjectData]!
}

type ObjectData {
  """
  Labels present in the resource
  """
  labels: [String!]
  """
  Name of the resource
  """
  name: String!
}

input Workload {
  name: String!
  kind: String!
  namespace: String!
}

"""
Defines details for fetching Kubernetes object data
"""
input KubeObjectRequest {
  """
  ID of the infra in which the Kubernetes object is present
  """
  infraID: ID!
  """
  GVR Request
  """
  kubeObjRequest: KubeGVRRequest
  objectType: String!
  workloads: [Workload]
}

input KubeGVRRequest {
  group: String!
  version: String!
  resource: String!
}

"""
Defines the details of Kubernetes object
"""
input KubeObjectData {
  """
  Unique request ID for fetching Kubernetes object details
  """
  requestID: ID!
  """
  ID of the infra in which the Kubernetes object is present
  """
  infraID: InfraIdentity!
  """
  Type of the Kubernetes object
  """
  kubeObj: String!
}

"""
Defines filter options for infras
"""
input InfraFilterInput {
  """
  Name of the infra
  """
  name: String
  """
  ID of the infra
  """
  infraID: String
  """
  ID of the infra
  """
  description: String
  """
  Platform name of infra
  """
  platformName: String
  """
  Scope of infra
  """
  infraScope: INFRA_SCOPE
  """
  Status of infra
  """
  isActive: Boolean
  """
  Tags of an infra
  """
  tags: [String]
}

enum INFRA_SCOPE {
  namespace
  cluster
}

"""
Defines the details for a infra
"""
input ListInfraRequest {
  """
  Array of infra IDs for which details will be fetched
  """
  infraIDs: [ID!]
  """
  Environment ID
  """
  environmentIDs: [ID!]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching filtered data
  """
  filter: InfraFilterInput
}

"""
Defines the details for a infras with total infras count
"""
type ListInfraResponse {
  """
  Total number of infras
  """
  totalNoOfInfras: Int!
  """
  Details related to the infras
  """
  infras: [Infra]!
}

type GetInfraStatsResponse{
  """
  Total number of infrastructures
  """
  totalInfrastructures: Int!
  """
  Total number of active infrastructures
  """
  totalActiveInfrastructure: Int!
  """
  Total number of inactive infrastructures
  """
  totalInactiveInfrastructures: Int!
  """
  Total number of confirmed infrastructures
  """
  totalConfirmedInfrastructure: Int!
  """
  Total number of non confirmed infrastructures
  """
  totalNonConfirmedInfrastructures: Int!
}

"""
InfraVersionDetails returns the details of compatible infra versions and the latest infra version supported
"""
type InfraVersionDetails {
  """
  Latest infra version supported
  """
  latestVersion: String!
  """
  List of all infra versions supported
  """
  compatibleVersions: [String!]!
}

"""
Response received for fetching GQL server version
"""
type ServerVersionResponse {
  """
  Returns server version key
  """
  key: String!
  """
  Returns server version value
  """
  value: String!
}


extend type Query {
  # INFRA OPERATIONS
  """
  Returns infra with a particular infraID in the project
  """
  getInfra(
    projectID:ID!
    infraID: String!
  ): Infra! @authorized

  """
  Returns infras with a particular infra type in the project
  """
  listInfras(
    projectID:ID!
    request: ListInfraRequest
  ): ListInfraResponse! @authorized

  """
  Returns infra details based on identifiers
  """
  getInfraDetails(infraID: ID!, projectID:ID!): Infra!
    @authorized

  """
  Returns the manifest for a given infraID
  """
  getInfraManifest(infraID: ID!, upgrade: Boolean!, projectID:ID!): String!
    @authorized

  """
  Query to get experiment stats
  """
  getInfraStats(projectID:ID!): GetInfraStatsResponse! @authorized

  """
  Query to get the latest version of infra available
  """
  getVersionDetails(projectID:ID!): InfraVersionDetails! @authorized
  """
  Returns version of gql server
  """
  getServerVersion: ServerVersionResponse!
}

extend type Mutation {
  """
  Connect a new infra for a user in a specified project
  """
  registerInfra(
    projectID:ID!
    request: RegisterInfraRequest!
  ): RegisterInfraResponse!


  """
  Confirms the subscriber's registration with the control plane
  """
  # authorized directive not required
  confirmInfraRegistration(
    request: InfraIdentity!
  ): ConfirmInfraRegistrationResponse!
  """
  Disconnects an infra and deletes its configuration from the control plane
  """
  deleteInfra(projectID:ID!, infraID: String!): String! @authorized

  """
  Fetches manifest details
  """
  getManifestWithInfraID(
    projectID:ID!
    infraID: String!
    accessKey: String!
  ): String!

  """
  Receives pod logs for experiments from infra
  """
  # authorized directive not required
  podLog(request: PodLog!): String!

  """
  Receives kubernetes object data from subscriber
  """
  # authorized directive not required
  kubeObj(request: KubeObjectData!): String!
}

extend type Subscription {
  # INFRA OPERATIONS
  """
  Listens infra events from the graphql server
  """
  getInfraEvents(projectID: String!): InfraEventResponse! @authorized

  """
  Listens infra operation request from the graphql server
  """
  # authorized directive not required
  infraConnect(request: InfraIdentity!): InfraActionResponse!

  """
  Returns experiment logs from the pods
  """
  getPodLog(request: PodLogRequest!): PodLogResponse!

  # K8S OPERATIONS
  """
  Returns a kubernetes object given an input
  """
  getKubeObject(request: KubeObjectRequest!): KubeObjectResponse!
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/chaoshub.graphqls", Input: `enum AuthType {
  BASIC
  NONE
  SSH
  TOKEN
}

enum FileType {
  EXPERIMENT
  ENGINE
  WORKFLOW
  CSV
}

enum HubType {
  GIT
  REMOTE
}

type ChaosHub implements ResourceDetails & Audit {
  """
  ID of the chaos hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  ID of the project in which the chaos hub is present
  """
  projectID: ID!
  """
  Default Hub Identifier
  """
  isDefault: Boolean!
  """
  Name of the chaos hub
  """
  name: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  User who created the ChaosHub
  """
  createdBy: UserDetails
  """
  User who has updated the ChaosHub
  """
  updatedBy: UserDetails
  """
  Description of ChaosHub
  """
  description: String
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Bool value indicating if the chaos hub is removed
  """
  isRemoved: Boolean!
  """
  Timestamp when the chaos hub was created
  """
  createdAt: String!
  """
  Timestamp when the chaos hub was last updated
  """
  updatedAt: String!
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
}

#type Charts {
#	charts: [Chart!]!
#}

type Chart {
  apiVersion: String!
  kind: String!
  metadata: Metadata!
  spec: Spec!
  packageInfo: PackageInformation!
}

"""
Defines the details of the maintainer
"""
type Maintainer {
  """
  Name of the maintainer
  """
  name: String!
  """
  Email of the maintainer
  """
  email: String!
}

type Link {
  name: String!
  url: String!
}

type Metadata {
  name: String!
  version: String!
  annotations: Annotation!
}

type Annotation {
  categories: String!
  vendor: String!
  createdAt: String!
  repository: String!
  support: String!
  chartDescription: String!
}

type FaultList{
  name: String!
  displayName: String!
  description: String!
  plan: [String!]
}

type Spec {
  displayName: String!
  categoryDescription: String!
  keywords: [String!]!
  maturity: String!
  maintainers: [Maintainer!]!
  minKubeVersion: String!
  provider: Provider!
  links: [Link!]!
  faults: [FaultList!]!
  experiments: [String!]
  chaosExpCRDLink: String!
  platforms: [String!]!
  chaosType: String
}

type Provider {
	name: String!
}

type PackageInformation {
  packageName: String!
  experiments: [Experiments!]!
}

type Experiments {
  name: String!
  CSV: String!
  desc: String!
}

type ChaosHubStatus implements ResourceDetails & Audit {
  """
  ID of the hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is available or not.
  """
  isAvailable: Boolean!
  """
  Total number of experiments in the hub
  """
  totalFaults: String!
  """
  Total experiments
  """
  totalExperiments: String!
  """
  Name of the chaos hub
  """
  name: String!
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Bool value indicating whether the hub is private or not.
  """
  isRemoved: Boolean!
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  User who created the ChaosHub
  """
  createdBy: UserDetails
  """
  User who has updated the ChaosHub
  """
  updatedBy: UserDetails
  """
  Created at timestamp
  """
  createdAt: String!
  """
  Updated at timestamp
  """
  updatedAt: String!
  """
  Description of ChaosHub
  """
  description: String
  """
  Default Hub Identifier
  """
  isDefault: Boolean!
}

"""
Defines the details required for creating a chaos hub
"""
input CreateChaosHubRequest {
  """
  Name of the chaos hub
  """
  name: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  Description of ChaosHub
  """
  description: String
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
}

input ExperimentRequest {
  """
  Name of the chart being used
  """
  category: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  ID of the hub
  """
  hubID: String!
}

input CloningInput {
  """
  Name of the chaos hub
  """
  name: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  sshPrivateKey: String
  isDefault:Boolean!
}

input CreateRemoteChaosHub {
  """
  Name of the chaos hub
  """
  name: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  Description of ChaosHub
  """
  description: String
  """
  URL of the git repository
  """
  repoURL: String!
}


input UpdateChaosHubRequest {
  """
  ID of the chaos hub
  """
  id: String!
  """
  Name of the chaos hub
  """
  name: String!
  """
  Description of the infra
  """
  description: String
  """
  Tags of the infra
  """
  tags: [String!]
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
}

type ExperimentDetails{
  """
  Engine Manifest
  """
  engineDetails: String!

  """
  Experiment Manifest
  """
  experimentDetails: String!
}

type PredefinedExperimentList {
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Experiment CSV
  """
  experimentCSV: String!
  """
  Experiment Manifest
  """
  experimentManifest: String!
}

"""
Defines filter options for ChaosHub
"""
input ChaosHubFilterInput {
  """
  Name of the ChaosHub
  """
  chaosHubName: String
  """
  Tags of a chaos hub
  """
  tags: [String!]
  """
  Description of a chaos hub
  """
  description: String
}

input ListChaosHubRequest {
  """
  Array of ChaosHub IDs for which details will be fetched
  """
  chaosHubIDs: [ID!]
  """
  Details for fetching filtered data
  """
  filter: ChaosHubFilterInput
}

"""
Fault Detail consists of all the fault related details
"""
type FaultDetails {
  """
  fault consists of fault.yaml
  """
  fault: String!
  """
  engine consists engine.yaml
  """
  engine: String!
  """
  csv consists chartserviceversion.yaml
  """
  csv: String!
}

type GetChaosHubStatsResponse{
  """
  Total number of chaoshubs
  """
  totalChaosHubs: Int!

}


extend type Query {
  # CHAOS-HUB OPERATIONS
  """
  List the Charts details of a ChaosHub
  """
  listChaosFaults(hubID: ID!, projectID: ID!): [Chart!]! @authorized

  """
  Get the fault list from a ChaosHub
  """
  getChaosFault(projectID: ID!,request: ExperimentRequest!): FaultDetails! @authorized

  """
  Lists all the connected ChaosHub
  """
  listChaosHub(projectID: ID!, request: ListChaosHubRequest): [ChaosHubStatus]! @authorized
  """
  Get the details of a requested ChaosHub
  """
  getChaosHub(projectID: ID!, chaosHubID: ID!): ChaosHubStatus! @authorized
#
#  """
#  Get the YAML manifest of ChaosEngine/ChaosExperiment
#  """
#  getYAMLData(projectID: String!,request: ExperimentRequest!): String! @authorized

#  """
#  Get Engine and Experiment YAML
#  """
#  getExperimentDetails(projectID: String!,request: ExperimentRequest!): ExperimentDetails! @authorized

  """
  List the PredefinedExperiments present in the hub
  """
  listPredefinedExperiments(hubID: ID!, projectID: ID!): [PredefinedExperimentList!]! @authorized
  """
  Returns predefined experiment details of selected experiments
  """
  getPredefinedExperiment(
    hubID: ID!
    experimentName: [String!]!
    projectID: ID!
  ): [PredefinedExperimentList!]! @authorized
  """
  Query to get experiment stats
  """
  getChaosHubStats(projectID: ID!): GetChaosHubStatsResponse!  @authorized
}

extend type Mutation {
  # CHAOS-HUB OPERATIONS
  """
  Add a ChaosHub (includes the git clone operation)
  """
  addChaosHub(  projectID: ID!,request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Add a ChaosHub (remote hub download)
  """
  addRemoteChaosHub(projectID: ID!,request: CreateRemoteChaosHub!): ChaosHub! @authorized

  """
  Save a ChaosHub configuration without cloning it
  """
  saveChaosHub(projectID: ID!,request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Sync changes from the Git repository of a ChaosHub
  """
  syncChaosHub(id: ID!, projectID: ID!): String! @authorized

  """
  Generates Private and Public key for SSH authentication
  """
  generateSSHKey: SSHKey! @authorized

  """
  Update the configuration of a ChaosHub
  """
  updateChaosHub(projectID: ID!,request: UpdateChaosHubRequest!): ChaosHub! @authorized

  """
  Delete the ChaosHub
  """
  deleteChaosHub(projectID: ID!, hubID: ID!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/common.graphqls", Input: `
interface ResourceDetails {
    name: String!
    description: String
    tags:[String!]
}

interface Audit {
    updatedAt: String
    createdAt: String
    updatedBy: UserDetails
    createdBy: UserDetails
}

type UserDetails {
    userID: String!
    username: String!
    email: String!
}

`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/environment.graphqls", Input: `
enum EnvironmentType{
    PROD
    NON_PROD
}

type Environment implements ResourceDetails & Audit {
    projectID:String!
    environmentID : String!
    name: String!
    description: String
    tags:[String!]
    type: EnvironmentType!
    createdAt: String!
    createdBy: UserDetails
    updatedBy: UserDetails
    updatedAt: String!
    isRemoved: Boolean
    infraIDs:[String!]
}

input CreateEnvironmentRequest{
    environmentID : String! #check if human readable ID is required
    name: String!
    type: EnvironmentType!
    description: String
    tags:[String!]
}

input UpdateEnvironmentRequest{
    environmentID : String!
    name: String
    description: String
    tags:[String]
    type: EnvironmentType
}

"""
Defines filter options for infras
"""
input EnvironmentFilterInput {
    """
    Name of the environment
    """
    name: String
    """
    ID of the environment
    """
    description: String
    """
    Type name of environment
    """
    type: String
    """
    Tags of an environment
    """
    tags: [EnvironmentType]
}
enum EnvironmentSortingField {
    NAME
    TIME
}

"""
Defines sorting options for experiment
"""
input EnvironmentSortInput {
    """
    Field in which sorting will be done
    """
    field: EnvironmentSortingField!
    """
    Bool value indicating whether the sorting will be done in ascending order
    """
    ascending: Boolean
}


input ListEnvironmentRequest{
    """
    Environment ID
    """
    environmentIDs: [ID!]
    """
    Details for fetching paginated data
    """
    pagination: Pagination
    """
    Details for fetching filtered data
    """
    filter: EnvironmentFilterInput
    """
    Details for fetching sorted data
    """
    sort: EnvironmentSortInput
}

type ListEnvironmentResponse{
    """
    Total number of environment
    """
    totalNoOfEnvironments: Int!
    environments:[Environment]
}

extend type Query {

    getEnvironment(projectID: ID!, environmentID: ID!) : Environment @authorized
    listEnvironments (projectID: ID!, request: ListEnvironmentRequest): ListEnvironmentResponse @authorized
}

extend type Mutation{
    createEnvironment( projectID:ID!,request:CreateEnvironmentRequest): Environment @authorized
    updateEnvironment( projectID:ID!,request:UpdateEnvironmentRequest): String! @authorized
    deleteEnvironment(projectID:ID!,environmentID: ID!): String! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/gitops.graphqls", Input: `
"""
Defines the SSHKey details
"""
type SSHKey {
    """
    Public SSH key authenticating into git repository
    """
    publicKey: String!
    """
    Private SSH key authenticating into git repository
    """
    privateKey: String!
}

"""
Details of setting a Git repository
"""
input GitConfig {
    """
    ID of the project where GitOps is configured
    """
    projectID: ID!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String!
    """
    URL of the Git repository
    """
    repoURL: String!
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType!
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

"""
Response received after configuring GitOps
"""
type GitConfigResponse {
    """
    Bool value indicating whether GitOps is enabled or not
    """
    enabled: Boolean!
    """
    ID of the project where GitOps is configured
    """
    projectID: String!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String
    """
    URL of the Git repository
    """
    repoURL: String
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

extend type Query {
    # GIT-OPS OPERATIONS
    """
    Returns the git configuration for gitops
    """
    getGitOpsDetails(projectID: ID!): GitConfigResponse! @authorized
}

extend type Mutation {
    # GIT-OPS OPERATIONS
    """
    Sends workflow run request(single run workflow only) to agent on gitops notification
    """
    # authorized directive not required
    gitopsNotifier(clusterInfo: InfraIdentity!, workflowID: ID!): String!

    """
    Enables gitops settings in the project
    """
    enableGitOps(configurations: GitConfig!): Boolean! @authorized

    """
    Disables gitops settings in the project
    """
    disableGitOps(projectID: String!): Boolean! @authorized

    """
    Updates gitops settings in the project
    """
    updateGitOps(configurations: GitConfig!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/image_registry.graphqls", Input: `"""
Defines details for image registry
"""
type ImageRegistry {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines input data for querying the details of an image registry
"""
input ImageRegistryInput {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines response data for image registry
"""
type ImageRegistryResponse implements Audit {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Information Image Registry
  """
  imageRegistryInfo: ImageRegistry
  """
  ID of the image registry
  """
  imageRegistryID: String!
  """
  ID of the project in which image registry is created
  """
  projectID: String!
  """
  Timestamp when the image registry was last updated
  """
  updatedAt: String
  """
  Timestamp when the image registry was created
  """
  createdAt: String
  """
  User who created the infra
  """
  createdBy: UserDetails
  """
  User who has updated the infra
  """
  updatedBy: UserDetails
  """
  Bool value indicating if the image registry has been removed
  """
  isRemoved: Boolean
}

extend type Query {
  # IMAGE REGISTRY OPERATIONS
  listImageRegistry(projectID: String!): [ImageRegistryResponse!] @authorized

  getImageRegistry(
    imageRegistryID: String!
    projectID: String!
  ): ImageRegistryResponse! @authorized
}

extend type Mutation {
  # IMAGE REGISTRY OPERATIONS
  """
  Create an Image Registry configuration
  """
  createImageRegistry(
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Update the Image Registry configuration
  """
  updateImageRegistry(
    imageRegistryID: String!
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Delete the Image Registry
  """
  deleteImageRegistry(imageRegistryID: String!, projectID: String!): String!
  @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/project.graphqls", Input: `enum Invitation {
  Accepted
  Pending
}

enum MemberRole {
  Owner
  Editor
  Viewer
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNCreateChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addRemoteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.CreateRemoteChaosHub
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNCreateRemoteChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateRemoteChaosHub(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_chaosExperimentRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRunRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRunRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmInfraRegistration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.InfraIdentity
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ChaosExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.CreateEnvironmentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOCreateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateEnvironmentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg1, err = ec.unmarshalNImageRegistryInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["experimentID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["experimentRunID"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentRunID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["environmentID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["environmentID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteInfra_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_disableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_enableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["configurations"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configurations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_getManifestWithInfraID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["accessKey"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accessKey"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_gitopsNotifier_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.InfraIdentity
	if tmp, ok := rawArgs["clusterInfo"]; ok {
		arg0, err = ec.unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterInfo"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_kubeObj_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectData
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectData2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObjectData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_podLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLog
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLog2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPodLog(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerInfra_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.RegisterInfraRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNRegisterInfraRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRegisterInfraRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_runChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["experimentID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SaveChaosExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNSaveChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSaveChaosExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNCreateChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_syncChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ChaosExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.UpdateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNUpdateChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.UpdateEnvironmentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOUpdateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateEnvironmentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["configurations"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configurations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	var arg2 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg2, err = ec.unmarshalNImageRegistryInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getChaosFault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getChaosHubStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["chaosHubID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chaosHubID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["environmentID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["environmentID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentRunStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["experimentRunID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentRunID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["experimentID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getGitOpsDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getInfraDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getInfraManifest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["upgrade"]; ok {
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upgrade"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getInfraStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInfra_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getPredefinedExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["experimentName"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getVersionDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listChaosFaults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.ListChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOListChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listEnvironments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.ListEnvironmentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOListEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListEnvironmentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listExperimentRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ListExperimentRunRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNListExperimentRunRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentRunRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ListExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNListExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listInfras_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.ListInfraRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOListInfraRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListInfraRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listPredefinedExperiments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_getInfraEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getKubeObject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObjectRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getPodLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLogRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLogRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPodLogRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_infraConnect_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.InfraIdentity
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActionPayload_requestID(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_requestType(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_k8sManifest(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.K8sManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_externalData(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_username(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_categories(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Categories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_vendor(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_repository(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_support(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Support, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_chartDescription(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChartDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_experimentDescription(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_isCustomExperiment(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomExperiment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_tags(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_name(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_tags(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_description(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isAvailable(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_totalFaults(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalFaults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_name(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPublicKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_tags(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_description(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_kind(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Metadata)
	fc.Result = res
	return ec.marshalNMetadata2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_spec(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Spec)
	fc.Result = res
	return ec.marshalNSpec2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_packageInfo(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PackageInformation)
	fc.Result = res
	return ec.marshalNPackageInformation2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPackageInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmInfraRegistrationResponse_isInfraConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmInfraRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmInfraRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInfraConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmInfraRegistrationResponse_newAccessKey(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmInfraRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmInfraRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewAccessKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmInfraRegistrationResponse_infraID(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmInfraRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmInfraRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_environmentID(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_name(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_description(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_tags(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_type(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EnvironmentType)
	fc.Result = res
	return ec.marshalNEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_infraIDs(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EventMetadata_faultName(ctx context.Context, field graphql.CollectedField, obj *model.EventMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EventMetadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EventMetadata_serviceIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.EventMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EventMetadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EventMetadata_environmentIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.EventMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EventMetadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_experimentType(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_experimentManifest(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_name(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_description(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_weightages(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightages(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_isCustomExperiment(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomExperiment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_infra(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infra, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalOInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_tags(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_recentExperimentRunDetails(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecentExperimentRunDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RecentExperimentRun)
	fc.Result = res
	return ec.marshalORecentExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRecentExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_engineDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EngineDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_experimentDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentType(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_weightages(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightages(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_infra(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infra, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentManifest(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_phase(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ExperimentRunStatus)
	fc.Result = res
	return ec.marshalNExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_resiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsPassed(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsFailed(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsAwaited(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsAwaited, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsStopped(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsStopped, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsNa(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsNa, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_totalFaults(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalFaults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_executionData(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_name(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_CSV(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_desc(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultDetails_fault(ctx context.Context, field graphql.CollectedField, obj *model.FaultDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultDetails_engine(ctx context.Context, field graphql.CollectedField, obj *model.FaultDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Engine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultDetails_csv(ctx context.Context, field graphql.CollectedField, obj *model.FaultDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_name(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_displayName(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_description(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_plan(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GetChaosHubStatsResponse_totalChaosHubs(ctx context.Context, field graphql.CollectedField, obj *model.GetChaosHubStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetChaosHubStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalChaosHubs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentResponse_experimentDetails(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Experiment)
	fc.Result = res
	return ec.marshalNExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentResponse_averageResiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AverageResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalCompletedExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCompletedExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalTerminatedExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTerminatedExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalRunningExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRunningExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalStoppedExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalStoppedExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalErroredExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalErroredExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentStatsResponse_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentStatsResponse_totalExpCategorizedByResiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExpCategorizedByResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResilienceScoreCategory)
	fc.Result = res
	return ec.marshalNResilienceScoreCategory2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelResilienceScoreCategory(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalInfrastructures(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalInfrastructures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalActiveInfrastructure(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalActiveInfrastructure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalInactiveInfrastructures(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalInactiveInfrastructures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalConfirmedInfrastructure(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalConfirmedInfrastructure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalNonConfirmedInfrastructures(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNonConfirmedInfrastructures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_enabled(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_branch(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_authType(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuthType)
	fc.Result = res
	return ec.marshalOAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_userName(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_password(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRepoName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRepoName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryType(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretNamespace(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_enableRegistry(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnableRegistry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryInfo(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistry)
	fc.Result = res
	return ec.marshalOImageRegistry2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraID(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_name(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_description(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_tags(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_environmentID(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_platformName(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_isActive(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_isInfraConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInfraConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_noOfExperiments(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_noOfExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_token(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraNamespace(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraScope(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraScope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraNsExists(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraNsExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraSaExists(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraSaExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_lastExperimentTimestamp(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastExperimentTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_startTime(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_version(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraType(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InfrastructureType)
	fc.Result = res
	return ec.marshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_updateStatus(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateStatus)
	fc.Result = res
	return ec.marshalNUpdateStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraActionResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.InfraActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraActionResponse_action(ctx context.Context, field graphql.CollectedField, obj *model.InfraActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ActionPayload)
	fc.Result = res
	return ec.marshalNActionPayload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelActionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_eventID(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_eventType(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_eventName(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_description(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_infra(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infra, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraVersionDetails_latestVersion(ctx context.Context, field graphql.CollectedField, obj *model.InfraVersionDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraVersionDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraVersionDetails_compatibleVersions(ctx context.Context, field graphql.CollectedField, obj *model.InfraVersionDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraVersionDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompatibleVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObject_namespace(ctx context.Context, field graphql.CollectedField, obj *model.KubeObject) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObject",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObject_data(ctx context.Context, field graphql.CollectedField, obj *model.KubeObject) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObject",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ObjectData)
	fc.Result = res
	return ec.marshalNObjectData2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelObjectData(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_infraID(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_kubeObj(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KubeObj, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.KubeObject)
	fc.Result = res
	return ec.marshalNKubeObject2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObject(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_name(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_url(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListEnvironmentResponse_totalNoOfEnvironments(ctx context.Context, field graphql.CollectedField, obj *model.ListEnvironmentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListEnvironmentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfEnvironments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListEnvironmentResponse_environments(ctx context.Context, field graphql.CollectedField, obj *model.ListEnvironmentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListEnvironmentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentResponse_totalNoOfExperiments(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentResponse_experiments(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Experiment)
	fc.Result = res
	return ec.marshalNExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentRunResponse_totalNoOfExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentRunResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentRunResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentRunResponse_experimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentRunResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentRunResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ExperimentRun)
	fc.Result = res
	return ec.marshalNExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _ListInfraResponse_totalNoOfInfras(ctx context.Context, field graphql.CollectedField, obj *model.ListInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfInfras, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListInfraResponse_infras(ctx context.Context, field graphql.CollectedField, obj *model.ListInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infras, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_name(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_email(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_version(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Annotation)
	fc.Result = res
	return ec.marshalNAnnotation2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateChaosExperiment(rctx, args["request"].(model.ChaosExperimentRequest), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosExperimentResponse)
	fc.Result = res
	return ec.marshalNChaosExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_saveChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_saveChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveChaosExperiment(rctx, args["request"].(model.SaveChaosExperimentRequest), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_runChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_runChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RunChaosExperiment(rctx, args["experimentID"].(string), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RunChaosExperimentResponse)
	fc.Result = res
	return ec.marshalNRunChaosExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRunChaosExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateChaosExperiment(rctx, args["request"].(*model.ChaosExperimentRequest), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosExperimentResponse)
	fc.Result = res
	return ec.marshalNChaosExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteChaosExperiment(rctx, args["experimentID"].(string), args["experimentRunID"].(*string), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_chaosExperimentRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_chaosExperimentRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ChaosExperimentRun(rctx, args["request"].(model.ExperimentRunRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_registerInfra(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_registerInfra_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RegisterInfra(rctx, args["projectID"].(string), args["request"].(model.RegisterInfraRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegisterInfraResponse)
	fc.Result = res
	return ec.marshalNRegisterInfraResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRegisterInfraResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_confirmInfraRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_confirmInfraRegistration_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmInfraRegistration(rctx, args["request"].(model.InfraIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConfirmInfraRegistrationResponse)
	fc.Result = res
	return ec.marshalNConfirmInfraRegistrationResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelConfirmInfraRegistrationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteInfra(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteInfra_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteInfra(rctx, args["projectID"].(string), args["infraID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_getManifestWithInfraID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_getManifestWithInfraID_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetManifestWithInfraID(rctx, args["projectID"].(string), args["infraID"].(string), args["accessKey"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_podLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_podLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PodLog(rctx, args["request"].(model.PodLog))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_kubeObj(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_kubeObj_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().KubeObj(rctx, args["request"].(model.KubeObjectData))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddChaosHub(rctx, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addRemoteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addRemoteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddRemoteChaosHub(rctx, args["projectID"].(string), args["request"].(model.CreateRemoteChaosHub))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_saveChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_saveChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SaveChaosHub(rctx, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_syncChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_syncChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncChaosHub(rctx, args["id"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_generateSSHKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().GenerateSSHKey(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SSHKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.SSHKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SSHKey)
	fc.Result = res
	return ec.marshalNSSHKey2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSSHKey(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateChaosHub(rctx, args["projectID"].(string), args["request"].(model.UpdateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteChaosHub(rctx, args["projectID"].(string), args["hubID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEnvironment(rctx, args["projectID"].(string), args["request"].(*model.CreateEnvironmentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEnvironment(rctx, args["projectID"].(string), args["request"].(*model.UpdateEnvironmentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEnvironment(rctx, args["projectID"].(string), args["environmentID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_gitopsNotifier(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_gitopsNotifier_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GitopsNotifier(rctx, args["clusterInfo"].(model.InfraIdentity), args["workflowID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_enableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_enableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EnableGitOps(rctx, args["configurations"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_disableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_disableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DisableGitOps(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGitOps(rctx, args["configurations"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateImageRegistry(rctx, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectData_labels(ctx context.Context, field graphql.CollectedField, obj *model.ObjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectData_name(ctx context.Context, field graphql.CollectedField, obj *model.ObjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_packageName(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_experiments(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Experiments)
	fc.Result = res
	return ec.marshalNExperiments2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiments(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podName(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podType(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_log(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Log, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedExperimentList_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedExperimentList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedExperimentList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedExperimentList_experimentCSV(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedExperimentList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedExperimentList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentCsv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedExperimentList_experimentManifest(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedExperimentList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedExperimentList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Provider_name(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Provider",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperimentRun(rctx, args["projectID"].(string), args["experimentRunID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ExperimentRun)
	fc.Result = res
	return ec.marshalNExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listExperimentRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listExperimentRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListExperimentRun(rctx, args["projectID"].(string), args["request"].(model.ListExperimentRunRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListExperimentRunResponse)
	fc.Result = res
	return ec.marshalNListExperimentRunResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentRunResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperiment(rctx, args["projectID"].(string), args["experimentID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetExperimentResponse)
	fc.Result = res
	return ec.marshalNGetExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListExperiment(rctx, args["projectID"].(string), args["request"].(model.ListExperimentRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListExperimentResponse)
	fc.Result = res
	return ec.marshalNListExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentRunStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentRunStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperimentRunStats(rctx, args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetExperimentRunStatsResponse)
	fc.Result = res
	return ec.marshalNGetExperimentRunStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentRunStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperimentStats(rctx, args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetExperimentStatsResponse)
	fc.Result = res
	return ec.marshalNGetExperimentStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfra(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfra_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfra(rctx, args["projectID"].(string), args["infraID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Infra); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Infra`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listInfras(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listInfras_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListInfras(rctx, args["projectID"].(string), args["request"].(*model.ListInfraRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListInfraResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ListInfraResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListInfraResponse)
	fc.Result = res
	return ec.marshalNListInfraResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListInfraResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfraDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfraDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfraDetails(rctx, args["infraID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Infra); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Infra`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfraManifest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfraManifest_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfraManifest(rctx, args["infraID"].(string), args["upgrade"].(bool), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfraStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfraStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfraStats(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GetInfraStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.GetInfraStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetInfraStatsResponse)
	fc.Result = res
	return ec.marshalNGetInfraStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetInfraStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getVersionDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getVersionDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetVersionDetails(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.InfraVersionDetails); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.InfraVersionDetails`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.InfraVersionDetails)
	fc.Result = res
	return ec.marshalNInfraVersionDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraVersionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getServerVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetServerVersion(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ServerVersionResponse)
	fc.Result = res
	return ec.marshalNServerVersionResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelServerVersionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listChaosFaults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listChaosFaults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListChaosFaults(rctx, args["hubID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Chart); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Chart`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Chart)
	fc.Result = res
	return ec.marshalNChart2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChart(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getChaosFault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getChaosFault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetChaosFault(rctx, args["projectID"].(string), args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.FaultDetails); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.FaultDetails`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FaultDetails)
	fc.Result = res
	return ec.marshalNFaultDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListChaosHub(rctx, args["projectID"].(string), args["request"].(*model.ListChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ChaosHubStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHubStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChaosHubStatus)
	fc.Result = res
	return ec.marshalNChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetChaosHub(rctx, args["projectID"].(string), args["chaosHubID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHubStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHubStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHubStatus)
	fc.Result = res
	return ec.marshalNChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listPredefinedExperiments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listPredefinedExperiments_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListPredefinedExperiments(rctx, args["hubID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PredefinedExperimentList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.PredefinedExperimentList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PredefinedExperimentList)
	fc.Result = res
	return ec.marshalNPredefinedExperimentList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPredefinedExperimentList(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPredefinedExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPredefinedExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPredefinedExperiment(rctx, args["hubID"].(string), args["experimentName"].([]string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PredefinedExperimentList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.PredefinedExperimentList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PredefinedExperimentList)
	fc.Result = res
	return ec.marshalNPredefinedExperimentList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPredefinedExperimentList(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getChaosHubStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getChaosHubStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetChaosHubStats(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GetChaosHubStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.GetChaosHubStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetChaosHubStatsResponse)
	fc.Result = res
	return ec.marshalNGetChaosHubStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetChaosHubStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEnvironment(rctx, args["projectID"].(string), args["environmentID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listEnvironments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listEnvironments_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListEnvironments(rctx, args["projectID"].(string), args["request"].(*model.ListEnvironmentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListEnvironmentResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ListEnvironmentResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ListEnvironmentResponse)
	fc.Result = res
	return ec.marshalOListEnvironmentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListEnvironmentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getGitOpsDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getGitOpsDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetGitOpsDetails(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GitConfigResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.GitConfigResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GitConfigResponse)
	fc.Result = res
	return ec.marshalNGitConfigResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGitConfigResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListImageRegistry(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalOImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_phase(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_resiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_infraID(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_name(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_manifest(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ResilienceScoreCategory_id(ctx context.Context, field graphql.CollectedField, obj *model.ResilienceScoreCategory) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResilienceScoreCategory",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ResilienceScoreCategory_count(ctx context.Context, field graphql.CollectedField, obj *model.ResilienceScoreCategory) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResilienceScoreCategory",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _RunChaosExperimentResponse_notifyID(ctx context.Context, field graphql.CollectedField, obj *model.RunChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RunChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotifyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_publicKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_key(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_value(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_displayName(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_categoryDescription(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CategoryDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_keywords(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maturity(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maturity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maintainers(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_minKubeVersion(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinKubeVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_provider(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Provider)
	fc.Result = res
	return ec.marshalNProvider2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelProvider(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_links(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Links, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Link)
	fc.Result = res
	return ec.marshalNLink2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelLink(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_faults(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FaultList)
	fc.Result = res
	return ec.marshalNFaultList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultList(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_experiments(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosExpCRDLink(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosExpCRDLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_platforms(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platforms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosType(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StopExperimentRunsRequest_projectID(ctx context.Context, field graphql.CollectedField, obj *model.StopExperimentRunsRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "StopExperimentRunsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StopExperimentRunsRequest_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.StopExperimentRunsRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "StopExperimentRunsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StopExperimentRunsRequest_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.StopExperimentRunsRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "StopExperimentRunsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Subscription_getInfraEvents(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getInfraEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetInfraEvents(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.InfraEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.InfraEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.InfraEventResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNInfraEventResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraEventResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_infraConnect(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_infraConnect_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().InfraConnect(rctx, args["request"].(model.InfraIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.InfraActionResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNInfraActionResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraActionResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getPodLog(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getPodLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().GetPodLog(rctx, args["request"].(model.PodLogRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.PodLogResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNPodLogResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPodLogResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getKubeObject(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getKubeObject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().GetKubeObject(rctx, args["request"].(model.KubeObjectRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.KubeObjectResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNKubeObjectResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObjectResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _UserDetails_userID(ctx context.Context, field graphql.CollectedField, obj *model.UserDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UserDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserDetails_username(ctx context.Context, field graphql.CollectedField, obj *model.UserDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UserDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserDetails_email(ctx context.Context, field graphql.CollectedField, obj *model.UserDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UserDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_faultName(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_weightage(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputChaosExperimentRequest(ctx context.Context, obj interface{}) (model.ChaosExperimentRequest, error) {
	var it model.ChaosExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentID":
			var err error
			it.ExperimentID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runExperiment":
			var err error
			it.RunExperiment, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentManifest":
			var err error
			it.ExperimentManifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentType":
			var err error
			it.ExperimentType, err = ec.unmarshalOExperimentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentType(ctx, v)
			if err != nil {
				return it, err
			}
		case "cronSyntax":
			var err error
			it.CronSyntax, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentDescription":
			var err error
			it.ExperimentDescription, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightages":
			var err error
			it.Weightages, err = ec.unmarshalNWeightagesInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightagesInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "isCustomExperiment":
			var err error
			it.IsCustomExperiment, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChaosHubFilterInput(ctx context.Context, obj interface{}) (model.ChaosHubFilterInput, error) {
	var it model.ChaosHubFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "chaosHubName":
			var err error
			it.ChaosHubName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCloningInput(ctx context.Context, obj interface{}) (model.CloningInput, error) {
	var it model.CloningInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDefault":
			var err error
			it.IsDefault, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChaosHubRequest(ctx context.Context, obj interface{}) (model.CreateChaosHubRequest, error) {
	var it model.CreateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEnvironmentRequest(ctx context.Context, obj interface{}) (model.CreateEnvironmentRequest, error) {
	var it model.CreateEnvironmentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "environmentID":
			var err error
			it.EnvironmentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRemoteChaosHub(ctx context.Context, obj interface{}) (model.CreateRemoteChaosHub, error) {
	var it model.CreateRemoteChaosHub
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateRange(ctx context.Context, obj interface{}) (model.DateRange, error) {
	var it model.DateRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvironmentFilterInput(ctx context.Context, obj interface{}) (model.EnvironmentFilterInput, error) {
	var it model.EnvironmentFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvironmentSortInput(ctx context.Context, obj interface{}) (model.EnvironmentSortInput, error) {
	var it model.EnvironmentSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNEnvironmentSortingField2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "ascending":
			var err error
			it.Ascending, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventMetadataInput(ctx context.Context, obj interface{}) (model.EventMetadataInput, error) {
	var it model.EventMetadataInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "faultName":
			var err error
			it.FaultName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serviceIdentifier":
			var err error
			it.ServiceIdentifier, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "environmentIdentifier":
			var err error
			it.EnvironmentIdentifier, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentFilterInput(ctx context.Context, obj interface{}) (model.ExperimentFilterInput, error) {
	var it model.ExperimentFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraName":
			var err error
			it.InfraName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraActive":
			var err error
			it.InfraActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "scheduleType":
			var err error
			it.ScheduleType, err = ec.unmarshalOScheduleType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelScheduleType(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalODateRange2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraTypes":
			var err error
			it.InfraTypes, err = ec.unmarshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRequest(ctx context.Context, obj interface{}) (model.ExperimentRequest, error) {
	var it model.ExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "category":
			var err error
			it.Category, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hubID":
			var err error
			it.HubID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRunFilterInput(ctx context.Context, obj interface{}) (model.ExperimentRunFilterInput, error) {
	var it model.ExperimentRunFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentType":
			var err error
			it.ExperimentType, err = ec.unmarshalOScheduleType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelScheduleType(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentStatus":
			var err error
			it.ExperimentStatus, err = ec.unmarshalOExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalODateRange2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunStatus":
			var err error
			it.ExperimentRunStatus, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraTypes":
			var err error
			it.InfraTypes, err = ec.unmarshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRunRequest(ctx context.Context, obj interface{}) (model.ExperimentRunRequest, error) {
	var it model.ExperimentRunRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentID":
			var err error
			it.ExperimentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "notifyID":
			var err error
			it.NotifyID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "executionData":
			var err error
			it.ExecutionData, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "revisionID":
			var err error
			it.RevisionID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "completed":
			var err error
			it.Completed, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isRemoved":
			var err error
			it.IsRemoved, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy":
			var err error
			it.UpdatedBy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRunSortInput(ctx context.Context, obj interface{}) (model.ExperimentRunSortInput, error) {
	var it model.ExperimentRunSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNExperimentSortingField2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "ascending":
			var err error
			it.Ascending, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentSortInput(ctx context.Context, obj interface{}) (model.ExperimentSortInput, error) {
	var it model.ExperimentSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNExperimentSortingField2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "ascending":
			var err error
			it.Ascending, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitConfig(ctx context.Context, obj interface{}) (model.GitConfig, error) {
	var it model.GitConfig
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "branch":
			var err error
			it.Branch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageRegistryInput(ctx context.Context, obj interface{}) (model.ImageRegistryInput, error) {
	var it model.ImageRegistryInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "isDefault":
			var err error
			it.IsDefault, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryName":
			var err error
			it.ImageRegistryName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRepoName":
			var err error
			it.ImageRepoName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryType":
			var err error
			it.ImageRegistryType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretName":
			var err error
			it.SecretName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretNamespace":
			var err error
			it.SecretNamespace, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "enableRegistry":
			var err error
			it.EnableRegistry, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInfraFilterInput(ctx context.Context, obj interface{}) (model.InfraFilterInput, error) {
	var it model.InfraFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName":
			var err error
			it.PlatformName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraScope":
			var err error
			it.InfraScope, err = ec.unmarshalOINFRA_SCOPE2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraScope(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInfraIdentity(ctx context.Context, obj interface{}) (model.InfraIdentity, error) {
	var it model.InfraIdentity
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeGVRRequest(ctx context.Context, obj interface{}) (model.KubeGVRRequest, error) {
	var it model.KubeGVRRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "group":
			var err error
			it.Group, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectData(ctx context.Context, obj interface{}) (model.KubeObjectData, error) {
	var it model.KubeObjectData
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObj":
			var err error
			it.KubeObj, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectRequest(ctx context.Context, obj interface{}) (model.KubeObjectRequest, error) {
	var it model.KubeObjectRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObjRequest":
			var err error
			it.KubeObjRequest, err = ec.unmarshalOKubeGVRRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeGVRRequest(ctx, v)
			if err != nil {
				return it, err
			}
		case "objectType":
			var err error
			it.ObjectType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workloads":
			var err error
			it.Workloads, err = ec.unmarshalOWorkload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWorkload(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListChaosHubRequest(ctx context.Context, obj interface{}) (model.ListChaosHubRequest, error) {
	var it model.ListChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "chaosHubIDs":
			var err error
			it.ChaosHubIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOChaosHubFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListEnvironmentRequest(ctx context.Context, obj interface{}) (model.ListEnvironmentRequest, error) {
	var it model.ListEnvironmentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "environmentIDs":
			var err error
			it.EnvironmentIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOEnvironmentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOEnvironmentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListExperimentRequest(ctx context.Context, obj interface{}) (model.ListExperimentRequest, error) {
	var it model.ListExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentIDs":
			var err error
			it.ExperimentIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOExperimentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOExperimentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListExperimentRunRequest(ctx context.Context, obj interface{}) (model.ListExperimentRunRequest, error) {
	var it model.ListExperimentRunRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentRunIDs":
			var err error
			it.ExperimentRunIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentIDs":
			var err error
			it.ExperimentIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOExperimentRunSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOExperimentRunFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListInfraRequest(ctx context.Context, obj interface{}) (model.ListInfraRequest, error) {
	var it model.ListInfraRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraIDs":
			var err error
			it.InfraIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "environmentIDs":
			var err error
			it.EnvironmentIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOInfraFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewInfraEventRequest(ctx context.Context, obj interface{}) (model.NewInfraEventRequest, error) {
	var it model.NewInfraEventRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eventName":
			var err error
			it.EventName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj interface{}) (model.Pagination, error) {
	var it model.Pagination
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "page":
			var err error
			it.Page, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLog(ctx context.Context, obj interface{}) (model.PodLog, error) {
	var it model.PodLog
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "log":
			var err error
			it.Log, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLogRequest(ctx context.Context, obj interface{}) (model.PodLogRequest, error) {
	var it model.PodLogRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podNamespace":
			var err error
			it.PodNamespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expPod":
			var err error
			it.ExpPod, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runnerPod":
			var err error
			it.RunnerPod, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosNamespace":
			var err error
			it.ChaosNamespace, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegisterInfraRequest(ctx context.Context, obj interface{}) (model.RegisterInfraRequest, error) {
	var it model.RegisterInfraRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "environmentID":
			var err error
			it.EnvironmentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infrastructureType":
			var err error
			it.InfrastructureType, err = ec.unmarshalNInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName":
			var err error
			it.PlatformName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraNamespace":
			var err error
			it.InfraNamespace, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serviceAccount":
			var err error
			it.ServiceAccount, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraScope":
			var err error
			it.InfraScope, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraNsExists":
			var err error
			it.InfraNsExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraSaExists":
			var err error
			it.InfraSaExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipSsl":
			var err error
			it.SkipSsl, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeSelector":
			var err error
			it.NodeSelector, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tolerations":
			var err error
			it.Tolerations, err = ec.unmarshalOToleration2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelToleration(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveChaosExperimentRequest(ctx context.Context, obj interface{}) (model.SaveChaosExperimentRequest, error) {
	var it model.SaveChaosExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOExperimentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentType(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manifest":
			var err error
			it.Manifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToleration(ctx context.Context, obj interface{}) (model.Toleration, error) {
	var it model.Toleration
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tolerationSeconds":
			var err error
			it.TolerationSeconds, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "key":
			var err error
			it.Key, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "operator":
			var err error
			it.Operator, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "effect":
			var err error
			it.Effect, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateChaosHubRequest(ctx context.Context, obj interface{}) (model.UpdateChaosHubRequest, error) {
	var it model.UpdateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEnvironmentRequest(ctx context.Context, obj interface{}) (model.UpdateEnvironmentRequest, error) {
	var it model.UpdateEnvironmentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "environmentID":
			var err error
			it.EnvironmentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeightagesInput(ctx context.Context, obj interface{}) (model.WeightagesInput, error) {
	var it model.WeightagesInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "faultName":
			var err error
			it.FaultName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightage":
			var err error
			it.Weightage, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkload(ctx context.Context, obj interface{}) (model.Workload, error) {
	var it model.Workload
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kind":
			var err error
			it.Kind, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Audit(ctx context.Context, sel ast.SelectionSet, obj model.Audit) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ExperimentRun:
		return ec._ExperimentRun(ctx, sel, &obj)
	case *model.ExperimentRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._ExperimentRun(ctx, sel, obj)
	case model.RecentExperimentRun:
		return ec._RecentExperimentRun(ctx, sel, &obj)
	case *model.RecentExperimentRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._RecentExperimentRun(ctx, sel, obj)
	case model.Experiment:
		return ec._Experiment(ctx, sel, &obj)
	case *model.Experiment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Experiment(ctx, sel, obj)
	case model.Infra:
		return ec._Infra(ctx, sel, &obj)
	case *model.Infra:
		if obj == nil {
			return graphql.Null
		}
		return ec._Infra(ctx, sel, obj)
	case model.ChaosHub:
		return ec._ChaosHub(ctx, sel, &obj)
	case *model.ChaosHub:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHub(ctx, sel, obj)
	case model.ChaosHubStatus:
		return ec._ChaosHubStatus(ctx, sel, &obj)
	case *model.ChaosHubStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHubStatus(ctx, sel, obj)
	case model.Environment:
		return ec._Environment(ctx, sel, &obj)
	case *model.Environment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Environment(ctx, sel, obj)
	case model.ImageRegistryResponse:
		return ec._ImageRegistryResponse(ctx, sel, &obj)
	case *model.ImageRegistryResponse:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageRegistryResponse(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ResourceDetails(ctx context.Context, sel ast.SelectionSet, obj model.ResourceDetails) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Experiment:
		return ec._Experiment(ctx, sel, &obj)
	case *model.Experiment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Experiment(ctx, sel, obj)
	case model.Infra:
		return ec._Infra(ctx, sel, &obj)
	case *model.Infra:
		if obj == nil {
			return graphql.Null
		}
		return ec._Infra(ctx, sel, obj)
	case model.ChaosHub:
		return ec._ChaosHub(ctx, sel, &obj)
	case *model.ChaosHub:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHub(ctx, sel, obj)
	case model.ChaosHubStatus:
		return ec._ChaosHubStatus(ctx, sel, &obj)
	case *model.ChaosHubStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHubStatus(ctx, sel, obj)
	case model.Environment:
		return ec._Environment(ctx, sel, &obj)
	case *model.Environment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Environment(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actionPayloadImplementors = []string{"ActionPayload"}

func (ec *executionContext) _ActionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ActionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionPayload")
		case "requestID":
			out.Values[i] = ec._ActionPayload_requestID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requestType":
			out.Values[i] = ec._ActionPayload_requestType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "k8sManifest":
			out.Values[i] = ec._ActionPayload_k8sManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "namespace":
			out.Values[i] = ec._ActionPayload_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "externalData":
			out.Values[i] = ec._ActionPayload_externalData(ctx, field, obj)
		case "username":
			out.Values[i] = ec._ActionPayload_username(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.Annotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "categories":
			out.Values[i] = ec._Annotation_categories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "vendor":
			out.Values[i] = ec._Annotation_vendor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Annotation_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repository":
			out.Values[i] = ec._Annotation_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "support":
			out.Values[i] = ec._Annotation_support(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chartDescription":
			out.Values[i] = ec._Annotation_chartDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosExperimentResponseImplementors = []string{"ChaosExperimentResponse"}

func (ec *executionContext) _ChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosExperimentResponse")
		case "experimentID":
			out.Values[i] = ec._ChaosExperimentResponse_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ChaosExperimentResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._ChaosExperimentResponse_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentName":
			out.Values[i] = ec._ChaosExperimentResponse_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentDescription":
			out.Values[i] = ec._ChaosExperimentResponse_experimentDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomExperiment":
			out.Values[i] = ec._ChaosExperimentResponse_isCustomExperiment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._ChaosExperimentResponse_tags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubImplementors = []string{"ChaosHub", "ResourceDetails", "Audit"}

func (ec *executionContext) _ChaosHub(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHub) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHub")
		case "id":
			out.Values[i] = ec._ChaosHub_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHub_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHub_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ChaosHub_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDefault":
			out.Values[i] = ec._ChaosHub_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._ChaosHub_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._ChaosHub_tags(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ChaosHub_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ChaosHub_updatedBy(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ChaosHub_description(ctx, field, obj)
		case "hubType":
			out.Values[i] = ec._ChaosHub_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHub_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHub_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHub_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHub_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHub_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHub_sshPrivateKey(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHub_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ChaosHub_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ChaosHub_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHub_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubStatusImplementors = []string{"ChaosHubStatus", "ResourceDetails", "Audit"}

func (ec *executionContext) _ChaosHubStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHubStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubStatusImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHubStatus")
		case "id":
			out.Values[i] = ec._ChaosHubStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHubStatus_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHubStatus_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isAvailable":
			out.Values[i] = ec._ChaosHubStatus_isAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalFaults":
			out.Values[i] = ec._ChaosHubStatus_totalFaults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExperiments":
			out.Values[i] = ec._ChaosHubStatus_totalExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._ChaosHubStatus_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubType":
			out.Values[i] = ec._ChaosHubStatus_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHubStatus_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHubStatus_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHubStatus_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHubStatus_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHubStatus_password(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHubStatus_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHubStatus_sshPrivateKey(ctx, field, obj)
		case "sshPublicKey":
			out.Values[i] = ec._ChaosHubStatus_sshPublicKey(ctx, field, obj)
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHubStatus_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._ChaosHubStatus_tags(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ChaosHubStatus_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ChaosHubStatus_updatedBy(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ChaosHubStatus_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ChaosHubStatus_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._ChaosHubStatus_description(ctx, field, obj)
		case "isDefault":
			out.Values[i] = ec._ChaosHubStatus_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chartImplementors = []string{"Chart"}

func (ec *executionContext) _Chart(ctx context.Context, sel ast.SelectionSet, obj *model.Chart) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chartImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Chart")
		case "apiVersion":
			out.Values[i] = ec._Chart_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kind":
			out.Values[i] = ec._Chart_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._Chart_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._Chart_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "packageInfo":
			out.Values[i] = ec._Chart_packageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var confirmInfraRegistrationResponseImplementors = []string{"ConfirmInfraRegistrationResponse"}

func (ec *executionContext) _ConfirmInfraRegistrationResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ConfirmInfraRegistrationResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, confirmInfraRegistrationResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfirmInfraRegistrationResponse")
		case "isInfraConfirmed":
			out.Values[i] = ec._ConfirmInfraRegistrationResponse_isInfraConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newAccessKey":
			out.Values[i] = ec._ConfirmInfraRegistrationResponse_newAccessKey(ctx, field, obj)
		case "infraID":
			out.Values[i] = ec._ConfirmInfraRegistrationResponse_infraID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var environmentImplementors = []string{"Environment", "ResourceDetails", "Audit"}

func (ec *executionContext) _Environment(ctx context.Context, sel ast.SelectionSet, obj *model.Environment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, environmentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Environment")
		case "projectID":
			out.Values[i] = ec._Environment_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "environmentID":
			out.Values[i] = ec._Environment_environmentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Environment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Environment_description(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Environment_tags(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Environment_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Environment_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdBy":
			out.Values[i] = ec._Environment_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Environment_updatedBy(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Environment_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._Environment_isRemoved(ctx, field, obj)
		case "infraIDs":
			out.Values[i] = ec._Environment_infraIDs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var eventMetadataImplementors = []string{"EventMetadata"}

func (ec *executionContext) _EventMetadata(ctx context.Context, sel ast.SelectionSet, obj *model.EventMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventMetadata")
		case "faultName":
			out.Values[i] = ec._EventMetadata_faultName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "serviceIdentifier":
			out.Values[i] = ec._EventMetadata_serviceIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "environmentIdentifier":
			out.Values[i] = ec._EventMetadata_environmentIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentImplementors = []string{"Experiment", "ResourceDetails", "Audit"}

func (ec *executionContext) _Experiment(ctx context.Context, sel ast.SelectionSet, obj *model.Experiment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiment")
		case "projectID":
			out.Values[i] = ec._Experiment_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentID":
			out.Values[i] = ec._Experiment_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentType":
			out.Values[i] = ec._Experiment_experimentType(ctx, field, obj)
		case "experimentManifest":
			out.Values[i] = ec._Experiment_experimentManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._Experiment_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Experiment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Experiment_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._Experiment_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomExperiment":
			out.Values[i] = ec._Experiment_isCustomExperiment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Experiment_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Experiment_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infra":
			out.Values[i] = ec._Experiment_infra(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._Experiment_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._Experiment_tags(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Experiment_createdBy(ctx, field, obj)
		case "recentExperimentRunDetails":
			out.Values[i] = ec._Experiment_recentExperimentRunDetails(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Experiment_updatedBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentDetailsImplementors = []string{"ExperimentDetails"}

func (ec *executionContext) _ExperimentDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ExperimentDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentDetails")
		case "engineDetails":
			out.Values[i] = ec._ExperimentDetails_engineDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentDetails":
			out.Values[i] = ec._ExperimentDetails_experimentDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentRunImplementors = []string{"ExperimentRun", "Audit"}

func (ec *executionContext) _ExperimentRun(ctx context.Context, sel ast.SelectionSet, obj *model.ExperimentRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentRunImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentRun")
		case "projectID":
			out.Values[i] = ec._ExperimentRun_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentRunID":
			out.Values[i] = ec._ExperimentRun_experimentRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentType":
			out.Values[i] = ec._ExperimentRun_experimentType(ctx, field, obj)
		case "experimentID":
			out.Values[i] = ec._ExperimentRun_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._ExperimentRun_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ExperimentRun_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ExperimentRun_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infra":
			out.Values[i] = ec._ExperimentRun_infra(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentName":
			out.Values[i] = ec._ExperimentRun_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentManifest":
			out.Values[i] = ec._ExperimentRun_experimentManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "phase":
			out.Values[i] = ec._ExperimentRun_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resiliencyScore":
			out.Values[i] = ec._ExperimentRun_resiliencyScore(ctx, field, obj)
		case "faultsPassed":
			out.Values[i] = ec._ExperimentRun_faultsPassed(ctx, field, obj)
		case "faultsFailed":
			out.Values[i] = ec._ExperimentRun_faultsFailed(ctx, field, obj)
		case "faultsAwaited":
			out.Values[i] = ec._ExperimentRun_faultsAwaited(ctx, field, obj)
		case "faultsStopped":
			out.Values[i] = ec._ExperimentRun_faultsStopped(ctx, field, obj)
		case "faultsNa":
			out.Values[i] = ec._ExperimentRun_faultsNa(ctx, field, obj)
		case "totalFaults":
			out.Values[i] = ec._ExperimentRun_totalFaults(ctx, field, obj)
		case "executionData":
			out.Values[i] = ec._ExperimentRun_executionData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._ExperimentRun_isRemoved(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ExperimentRun_updatedBy(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ExperimentRun_createdBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentsImplementors = []string{"Experiments"}

func (ec *executionContext) _Experiments(ctx context.Context, sel ast.SelectionSet, obj *model.Experiments) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiments")
		case "name":
			out.Values[i] = ec._Experiments_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CSV":
			out.Values[i] = ec._Experiments_CSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "desc":
			out.Values[i] = ec._Experiments_desc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var faultDetailsImplementors = []string{"FaultDetails"}

func (ec *executionContext) _FaultDetails(ctx context.Context, sel ast.SelectionSet, obj *model.FaultDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, faultDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FaultDetails")
		case "fault":
			out.Values[i] = ec._FaultDetails_fault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "engine":
			out.Values[i] = ec._FaultDetails_engine(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "csv":
			out.Values[i] = ec._FaultDetails_csv(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var faultListImplementors = []string{"FaultList"}

func (ec *executionContext) _FaultList(ctx context.Context, sel ast.SelectionSet, obj *model.FaultList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, faultListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FaultList")
		case "name":
			out.Values[i] = ec._FaultList_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":
			out.Values[i] = ec._FaultList_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._FaultList_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "plan":
			out.Values[i] = ec._FaultList_plan(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getChaosHubStatsResponseImplementors = []string{"GetChaosHubStatsResponse"}

func (ec *executionContext) _GetChaosHubStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetChaosHubStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getChaosHubStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetChaosHubStatsResponse")
		case "totalChaosHubs":
			out.Values[i] = ec._GetChaosHubStatsResponse_totalChaosHubs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getExperimentResponseImplementors = []string{"GetExperimentResponse"}

func (ec *executionContext) _GetExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetExperimentResponse")
		case "experimentDetails":
			out.Values[i] = ec._GetExperimentResponse_experimentDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "averageResiliencyScore":
			out.Values[i] = ec._GetExperimentResponse_averageResiliencyScore(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getExperimentRunStatsResponseImplementors = []string{"GetExperimentRunStatsResponse"}

func (ec *executionContext) _GetExperimentRunStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetExperimentRunStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getExperimentRunStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetExperimentRunStatsResponse")
		case "totalExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCompletedExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalCompletedExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalTerminatedExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalTerminatedExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalRunningExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalRunningExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalStoppedExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalStoppedExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalErroredExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalErroredExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getExperimentStatsResponseImplementors = []string{"GetExperimentStatsResponse"}

func (ec *executionContext) _GetExperimentStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetExperimentStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getExperimentStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetExperimentStatsResponse")
		case "totalExperiments":
			out.Values[i] = ec._GetExperimentStatsResponse_totalExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExpCategorizedByResiliencyScore":
			out.Values[i] = ec._GetExperimentStatsResponse_totalExpCategorizedByResiliencyScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getInfraStatsResponseImplementors = []string{"GetInfraStatsResponse"}

func (ec *executionContext) _GetInfraStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetInfraStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getInfraStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetInfraStatsResponse")
		case "totalInfrastructures":
			out.Values[i] = ec._GetInfraStatsResponse_totalInfrastructures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalActiveInfrastructure":
			out.Values[i] = ec._GetInfraStatsResponse_totalActiveInfrastructure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalInactiveInfrastructures":
			out.Values[i] = ec._GetInfraStatsResponse_totalInactiveInfrastructures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalConfirmedInfrastructure":
			out.Values[i] = ec._GetInfraStatsResponse_totalConfirmedInfrastructure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalNonConfirmedInfrastructures":
			out.Values[i] = ec._GetInfraStatsResponse_totalNonConfirmedInfrastructures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitConfigResponseImplementors = []string{"GitConfigResponse"}

func (ec *executionContext) _GitConfigResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GitConfigResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitConfigResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitConfigResponse")
		case "enabled":
			out.Values[i] = ec._GitConfigResponse_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._GitConfigResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "branch":
			out.Values[i] = ec._GitConfigResponse_branch(ctx, field, obj)
		case "repoURL":
			out.Values[i] = ec._GitConfigResponse_repoURL(ctx, field, obj)
		case "authType":
			out.Values[i] = ec._GitConfigResponse_authType(ctx, field, obj)
		case "token":
			out.Values[i] = ec._GitConfigResponse_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._GitConfigResponse_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._GitConfigResponse_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._GitConfigResponse_sshPrivateKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryImplementors = []string{"ImageRegistry"}

func (ec *executionContext) _ImageRegistry(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistry")
		case "isDefault":
			out.Values[i] = ec._ImageRegistry_isDefault(ctx, field, obj)
		case "imageRegistryName":
			out.Values[i] = ec._ImageRegistry_imageRegistryName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRepoName":
			out.Values[i] = ec._ImageRegistry_imageRepoName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryType":
			out.Values[i] = ec._ImageRegistry_imageRegistryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "secretName":
			out.Values[i] = ec._ImageRegistry_secretName(ctx, field, obj)
		case "secretNamespace":
			out.Values[i] = ec._ImageRegistry_secretNamespace(ctx, field, obj)
		case "enableRegistry":
			out.Values[i] = ec._ImageRegistry_enableRegistry(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryResponseImplementors = []string{"ImageRegistryResponse", "Audit"}

func (ec *executionContext) _ImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistryResponse")
		case "isDefault":
			out.Values[i] = ec._ImageRegistryResponse_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryInfo":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryInfo(ctx, field, obj)
		case "imageRegistryID":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ImageRegistryResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ImageRegistryResponse_updatedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ImageRegistryResponse_createdAt(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ImageRegistryResponse_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ImageRegistryResponse_updatedBy(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ImageRegistryResponse_isRemoved(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraImplementors = []string{"Infra", "ResourceDetails", "Audit"}

func (ec *executionContext) _Infra(ctx context.Context, sel ast.SelectionSet, obj *model.Infra) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Infra")
		case "projectID":
			out.Values[i] = ec._Infra_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraID":
			out.Values[i] = ec._Infra_infraID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Infra_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Infra_description(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Infra_tags(ctx, field, obj)
		case "environmentID":
			out.Values[i] = ec._Infra_environmentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "platformName":
			out.Values[i] = ec._Infra_platformName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isActive":
			out.Values[i] = ec._Infra_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isInfraConfirmed":
			out.Values[i] = ec._Infra_isInfraConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._Infra_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Infra_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Infra_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "noOfExperiments":
			out.Values[i] = ec._Infra_noOfExperiments(ctx, field, obj)
		case "noOfExperimentRuns":
			out.Values[i] = ec._Infra_noOfExperimentRuns(ctx, field, obj)
		case "token":
			out.Values[i] = ec._Infra_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraNamespace":
			out.Values[i] = ec._Infra_infraNamespace(ctx, field, obj)
		case "serviceAccount":
			out.Values[i] = ec._Infra_serviceAccount(ctx, field, obj)
		case "infraScope":
			out.Values[i] = ec._Infra_infraScope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraNsExists":
			out.Values[i] = ec._Infra_infraNsExists(ctx, field, obj)
		case "infraSaExists":
			out.Values[i] = ec._Infra_infraSaExists(ctx, field, obj)
		case "lastExperimentTimestamp":
			out.Values[i] = ec._Infra_lastExperimentTimestamp(ctx, field, obj)
		case "startTime":
			out.Values[i] = ec._Infra_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Infra_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdBy":
			out.Values[i] = ec._Infra_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Infra_updatedBy(ctx, field, obj)
		case "infraType":
			out.Values[i] = ec._Infra_infraType(ctx, field, obj)
		case "updateStatus":
			out.Values[i] = ec._Infra_updateStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraActionResponseImplementors = []string{"InfraActionResponse"}

func (ec *executionContext) _InfraActionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.InfraActionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraActionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InfraActionResponse")
		case "projectID":
			out.Values[i] = ec._InfraActionResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "action":
			out.Values[i] = ec._InfraActionResponse_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraEventResponseImplementors = []string{"InfraEventResponse"}

func (ec *executionContext) _InfraEventResponse(ctx context.Context, sel ast.SelectionSet, obj *model.InfraEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InfraEventResponse")
		case "eventID":
			out.Values[i] = ec._InfraEventResponse_eventID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":
			out.Values[i] = ec._InfraEventResponse_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventName":
			out.Values[i] = ec._InfraEventResponse_eventName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._InfraEventResponse_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infra":
			out.Values[i] = ec._InfraEventResponse_infra(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraVersionDetailsImplementors = []string{"InfraVersionDetails"}

func (ec *executionContext) _InfraVersionDetails(ctx context.Context, sel ast.SelectionSet, obj *model.InfraVersionDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraVersionDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InfraVersionDetails")
		case "latestVersion":
			out.Values[i] = ec._InfraVersionDetails_latestVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "compatibleVersions":
			out.Values[i] = ec._InfraVersionDetails_compatibleVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kubeObjectImplementors = []string{"KubeObject"}

func (ec *executionContext) _KubeObject(ctx context.Context, sel ast.SelectionSet, obj *model.KubeObject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kubeObjectImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeObject")
		case "namespace":
			out.Values[i] = ec._KubeObject_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":
			out.Values[i] = ec._KubeObject_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kubeObjectResponseImplementors = []string{"KubeObjectResponse"}

func (ec *executionContext) _KubeObjectResponse(ctx context.Context, sel ast.SelectionSet, obj *model.KubeObjectResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kubeObjectResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeObjectResponse")
		case "infraID":
			out.Values[i] = ec._KubeObjectResponse_infraID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._KubeObjectResponse_kubeObj(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var linkImplementors = []string{"Link"}

func (ec *executionContext) _Link(ctx context.Context, sel ast.SelectionSet, obj *model.Link) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linkImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Link")
		case "name":
			out.Values[i] = ec._Link_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Link_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listEnvironmentResponseImplementors = []string{"ListEnvironmentResponse"}

func (ec *executionContext) _ListEnvironmentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListEnvironmentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listEnvironmentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListEnvironmentResponse")
		case "totalNoOfEnvironments":
			out.Values[i] = ec._ListEnvironmentResponse_totalNoOfEnvironments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "environments":
			out.Values[i] = ec._ListEnvironmentResponse_environments(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listExperimentResponseImplementors = []string{"ListExperimentResponse"}

func (ec *executionContext) _ListExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListExperimentResponse")
		case "totalNoOfExperiments":
			out.Values[i] = ec._ListExperimentResponse_totalNoOfExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._ListExperimentResponse_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listExperimentRunResponseImplementors = []string{"ListExperimentRunResponse"}

func (ec *executionContext) _ListExperimentRunResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListExperimentRunResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listExperimentRunResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListExperimentRunResponse")
		case "totalNoOfExperimentRuns":
			out.Values[i] = ec._ListExperimentRunResponse_totalNoOfExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentRuns":
			out.Values[i] = ec._ListExperimentRunResponse_experimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listInfraResponseImplementors = []string{"ListInfraResponse"}

func (ec *executionContext) _ListInfraResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListInfraResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listInfraResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListInfraResponse")
		case "totalNoOfInfras":
			out.Values[i] = ec._ListInfraResponse_totalNoOfInfras(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infras":
			out.Values[i] = ec._ListInfraResponse_infras(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *model.Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "name":
			out.Values[i] = ec._Maintainer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._Maintainer_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metadataImplementors = []string{"Metadata"}

func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *model.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Metadata_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createChaosExperiment":
			out.Values[i] = ec._Mutation_createChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveChaosExperiment":
			out.Values[i] = ec._Mutation_saveChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runChaosExperiment":
			out.Values[i] = ec._Mutation_runChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosExperiment":
			out.Values[i] = ec._Mutation_updateChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosExperiment":
			out.Values[i] = ec._Mutation_deleteChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosExperimentRun":
			out.Values[i] = ec._Mutation_chaosExperimentRun(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "registerInfra":
			out.Values[i] = ec._Mutation_registerInfra(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "confirmInfraRegistration":
			out.Values[i] = ec._Mutation_confirmInfraRegistration(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteInfra":
			out.Values[i] = ec._Mutation_deleteInfra(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "getManifestWithInfraID":
			out.Values[i] = ec._Mutation_getManifestWithInfraID(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podLog":
			out.Values[i] = ec._Mutation_podLog(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._Mutation_kubeObj(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addChaosHub":
			out.Values[i] = ec._Mutation_addChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addRemoteChaosHub":
			out.Values[i] = ec._Mutation_addRemoteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveChaosHub":
			out.Values[i] = ec._Mutation_saveChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "syncChaosHub":
			out.Values[i] = ec._Mutation_syncChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "generateSSHKey":
			out.Values[i] = ec._Mutation_generateSSHKey(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosHub":
			out.Values[i] = ec._Mutation_updateChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosHub":
			out.Values[i] = ec._Mutation_deleteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createEnvironment":
			out.Values[i] = ec._Mutation_createEnvironment(ctx, field)
		case "updateEnvironment":
			out.Values[i] = ec._Mutation_updateEnvironment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteEnvironment":
			out.Values[i] = ec._Mutation_deleteEnvironment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gitopsNotifier":
			out.Values[i] = ec._Mutation_gitopsNotifier(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "enableGitOps":
			out.Values[i] = ec._Mutation_enableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "disableGitOps":
			out.Values[i] = ec._Mutation_disableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateGitOps":
			out.Values[i] = ec._Mutation_updateGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createImageRegistry":
			out.Values[i] = ec._Mutation_createImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateImageRegistry":
			out.Values[i] = ec._Mutation_updateImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteImageRegistry":
			out.Values[i] = ec._Mutation_deleteImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var objectDataImplementors = []string{"ObjectData"}

func (ec *executionContext) _ObjectData(ctx context.Context, sel ast.SelectionSet, obj *model.ObjectData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, objectDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObjectData")
		case "labels":
			out.Values[i] = ec._ObjectData_labels(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ObjectData_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageInformationImplementors = []string{"PackageInformation"}

func (ec *executionContext) _PackageInformation(ctx context.Context, sel ast.SelectionSet, obj *model.PackageInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageInformation")
		case "packageName":
			out.Values[i] = ec._PackageInformation_packageName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._PackageInformation_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podLogResponseImplementors = []string{"PodLogResponse"}

func (ec *executionContext) _PodLogResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PodLogResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podLogResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodLogResponse")
		case "experimentRunID":
			out.Values[i] = ec._PodLogResponse_experimentRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podName":
			out.Values[i] = ec._PodLogResponse_podName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podType":
			out.Values[i] = ec._PodLogResponse_podType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "log":
			out.Values[i] = ec._PodLogResponse_log(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var predefinedExperimentListImplementors = []string{"PredefinedExperimentList"}

func (ec *executionContext) _PredefinedExperimentList(ctx context.Context, sel ast.SelectionSet, obj *model.PredefinedExperimentList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, predefinedExperimentListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PredefinedExperimentList")
		case "experimentName":
			out.Values[i] = ec._PredefinedExperimentList_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentCSV":
			out.Values[i] = ec._PredefinedExperimentList_experimentCSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentManifest":
			out.Values[i] = ec._PredefinedExperimentList_experimentManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var providerImplementors = []string{"Provider"}

func (ec *executionContext) _Provider(ctx context.Context, sel ast.SelectionSet, obj *model.Provider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Provider")
		case "name":
			out.Values[i] = ec._Provider_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getExperimentRun":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentRun(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listExperimentRun":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listExperimentRun(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperimentRunStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentRunStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperimentStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfra":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfra(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listInfras":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listInfras(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfraDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfraDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfraManifest":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfraManifest(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfraStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfraStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getVersionDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getVersionDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getServerVersion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getServerVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listChaosFaults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listChaosFaults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getChaosFault":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getChaosFault(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listChaosHub":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listChaosHub(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getChaosHub":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getChaosHub(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listPredefinedExperiments":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listPredefinedExperiments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPredefinedExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPredefinedExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getChaosHubStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getChaosHubStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getEnvironment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getEnvironment(ctx, field)
				return res
			})
		case "listEnvironments":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listEnvironments(ctx, field)
				return res
			})
		case "getGitOpsDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGitOpsDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listImageRegistry(ctx, field)
				return res
			})
		case "getImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getImageRegistry(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var recentExperimentRunImplementors = []string{"RecentExperimentRun", "Audit"}

func (ec *executionContext) _RecentExperimentRun(ctx context.Context, sel ast.SelectionSet, obj *model.RecentExperimentRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recentExperimentRunImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RecentExperimentRun")
		case "experimentRunID":
			out.Values[i] = ec._RecentExperimentRun_experimentRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "phase":
			out.Values[i] = ec._RecentExperimentRun_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resiliencyScore":
			out.Values[i] = ec._RecentExperimentRun_resiliencyScore(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._RecentExperimentRun_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RecentExperimentRun_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdBy":
			out.Values[i] = ec._RecentExperimentRun_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._RecentExperimentRun_updatedBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var registerInfraResponseImplementors = []string{"RegisterInfraResponse"}

func (ec *executionContext) _RegisterInfraResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RegisterInfraResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registerInfraResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegisterInfraResponse")
		case "token":
			out.Values[i] = ec._RegisterInfraResponse_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraID":
			out.Values[i] = ec._RegisterInfraResponse_infraID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._RegisterInfraResponse_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manifest":
			out.Values[i] = ec._RegisterInfraResponse_manifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resilienceScoreCategoryImplementors = []string{"ResilienceScoreCategory"}

func (ec *executionContext) _ResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, obj *model.ResilienceScoreCategory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resilienceScoreCategoryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResilienceScoreCategory")
		case "id":
			out.Values[i] = ec._ResilienceScoreCategory_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._ResilienceScoreCategory_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runChaosExperimentResponseImplementors = []string{"RunChaosExperimentResponse"}

func (ec *executionContext) _RunChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RunChaosExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runChaosExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunChaosExperimentResponse")
		case "notifyID":
			out.Values[i] = ec._RunChaosExperimentResponse_notifyID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sSHKeyImplementors = []string{"SSHKey"}

func (ec *executionContext) _SSHKey(ctx context.Context, sel ast.SelectionSet, obj *model.SSHKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sSHKeyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SSHKey")
		case "publicKey":
			out.Values[i] = ec._SSHKey_publicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "privateKey":
			out.Values[i] = ec._SSHKey_privateKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverVersionResponseImplementors = []string{"ServerVersionResponse"}

func (ec *executionContext) _ServerVersionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ServerVersionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverVersionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerVersionResponse")
		case "key":
			out.Values[i] = ec._ServerVersionResponse_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._ServerVersionResponse_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var specImplementors = []string{"Spec"}

func (ec *executionContext) _Spec(ctx context.Context, sel ast.SelectionSet, obj *model.Spec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, specImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Spec")
		case "displayName":
			out.Values[i] = ec._Spec_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "categoryDescription":
			out.Values[i] = ec._Spec_categoryDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keywords":
			out.Values[i] = ec._Spec_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maturity":
			out.Values[i] = ec._Spec_maturity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._Spec_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "minKubeVersion":
			out.Values[i] = ec._Spec_minKubeVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "provider":
			out.Values[i] = ec._Spec_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "links":
			out.Values[i] = ec._Spec_links(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "faults":
			out.Values[i] = ec._Spec_faults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._Spec_experiments(ctx, field, obj)
		case "chaosExpCRDLink":
			out.Values[i] = ec._Spec_chaosExpCRDLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "platforms":
			out.Values[i] = ec._Spec_platforms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosType":
			out.Values[i] = ec._Spec_chaosType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stopExperimentRunsRequestImplementors = []string{"StopExperimentRunsRequest"}

func (ec *executionContext) _StopExperimentRunsRequest(ctx context.Context, sel ast.SelectionSet, obj *model.StopExperimentRunsRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopExperimentRunsRequestImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopExperimentRunsRequest")
		case "projectID":
			out.Values[i] = ec._StopExperimentRunsRequest_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentID":
			out.Values[i] = ec._StopExperimentRunsRequest_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentRunID":
			out.Values[i] = ec._StopExperimentRunsRequest_experimentRunID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "getInfraEvents":
		return ec._Subscription_getInfraEvents(ctx, fields[0])
	case "infraConnect":
		return ec._Subscription_infraConnect(ctx, fields[0])
	case "getPodLog":
		return ec._Subscription_getPodLog(ctx, fields[0])
	case "getKubeObject":
		return ec._Subscription_getKubeObject(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userDetailsImplementors = []string{"UserDetails"}

func (ec *executionContext) _UserDetails(ctx context.Context, sel ast.SelectionSet, obj *model.UserDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserDetails")
		case "userID":
			out.Values[i] = ec._UserDetails_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "username":
			out.Values[i] = ec._UserDetails_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._UserDetails_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var weightagesImplementors = []string{"Weightages"}

func (ec *executionContext) _Weightages(ctx context.Context, sel ast.SelectionSet, obj *model.Weightages) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weightagesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Weightages")
		case "faultName":
			out.Values[i] = ec._Weightages_faultName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightage":
			out.Values[i] = ec._Weightages_weightage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActionPayload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelActionPayload(ctx context.Context, sel ast.SelectionSet, v model.ActionPayload) graphql.Marshaler {
	return ec._ActionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNActionPayload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelActionPayload(ctx context.Context, sel ast.SelectionSet, v *model.ActionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ActionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnotation2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAnnotation(ctx context.Context, sel ast.SelectionSet, v model.Annotation) graphql.Marshaler {
	return ec._Annotation(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnotation2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.Annotation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentRequest(ctx context.Context, v interface{}) (model.ChaosExperimentRequest, error) {
	return ec.unmarshalInputChaosExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNChaosExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.ChaosExperimentResponse) graphql.Marshaler {
	return ec._ChaosExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.ChaosExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHub(ctx context.Context, sel ast.SelectionSet, v model.ChaosHub) graphql.Marshaler {
	return ec._ChaosHub(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHub(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHub) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosHub(ctx, sel, v)
}

func (ec *executionContext) marshalNChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v model.ChaosHubStatus) graphql.Marshaler {
	return ec._ChaosHubStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v []*model.ChaosHubStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHubStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosHubStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNChart2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChart(ctx context.Context, sel ast.SelectionSet, v model.Chart) graphql.Marshaler {
	return ec._Chart(ctx, sel, &v)
}

func (ec *executionContext) marshalNChart2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChart(ctx context.Context, sel ast.SelectionSet, v []*model.Chart) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChart2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChart(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChart2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChart(ctx context.Context, sel ast.SelectionSet, v *model.Chart) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Chart(ctx, sel, v)
}

func (ec *executionContext) marshalNConfirmInfraRegistrationResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelConfirmInfraRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v model.ConfirmInfraRegistrationResponse) graphql.Marshaler {
	return ec._ConfirmInfraRegistrationResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfirmInfraRegistrationResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelConfirmInfraRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v *model.ConfirmInfraRegistrationResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ConfirmInfraRegistrationResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateChaosHubRequest(ctx context.Context, v interface{}) (model.CreateChaosHubRequest, error) {
	return ec.unmarshalInputCreateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNCreateRemoteChaosHub2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateRemoteChaosHub(ctx context.Context, v interface{}) (model.CreateRemoteChaosHub, error) {
	return ec.unmarshalInputCreateRemoteChaosHub(ctx, v)
}

func (ec *executionContext) unmarshalNEnvironmentSortingField2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentSortingField(ctx context.Context, v interface{}) (model.EnvironmentSortingField, error) {
	var res model.EnvironmentSortingField
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEnvironmentSortingField2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentSortingField(ctx context.Context, sel ast.SelectionSet, v model.EnvironmentSortingField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, v interface{}) (model.EnvironmentType, error) {
	var res model.EnvironmentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, sel ast.SelectionSet, v model.EnvironmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx context.Context, sel ast.SelectionSet, v model.Experiment) graphql.Marshaler {
	return ec._Experiment(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx context.Context, sel ast.SelectionSet, v []*model.Experiment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx context.Context, sel ast.SelectionSet, v *model.Experiment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRequest(ctx context.Context, v interface{}) (model.ExperimentRequest, error) {
	return ec.unmarshalInputExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRun) graphql.Marshaler {
	return ec._ExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx context.Context, sel ast.SelectionSet, v []*model.ExperimentRun) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentRun) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ExperimentRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExperimentRunRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunRequest(ctx context.Context, v interface{}) (model.ExperimentRunRequest, error) {
	return ec.unmarshalInputExperimentRunRequest(ctx, v)
}

func (ec *executionContext) unmarshalNExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx context.Context, v interface{}) (model.ExperimentRunStatus, error) {
	var res model.ExperimentRunStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNExperimentSortingField2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortingField(ctx context.Context, v interface{}) (model.ExperimentSortingField, error) {
	var res model.ExperimentSortingField
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNExperimentSortingField2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortingField(ctx context.Context, sel ast.SelectionSet, v model.ExperimentSortingField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNExperiments2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiments(ctx context.Context, sel ast.SelectionSet, v model.Experiments) graphql.Marshaler {
	return ec._Experiments(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiments2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiments(ctx context.Context, sel ast.SelectionSet, v []*model.Experiments) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExperiments2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiments(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperiments2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiments(ctx context.Context, sel ast.SelectionSet, v *model.Experiments) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiments(ctx, sel, v)
}

func (ec *executionContext) marshalNFaultDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultDetails(ctx context.Context, sel ast.SelectionSet, v model.FaultDetails) graphql.Marshaler {
	return ec._FaultDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalNFaultDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultDetails(ctx context.Context, sel ast.SelectionSet, v *model.FaultDetails) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._FaultDetails(ctx, sel, v)
}

func (ec *executionContext) marshalNFaultList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultList(ctx context.Context, sel ast.SelectionSet, v model.FaultList) graphql.Marshaler {
	return ec._FaultList(ctx, sel, &v)
}

func (ec *executionContext) marshalNFaultList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultList(ctx context.Context, sel ast.SelectionSet, v []*model.FaultList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFaultList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNFaultList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelFaultList(ctx context.Context, sel ast.SelectionSet, v *model.FaultList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._FaultList(ctx, sel, v)
}

func (ec *executionContext) marshalNGetChaosHubStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetChaosHubStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetChaosHubStatsResponse) graphql.Marshaler {
	return ec._GetChaosHubStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetChaosHubStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetChaosHubStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetChaosHubStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetChaosHubStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.GetExperimentResponse) graphql.Marshaler {
	return ec._GetExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetExperimentRunStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetExperimentRunStatsResponse) graphql.Marshaler {
	return ec._GetExperimentRunStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetExperimentRunStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetExperimentRunStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetExperimentRunStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetExperimentStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetExperimentStatsResponse) graphql.Marshaler {
	return ec._GetExperimentStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetExperimentStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetExperimentStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetExperimentStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetExperimentStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetInfraStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetInfraStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetInfraStatsResponse) graphql.Marshaler {
	return ec._GetInfraStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetInfraStatsResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGetInfraStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetInfraStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetInfraStatsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGitConfig2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGitConfig(ctx context.Context, v interface{}) (model.GitConfig, error) {
	return ec.unmarshalInputGitConfig(ctx, v)
}

func (ec *executionContext) marshalNGitConfigResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v model.GitConfigResponse) graphql.Marshaler {
	return ec._GitConfigResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitConfigResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v *model.GitConfigResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GitConfigResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHubType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelHubType(ctx context.Context, v interface{}) (model.HubType, error) {
	var res model.HubType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNHubType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelHubType(ctx context.Context, sel ast.SelectionSet, v model.HubType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImageRegistryInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryInput(ctx context.Context, v interface{}) (model.ImageRegistryInput, error) {
	return ec.unmarshalInputImageRegistryInput(ctx, v)
}

func (ec *executionContext) marshalNImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistryResponse) graphql.Marshaler {
	return ec._ImageRegistryResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImageRegistryResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx context.Context, sel ast.SelectionSet, v model.Infra) graphql.Marshaler {
	return ec._Infra(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx context.Context, sel ast.SelectionSet, v []*model.Infra) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx context.Context, sel ast.SelectionSet, v *model.Infra) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Infra(ctx, sel, v)
}

func (ec *executionContext) marshalNInfraActionResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraActionResponse(ctx context.Context, sel ast.SelectionSet, v model.InfraActionResponse) graphql.Marshaler {
	return ec._InfraActionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfraActionResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraActionResponse(ctx context.Context, sel ast.SelectionSet, v *model.InfraActionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InfraActionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNInfraEventResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraEventResponse(ctx context.Context, sel ast.SelectionSet, v model.InfraEventResponse) graphql.Marshaler {
	return ec._InfraEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfraEventResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraEventResponse(ctx context.Context, sel ast.SelectionSet, v *model.InfraEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InfraEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx context.Context, v interface{}) (model.InfraIdentity, error) {
	return ec.unmarshalInputInfraIdentity(ctx, v)
}

func (ec *executionContext) unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx context.Context, v interface{}) (*model.InfraIdentity, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNInfraIdentity2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraIdentity(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNInfraVersionDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraVersionDetails(ctx context.Context, sel ast.SelectionSet, v model.InfraVersionDetails) graphql.Marshaler {
	return ec._InfraVersionDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfraVersionDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraVersionDetails(ctx context.Context, sel ast.SelectionSet, v *model.InfraVersionDetails) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InfraVersionDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, v interface{}) (model.InfrastructureType, error) {
	var res model.InfrastructureType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, sel ast.SelectionSet, v model.InfrastructureType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNKubeObject2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObject(ctx context.Context, sel ast.SelectionSet, v []*model.KubeObject) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOKubeObject2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObject(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNKubeObjectData2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObjectData(ctx context.Context, v interface{}) (model.KubeObjectData, error) {
	return ec.unmarshalInputKubeObjectData(ctx, v)
}

func (ec *executionContext) unmarshalNKubeObjectRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObjectRequest(ctx context.Context, v interface{}) (model.KubeObjectRequest, error) {
	return ec.unmarshalInputKubeObjectRequest(ctx, v)
}

func (ec *executionContext) marshalNKubeObjectResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v model.KubeObjectResponse) graphql.Marshaler {
	return ec._KubeObjectResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNKubeObjectResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v *model.KubeObjectResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._KubeObjectResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNLink2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelLink(ctx context.Context, sel ast.SelectionSet, v model.Link) graphql.Marshaler {
	return ec._Link(ctx, sel, &v)
}

func (ec *executionContext) marshalNLink2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelLink(ctx context.Context, sel ast.SelectionSet, v []*model.Link) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLink2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLink2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelLink(ctx context.Context, sel ast.SelectionSet, v *model.Link) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Link(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentRequest(ctx context.Context, v interface{}) (model.ListExperimentRequest, error) {
	return ec.unmarshalInputListExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNListExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.ListExperimentResponse) graphql.Marshaler {
	return ec._ListExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListExperimentRunRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentRunRequest(ctx context.Context, v interface{}) (model.ListExperimentRunRequest, error) {
	return ec.unmarshalInputListExperimentRunRequest(ctx, v)
}

func (ec *executionContext) marshalNListExperimentRunResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentRunResponse(ctx context.Context, sel ast.SelectionSet, v model.ListExperimentRunResponse) graphql.Marshaler {
	return ec._ListExperimentRunResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListExperimentRunResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListExperimentRunResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListExperimentRunResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListExperimentRunResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNListInfraResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListInfraResponse(ctx context.Context, sel ast.SelectionSet, v model.ListInfraResponse) graphql.Marshaler {
	return ec._ListInfraResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListInfraResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListInfraResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListInfraResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListInfraResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMaintainer(ctx context.Context, sel ast.SelectionSet, v model.Maintainer) graphql.Marshaler {
	return ec._Maintainer(ctx, sel, &v)
}

func (ec *executionContext) marshalNMaintainer2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMaintainer(ctx context.Context, sel ast.SelectionSet, v []*model.Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMaintainer(ctx context.Context, sel ast.SelectionSet, v *model.Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) marshalNMetadata2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMetadata(ctx context.Context, sel ast.SelectionSet, v model.Metadata) graphql.Marshaler {
	return ec._Metadata(ctx, sel, &v)
}

func (ec *executionContext) marshalNMetadata2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelMetadata(ctx context.Context, sel ast.SelectionSet, v *model.Metadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Metadata(ctx, sel, v)
}

func (ec *executionContext) marshalNObjectData2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelObjectData(ctx context.Context, sel ast.SelectionSet, v []*model.ObjectData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOObjectData2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelObjectData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPackageInformation2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPackageInformation(ctx context.Context, sel ast.SelectionSet, v model.PackageInformation) graphql.Marshaler {
	return ec._PackageInformation(ctx, sel, &v)
}

func (ec *executionContext) marshalNPackageInformation2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPackageInformation(ctx context.Context, sel ast.SelectionSet, v *model.PackageInformation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PackageInformation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPodLog2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPodLog(ctx context.Context, v interface{}) (model.PodLog, error) {
	return ec.unmarshalInputPodLog(ctx, v)
}

func (ec *executionContext) unmarshalNPodLogRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPodLogRequest(ctx context.Context, v interface{}) (model.PodLogRequest, error) {
	return ec.unmarshalInputPodLogRequest(ctx, v)
}

func (ec *executionContext) marshalNPodLogResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPodLogResponse(ctx context.Context, sel ast.SelectionSet, v model.PodLogResponse) graphql.Marshaler {
	return ec._PodLogResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodLogResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPodLogResponse(ctx context.Context, sel ast.SelectionSet, v *model.PodLogResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PodLogResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPredefinedExperimentList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPredefinedExperimentList(ctx context.Context, sel ast.SelectionSet, v model.PredefinedExperimentList) graphql.Marshaler {
	return ec._PredefinedExperimentList(ctx, sel, &v)
}

func (ec *executionContext) marshalNPredefinedExperimentList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPredefinedExperimentList(ctx context.Context, sel ast.SelectionSet, v []*model.PredefinedExperimentList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPredefinedExperimentList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPredefinedExperimentList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPredefinedExperimentList2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPredefinedExperimentList(ctx context.Context, sel ast.SelectionSet, v *model.PredefinedExperimentList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PredefinedExperimentList(ctx, sel, v)
}

func (ec *executionContext) marshalNProvider2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelProvider(ctx context.Context, sel ast.SelectionSet, v model.Provider) graphql.Marshaler {
	return ec._Provider(ctx, sel, &v)
}

func (ec *executionContext) marshalNProvider2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelProvider(ctx context.Context, sel ast.SelectionSet, v *model.Provider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Provider(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRegisterInfraRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRegisterInfraRequest(ctx context.Context, v interface{}) (model.RegisterInfraRequest, error) {
	return ec.unmarshalInputRegisterInfraRequest(ctx, v)
}

func (ec *executionContext) marshalNRegisterInfraResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRegisterInfraResponse(ctx context.Context, sel ast.SelectionSet, v model.RegisterInfraResponse) graphql.Marshaler {
	return ec._RegisterInfraResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegisterInfraResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRegisterInfraResponse(ctx context.Context, sel ast.SelectionSet, v *model.RegisterInfraResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RegisterInfraResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNResilienceScoreCategory2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, v []*model.ResilienceScoreCategory) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOResilienceScoreCategory2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelResilienceScoreCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRunChaosExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRunChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.RunChaosExperimentResponse) graphql.Marshaler {
	return ec._RunChaosExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRunChaosExperimentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRunChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.RunChaosExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RunChaosExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSSHKey2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSSHKey(ctx context.Context, sel ast.SelectionSet, v model.SSHKey) graphql.Marshaler {
	return ec._SSHKey(ctx, sel, &v)
}

func (ec *executionContext) marshalNSSHKey2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSSHKey(ctx context.Context, sel ast.SelectionSet, v *model.SSHKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SSHKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSaveChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSaveChaosExperimentRequest(ctx context.Context, v interface{}) (model.SaveChaosExperimentRequest, error) {
	return ec.unmarshalInputSaveChaosExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNServerVersionResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v model.ServerVersionResponse) graphql.Marshaler {
	return ec._ServerVersionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNServerVersionResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v *model.ServerVersionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ServerVersionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSpec2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSpec(ctx context.Context, sel ast.SelectionSet, v model.Spec) graphql.Marshaler {
	return ec._Spec(ctx, sel, &v)
}

func (ec *executionContext) marshalNSpec2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelSpec(ctx context.Context, sel ast.SelectionSet, v *model.Spec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Spec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNUpdateChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateChaosHubRequest(ctx context.Context, v interface{}) (model.UpdateChaosHubRequest, error) {
	return ec.unmarshalInputUpdateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateStatus(ctx context.Context, v interface{}) (model.UpdateStatus, error) {
	var res model.UpdateStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNUpdateStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateStatus(ctx context.Context, sel ast.SelectionSet, v model.UpdateStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWeightages2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightages(ctx context.Context, sel ast.SelectionSet, v model.Weightages) graphql.Marshaler {
	return ec._Weightages(ctx, sel, &v)
}

func (ec *executionContext) marshalNWeightages2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightages(ctx context.Context, sel ast.SelectionSet, v []*model.Weightages) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeightages2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWeightages2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightages(ctx context.Context, sel ast.SelectionSet, v *model.Weightages) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Weightages(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightagesInput(ctx context.Context, v interface{}) (model.WeightagesInput, error) {
	return ec.unmarshalInputWeightagesInput(ctx, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightagesInput(ctx context.Context, v interface{}) ([]*model.WeightagesInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.WeightagesInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNWeightagesInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightagesInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNWeightagesInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightagesInput(ctx context.Context, v interface{}) (*model.WeightagesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNWeightagesInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWeightagesInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx context.Context, v interface{}) (*model.AuthType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAuthType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelAuthType(ctx context.Context, sel ast.SelectionSet, v *model.AuthType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentRequest(ctx context.Context, v interface{}) (model.ChaosExperimentRequest, error) {
	return ec.unmarshalInputChaosExperimentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentRequest(ctx context.Context, v interface{}) (*model.ChaosExperimentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChaosExperimentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosExperimentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOChaosHubFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubFilterInput(ctx context.Context, v interface{}) (model.ChaosHubFilterInput, error) {
	return ec.unmarshalInputChaosHubFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOChaosHubFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubFilterInput(ctx context.Context, v interface{}) (*model.ChaosHubFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChaosHubFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v model.ChaosHubStatus) graphql.Marshaler {
	return ec._ChaosHubStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalOChaosHubStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHubStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChaosHubStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCreateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateEnvironmentRequest(ctx context.Context, v interface{}) (model.CreateEnvironmentRequest, error) {
	return ec.unmarshalInputCreateEnvironmentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOCreateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateEnvironmentRequest(ctx context.Context, v interface{}) (*model.CreateEnvironmentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCreateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelCreateEnvironmentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODateRange2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelDateRange(ctx context.Context, v interface{}) (model.DateRange, error) {
	return ec.unmarshalInputDateRange(ctx, v)
}

func (ec *executionContext) unmarshalODateRange2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelDateRange(ctx context.Context, v interface{}) (*model.DateRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODateRange2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelDateRange(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEnvironment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironment(ctx context.Context, sel ast.SelectionSet, v model.Environment) graphql.Marshaler {
	return ec._Environment(ctx, sel, &v)
}

func (ec *executionContext) marshalOEnvironment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironment(ctx context.Context, sel ast.SelectionSet, v []*model.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOEnvironment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironment(ctx context.Context, sel ast.SelectionSet, v *model.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Environment(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEnvironmentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentFilterInput(ctx context.Context, v interface{}) (model.EnvironmentFilterInput, error) {
	return ec.unmarshalInputEnvironmentFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOEnvironmentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentFilterInput(ctx context.Context, v interface{}) (*model.EnvironmentFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEnvironmentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOEnvironmentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentSortInput(ctx context.Context, v interface{}) (model.EnvironmentSortInput, error) {
	return ec.unmarshalInputEnvironmentSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOEnvironmentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentSortInput(ctx context.Context, v interface{}) (*model.EnvironmentSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEnvironmentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, v interface{}) (model.EnvironmentType, error) {
	var res model.EnvironmentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, sel ast.SelectionSet, v model.EnvironmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, v interface{}) ([]*model.EnvironmentType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.EnvironmentType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, sel ast.SelectionSet, v []*model.EnvironmentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, v interface{}) (*model.EnvironmentType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEnvironmentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelEnvironmentType(ctx context.Context, sel ast.SelectionSet, v *model.EnvironmentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx context.Context, sel ast.SelectionSet, v model.Experiment) graphql.Marshaler {
	return ec._Experiment(ctx, sel, &v)
}

func (ec *executionContext) marshalOExperiment2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperiment(ctx context.Context, sel ast.SelectionSet, v *model.Experiment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Experiment(ctx, sel, v)
}

func (ec *executionContext) unmarshalOExperimentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentFilterInput(ctx context.Context, v interface{}) (model.ExperimentFilterInput, error) {
	return ec.unmarshalInputExperimentFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentFilterInput(ctx context.Context, v interface{}) (*model.ExperimentFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRun) graphql.Marshaler {
	return ec._ExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalOExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRun(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ExperimentRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalOExperimentRunFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunFilterInput(ctx context.Context, v interface{}) (model.ExperimentRunFilterInput, error) {
	return ec.unmarshalInputExperimentRunFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentRunFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunFilterInput(ctx context.Context, v interface{}) (*model.ExperimentRunFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentRunFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOExperimentRunSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunSortInput(ctx context.Context, v interface{}) (model.ExperimentRunSortInput, error) {
	return ec.unmarshalInputExperimentRunSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentRunSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunSortInput(ctx context.Context, v interface{}) (*model.ExperimentRunSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentRunSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx context.Context, v interface{}) (model.ExperimentRunStatus, error) {
	var res model.ExperimentRunStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx context.Context, v interface{}) (*model.ExperimentRunStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOExperimentRunStatus2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentRunStatus(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentRunStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOExperimentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortInput(ctx context.Context, v interface{}) (model.ExperimentSortInput, error) {
	return ec.unmarshalInputExperimentSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortInput(ctx context.Context, v interface{}) (*model.ExperimentSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentSortInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOExperimentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentType(ctx context.Context, v interface{}) (model.ExperimentType, error) {
	var res model.ExperimentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOExperimentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentType(ctx context.Context, sel ast.SelectionSet, v model.ExperimentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOExperimentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentType(ctx context.Context, v interface{}) (*model.ExperimentType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOExperimentType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelExperimentType(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOINFRA_SCOPE2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraScope(ctx context.Context, v interface{}) (model.InfraScope, error) {
	var res model.InfraScope
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOINFRA_SCOPE2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraScope(ctx context.Context, sel ast.SelectionSet, v model.InfraScope) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOINFRA_SCOPE2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraScope(ctx context.Context, v interface{}) (*model.InfraScope, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOINFRA_SCOPE2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraScope(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOINFRA_SCOPE2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraScope(ctx context.Context, sel ast.SelectionSet, v *model.InfraScope) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOImageRegistry2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistry(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistry) graphql.Marshaler {
	return ec._ImageRegistry(ctx, sel, &v)
}

func (ec *executionContext) marshalOImageRegistry2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistry(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalOImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelImageRegistryResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx context.Context, sel ast.SelectionSet, v model.Infra) graphql.Marshaler {
	return ec._Infra(ctx, sel, &v)
}

func (ec *executionContext) marshalOInfra2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfra(ctx context.Context, sel ast.SelectionSet, v *model.Infra) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Infra(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInfraFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraFilterInput(ctx context.Context, v interface{}) (model.InfraFilterInput, error) {
	return ec.unmarshalInputInfraFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOInfraFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraFilterInput(ctx context.Context, v interface{}) (*model.InfraFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInfraFilterInput2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfraFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, v interface{}) (model.InfrastructureType, error) {
	var res model.InfrastructureType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, sel ast.SelectionSet, v model.InfrastructureType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, v interface{}) ([]*model.InfrastructureType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.InfrastructureType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, sel ast.SelectionSet, v []*model.InfrastructureType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, v interface{}) (*model.InfrastructureType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInfrastructureType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelInfrastructureType(ctx context.Context, sel ast.SelectionSet, v *model.InfrastructureType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOKubeGVRRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeGVRRequest(ctx context.Context, v interface{}) (model.KubeGVRRequest, error) {
	return ec.unmarshalInputKubeGVRRequest(ctx, v)
}

func (ec *executionContext) unmarshalOKubeGVRRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeGVRRequest(ctx context.Context, v interface{}) (*model.KubeGVRRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOKubeGVRRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeGVRRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOKubeObject2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObject(ctx context.Context, sel ast.SelectionSet, v model.KubeObject) graphql.Marshaler {
	return ec._KubeObject(ctx, sel, &v)
}

func (ec *executionContext) marshalOKubeObject2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelKubeObject(ctx context.Context, sel ast.SelectionSet, v *model.KubeObject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KubeObject(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListChaosHubRequest(ctx context.Context, v interface{}) (model.ListChaosHubRequest, error) {
	return ec.unmarshalInputListChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalOListChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListChaosHubRequest(ctx context.Context, v interface{}) (*model.ListChaosHubRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOListChaosHubRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListChaosHubRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOListEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListEnvironmentRequest(ctx context.Context, v interface{}) (model.ListEnvironmentRequest, error) {
	return ec.unmarshalInputListEnvironmentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOListEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListEnvironmentRequest(ctx context.Context, v interface{}) (*model.ListEnvironmentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOListEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListEnvironmentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOListEnvironmentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListEnvironmentResponse(ctx context.Context, sel ast.SelectionSet, v model.ListEnvironmentResponse) graphql.Marshaler {
	return ec._ListEnvironmentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOListEnvironmentResponse2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListEnvironmentResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListEnvironmentResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListEnvironmentResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListInfraRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListInfraRequest(ctx context.Context, v interface{}) (model.ListInfraRequest, error) {
	return ec.unmarshalInputListInfraRequest(ctx, v)
}

func (ec *executionContext) unmarshalOListInfraRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListInfraRequest(ctx context.Context, v interface{}) (*model.ListInfraRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOListInfraRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelListInfraRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOObjectData2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelObjectData(ctx context.Context, sel ast.SelectionSet, v model.ObjectData) graphql.Marshaler {
	return ec._ObjectData(ctx, sel, &v)
}

func (ec *executionContext) marshalOObjectData2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelObjectData(ctx context.Context, sel ast.SelectionSet, v *model.ObjectData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObjectData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPagination2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPagination(ctx context.Context, v interface{}) (model.Pagination, error) {
	return ec.unmarshalInputPagination(ctx, v)
}

func (ec *executionContext) unmarshalOPagination2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPagination(ctx context.Context, v interface{}) (*model.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPagination2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelPagination(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalORecentExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRecentExperimentRun(ctx context.Context, sel ast.SelectionSet, v model.RecentExperimentRun) graphql.Marshaler {
	return ec._RecentExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalORecentExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRecentExperimentRun(ctx context.Context, sel ast.SelectionSet, v []*model.RecentExperimentRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORecentExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRecentExperimentRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalORecentExperimentRun2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelRecentExperimentRun(ctx context.Context, sel ast.SelectionSet, v *model.RecentExperimentRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RecentExperimentRun(ctx, sel, v)
}

func (ec *executionContext) marshalOResilienceScoreCategory2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, v model.ResilienceScoreCategory) graphql.Marshaler {
	return ec._ResilienceScoreCategory(ctx, sel, &v)
}

func (ec *executionContext) marshalOResilienceScoreCategory2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, v *model.ResilienceScoreCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResilienceScoreCategory(ctx, sel, v)
}

func (ec *executionContext) unmarshalOScheduleType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelScheduleType(ctx context.Context, v interface{}) (model.ScheduleType, error) {
	var res model.ScheduleType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOScheduleType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelScheduleType(ctx context.Context, sel ast.SelectionSet, v model.ScheduleType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOScheduleType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelScheduleType(ctx context.Context, v interface{}) (*model.ScheduleType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOScheduleType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelScheduleType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOScheduleType2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelScheduleType(ctx context.Context, sel ast.SelectionSet, v *model.ScheduleType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOToleration2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelToleration(ctx context.Context, v interface{}) (model.Toleration, error) {
	return ec.unmarshalInputToleration(ctx, v)
}

func (ec *executionContext) unmarshalOToleration2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelToleration(ctx context.Context, v interface{}) ([]*model.Toleration, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Toleration, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOToleration2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelToleration(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOToleration2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelToleration(ctx context.Context, v interface{}) (*model.Toleration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOToleration2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelToleration(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUpdateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateEnvironmentRequest(ctx context.Context, v interface{}) (model.UpdateEnvironmentRequest, error) {
	return ec.unmarshalInputUpdateEnvironmentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOUpdateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateEnvironmentRequest(ctx context.Context, v interface{}) (*model.UpdateEnvironmentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUpdateEnvironmentRequest2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUpdateEnvironmentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx context.Context, sel ast.SelectionSet, v model.UserDetails) graphql.Marshaler {
	return ec._UserDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalOUserDetails2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelUserDetails(ctx context.Context, sel ast.SelectionSet, v *model.UserDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWorkload(ctx context.Context, v interface{}) (model.Workload, error) {
	return ec.unmarshalInputWorkload(ctx, v)
}

func (ec *executionContext) unmarshalOWorkload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWorkload(ctx context.Context, v interface{}) ([]*model.Workload, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Workload, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOWorkload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWorkload(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWorkload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWorkload(ctx context.Context, v interface{}) (*model.Workload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkload2githubcomlitmuschaoslitmuschaoscentergraphqlservergraphmodelWorkload(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
