// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Authorized func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	ActionPayload struct {
		ExternalData func(childComplexity int) int
		K8sManifest  func(childComplexity int) int
		Namespace    func(childComplexity int) int
		RequestType  func(childComplexity int) int
		Username     func(childComplexity int) int
	}

	AgentStat struct {
		Active  func(childComplexity int) int
		Cluster func(childComplexity int) int
		Ns      func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Annotation struct {
		Categories       func(childComplexity int) int
		ChartDescription func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Repository       func(childComplexity int) int
		Support          func(childComplexity int) int
		Vendor           func(childComplexity int) int
	}

	AnnotationsPromResponse struct {
		Legends      func(childComplexity int) int
		QueryID      func(childComplexity int) int
		SubDataArray func(childComplexity int) int
		Tsvs         func(childComplexity int) int
	}

	AnnotationsTimeStampValue struct {
		Date  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ApplicationMetadataResponse struct {
		Applications func(childComplexity int) int
		Namespace    func(childComplexity int) int
	}

	ChaosHub struct {
		AuthType      func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		HubName       func(childComplexity int) int
		HubType       func(childComplexity int) int
		ID            func(childComplexity int) int
		IsPrivate     func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		LastSyncedAt  func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoBranch    func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Token         func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ChaosHubStatus struct {
		AuthType      func(childComplexity int) int
		HubName       func(childComplexity int) int
		HubType       func(childComplexity int) int
		ID            func(childComplexity int) int
		IsAvailable   func(childComplexity int) int
		IsPrivate     func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		LastSyncedAt  func(childComplexity int) int
		Password      func(childComplexity int) int
		RepoBranch    func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		SSHPublicKey  func(childComplexity int) int
		Token         func(childComplexity int) int
		TotalExp      func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ChaosWorkFlowResponse struct {
		CronSyntax          func(childComplexity int) int
		IsCustomWorkflow    func(childComplexity int) int
		WorkflowDescription func(childComplexity int) int
		WorkflowID          func(childComplexity int) int
		WorkflowName        func(childComplexity int) int
	}

	Chart struct {
		APIVersion  func(childComplexity int) int
		Kind        func(childComplexity int) int
		Metadata    func(childComplexity int) int
		PackageInfo func(childComplexity int) int
		Spec        func(childComplexity int) int
	}

	Cluster struct {
		AccessKey             func(childComplexity int) int
		AgentNamespace        func(childComplexity int) int
		AgentNsExists         func(childComplexity int) int
		AgentSaExists         func(childComplexity int) int
		AgentScope            func(childComplexity int) int
		ClusterID             func(childComplexity int) int
		ClusterName           func(childComplexity int) int
		ClusterType           func(childComplexity int) int
		CreatedAt             func(childComplexity int) int
		Description           func(childComplexity int) int
		IsActive              func(childComplexity int) int
		IsClusterConfirmed    func(childComplexity int) int
		IsRegistered          func(childComplexity int) int
		LastWorkflowTimestamp func(childComplexity int) int
		NoOfSchedules         func(childComplexity int) int
		NoOfWorkflows         func(childComplexity int) int
		PlatformName          func(childComplexity int) int
		ProjectID             func(childComplexity int) int
		ServiceAccount        func(childComplexity int) int
		StartTime             func(childComplexity int) int
		Token                 func(childComplexity int) int
		UpdatedAt             func(childComplexity int) int
		Version               func(childComplexity int) int
	}

	ClusterActionResponse struct {
		Action    func(childComplexity int) int
		ProjectID func(childComplexity int) int
	}

	ClusterEventResponse struct {
		Cluster     func(childComplexity int) int
		Description func(childComplexity int) int
		EventID     func(childComplexity int) int
		EventName   func(childComplexity int) int
		EventType   func(childComplexity int) int
	}

	ConfirmClusterRegistrationResponse struct {
		ClusterID          func(childComplexity int) int
		IsClusterConfirmed func(childComplexity int) int
		NewAccessKey       func(childComplexity int) int
	}

	DSResponse struct {
		AccessType        func(childComplexity int) int
		AuthType          func(childComplexity int) int
		BasicAuthPassword func(childComplexity int) int
		BasicAuthUsername func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DsID              func(childComplexity int) int
		DsName            func(childComplexity int) int
		DsType            func(childComplexity int) int
		DsURL             func(childComplexity int) int
		HTTPMethod        func(childComplexity int) int
		HealthStatus      func(childComplexity int) int
		ProjectID         func(childComplexity int) int
		QueryTimeout      func(childComplexity int) int
		ScrapeInterval    func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	DashboardPromResponse struct {
		AnnotationsResponse      func(childComplexity int) int
		DashboardMetricsResponse func(childComplexity int) int
	}

	ExperimentDetails struct {
		EngineDetails     func(childComplexity int) int
		ExperimentDetails func(childComplexity int) int
	}

	Experiments struct {
		Csv  func(childComplexity int) int
		Desc func(childComplexity int) int
		Name func(childComplexity int) int
	}

	GitConfigResponse struct {
		AuthType      func(childComplexity int) int
		Branch        func(childComplexity int) int
		Enabled       func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Token         func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	HeatmapDataResponse struct {
		Bins func(childComplexity int) int
	}

	ImageRegistry struct {
		EnableRegistry    func(childComplexity int) int
		ImageRegistryName func(childComplexity int) int
		ImageRegistryType func(childComplexity int) int
		ImageRepoName     func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		SecretName        func(childComplexity int) int
		SecretNamespace   func(childComplexity int) int
	}

	ImageRegistryResponse struct {
		CreatedAt         func(childComplexity int) int
		ImageRegistryID   func(childComplexity int) int
		ImageRegistryInfo func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		IsRemoved         func(childComplexity int) int
		ProjectID         func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	KubeObjectResponse struct {
		ClusterID func(childComplexity int) int
		KubeObj   func(childComplexity int) int
	}

	LabelValue struct {
		Label  func(childComplexity int) int
		Values func(childComplexity int) int
	}

	Link struct {
		Name func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	ListDashboardResponse struct {
		ApplicationMetadataMap    func(childComplexity int) int
		ChaosEventQueryTemplate   func(childComplexity int) int
		ChaosVerdictQueryTemplate func(childComplexity int) int
		ClusterID                 func(childComplexity int) int
		ClusterName               func(childComplexity int) int
		CreatedAt                 func(childComplexity int) int
		DbID                      func(childComplexity int) int
		DbInformation             func(childComplexity int) int
		DbName                    func(childComplexity int) int
		DbTypeID                  func(childComplexity int) int
		DbTypeName                func(childComplexity int) int
		DsHealthStatus            func(childComplexity int) int
		DsID                      func(childComplexity int) int
		DsName                    func(childComplexity int) int
		DsType                    func(childComplexity int) int
		DsURL                     func(childComplexity int) int
		EndTime                   func(childComplexity int) int
		PanelGroups               func(childComplexity int) int
		ProjectID                 func(childComplexity int) int
		RefreshRate               func(childComplexity int) int
		StartTime                 func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
		ViewedAt                  func(childComplexity int) int
	}

	ListWorkflowRunsResponse struct {
		TotalNoOfWorkflowRuns func(childComplexity int) int
		WorkflowRuns          func(childComplexity int) int
	}

	ListWorkflowsResponse struct {
		TotalNoOfWorkflows func(childComplexity int) int
		Workflows          func(childComplexity int) int
	}

	Maintainer struct {
		Email func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	Metadata struct {
		Annotations func(childComplexity int) int
		Name        func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	MetricDataForPanel struct {
		PanelID              func(childComplexity int) int
		PanelMetricsResponse func(childComplexity int) int
	}

	MetricDataForPanelGroup struct {
		PanelGroupID              func(childComplexity int) int
		PanelGroupMetricsResponse func(childComplexity int) int
	}

	MetricsPromResponse struct {
		Legends func(childComplexity int) int
		QueryID func(childComplexity int) int
		Tsvs    func(childComplexity int) int
	}

	MetricsTimeStampValue struct {
		Date  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Mutation struct {
		AddChaosHub                func(childComplexity int, request model.CreateChaosHubRequest) int
		AddRemoteChaosHub          func(childComplexity int, request model.CreateRemoteMyHub) int
		ChaosWorkflowRun           func(childComplexity int, request model.WorkflowRunRequest) int
		ConfirmClusterRegistration func(childComplexity int, request model.ClusterIdentity) int
		CreateChaosWorkFlow        func(childComplexity int, request model.ChaosWorkFlowRequest) int
		CreateDashBoard            func(childComplexity int, dashboard *model.CreateDBInput) int
		CreateDataSource           func(childComplexity int, datasource *model.DSInput) int
		CreateImageRegistry        func(childComplexity int, projectID string, imageRegistryInfo model.ImageRegistryInput) int
		CreateWorkflowTemplate     func(childComplexity int, request *model.TemplateInput) int
		DeleteChaosHub             func(childComplexity int, projectID string, hubID string) int
		DeleteChaosWorkflow        func(childComplexity int, projectID string, workflowID *string, workflowRunID *string) int
		DeleteClusters             func(childComplexity int, projectID string, clusterIDs []*string) int
		DeleteDashboard            func(childComplexity int, projectID string, dbID *string) int
		DeleteDataSource           func(childComplexity int, projectID string, input model.DeleteDSInput) int
		DeleteImageRegistry        func(childComplexity int, imageRegistryID string, projectID string) int
		DeleteWorkflowTemplate     func(childComplexity int, projectID string, templateID string) int
		DisableGitOps              func(childComplexity int, projectID string) int
		EnableGitOps               func(childComplexity int, config model.GitConfig) int
		GenerateSSHKey             func(childComplexity int) int
		GitopsNotifier             func(childComplexity int, clusterInfo model.ClusterIdentity, workflowID string) int
		KubeObj                    func(childComplexity int, request model.KubeObjectData) int
		NewClusterEvent            func(childComplexity int, request model.NewClusterEventRequest) int
		PodLog                     func(childComplexity int, request model.PodLog) int
		ReRunChaosWorkFlow         func(childComplexity int, projectID string, workflowID string) int
		RegisterCluster            func(childComplexity int, request model.RegisterClusterRequest) int
		SaveChaosHub               func(childComplexity int, request model.CreateChaosHubRequest) int
		SyncChaosHub               func(childComplexity int, id string, projectID string) int
		SyncWorkflowRun            func(childComplexity int, projectID string, workflowID string, workflowRunID string) int
		TerminateChaosWorkflow     func(childComplexity int, projectID string, workflowID *string, workflowRunID *string) int
		UpdateChaosHub             func(childComplexity int, request model.UpdateChaosHubRequest) int
		UpdateChaosWorkflow        func(childComplexity int, request *model.ChaosWorkFlowRequest) int
		UpdateDashboard            func(childComplexity int, projectID string, dashboard model.UpdateDBInput, chaosQueryUpdate bool) int
		UpdateDataSource           func(childComplexity int, datasource model.DSInput) int
		UpdateGitOps               func(childComplexity int, config model.GitConfig) int
		UpdateImageRegistry        func(childComplexity int, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) int
		UpdatePanel                func(childComplexity int, panelInput []*model.Panel) int
	}

	Option struct {
		Name func(childComplexity int) int
	}

	PackageInformation struct {
		Experiments func(childComplexity int) int
		PackageName func(childComplexity int) int
	}

	PanelGroupResponse struct {
		PanelGroupID   func(childComplexity int) int
		PanelGroupName func(childComplexity int) int
		Panels         func(childComplexity int) int
	}

	PanelOptionResponse struct {
		GrIDs    func(childComplexity int) int
		LeftAxis func(childComplexity int) int
		Points   func(childComplexity int) int
	}

	PanelResponse struct {
		CreatedAt    func(childComplexity int) int
		PanelID      func(childComplexity int) int
		PanelName    func(childComplexity int) int
		PanelOptions func(childComplexity int) int
		PromQueries  func(childComplexity int) int
		Unit         func(childComplexity int) int
		XAxisDown    func(childComplexity int) int
		YAxisLeft    func(childComplexity int) int
		YAxisRight   func(childComplexity int) int
	}

	PodLogResponse struct {
		Log           func(childComplexity int) int
		PodName       func(childComplexity int) int
		PodType       func(childComplexity int) int
		WorkflowRunID func(childComplexity int) int
	}

	PortalDashboardDataResponse struct {
		DashboardData func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	PredefinedWorkflowList struct {
		WorkflowCsv      func(childComplexity int) int
		WorkflowManifest func(childComplexity int) int
		WorkflowName     func(childComplexity int) int
	}

	ProjectData struct {
		Agents    func(childComplexity int) int
		ProjectID func(childComplexity int) int
		Workflows func(childComplexity int) int
	}

	PromQueryResponse struct {
		CloseArea     func(childComplexity int) int
		Legend        func(childComplexity int) int
		Line          func(childComplexity int) int
		Minstep       func(childComplexity int) int
		PromQueryName func(childComplexity int) int
		QueryID       func(childComplexity int) int
		Resolution    func(childComplexity int) int
	}

	PromSeriesListResponse struct {
		SeriesList func(childComplexity int) int
	}

	PromSeriesResponse struct {
		LabelValues func(childComplexity int) int
		Series      func(childComplexity int) int
	}

	PrometheusDataResponse struct {
		AnnotationsResponse func(childComplexity int) int
		MetricsResponse     func(childComplexity int) int
	}

	Provider struct {
		Name func(childComplexity int) int
	}

	Query struct {
		GetAgentDetails             func(childComplexity int, clusterID string, projectID string) int
		GetExperimentDetails        func(childComplexity int, request model.ExperimentRequest) int
		GetGitOpsDetails            func(childComplexity int, projectID string) int
		GetHubExperiment            func(childComplexity int, request model.ExperimentRequest) int
		GetImageRegistry            func(childComplexity int, imageRegistryID string, projectID string) int
		GetManifest                 func(childComplexity int, projectID string, clusterID string, accessKey string) int
		GetPredefinedExperimentYaml func(childComplexity int, request model.ExperimentRequest) int
		GetPromLabelNamesAndValues  func(childComplexity int, request *model.PromSeriesInput) int
		GetPromSeriesList           func(childComplexity int, request *model.DsDetails) int
		GetPrometheusData           func(childComplexity int, request *model.PrometheusDataRequest) int
		GetServerVersion            func(childComplexity int) int
		GetUsageData                func(childComplexity int, request model.UsageDataRequest) int
		GetWorkflowManifestByID     func(childComplexity int, projectID string, templateID string) int
		GetWorkflowRunStats         func(childComplexity int, workflowRunStatsRequest model.WorkflowRunStatsRequest) int
		GetYAMLData                 func(childComplexity int, request model.ExperimentRequest) int
		ListCharts                  func(childComplexity int, hubName string, projectID string) int
		ListClusters                func(childComplexity int, projectID string, clusterType *string) int
		ListDashboard               func(childComplexity int, projectID string, clusterID *string, dbID *string) int
		ListDataSource              func(childComplexity int, projectID string) int
		ListHeatmapData             func(childComplexity int, projectID string, workflowID string, year int) int
		ListHubStatus               func(childComplexity int, projectID string) int
		ListImageRegistry           func(childComplexity int, projectID string) int
		ListPortalDashboardData     func(childComplexity int, projectID string, hubName string) int
		ListPredefinedWorkflows     func(childComplexity int, hubName string, projectID string) int
		ListWorkflowManifests       func(childComplexity int, projectID string) int
		ListWorkflowRuns            func(childComplexity int, request model.ListWorkflowRunsRequest) int
		ListWorkflowStats           func(childComplexity int, projectID string, filter model.TimeFrequency, showWorkflowRuns bool) int
		ListWorkflows               func(childComplexity int, request model.ListWorkflowsRequest) int
	}

	RegisterClusterResponse struct {
		ClusterID   func(childComplexity int) int
		ClusterName func(childComplexity int) int
		Token       func(childComplexity int) int
	}

	ResourceResponse struct {
		Kind  func(childComplexity int) int
		Names func(childComplexity int) int
	}

	SSHKey struct {
		PrivateKey func(childComplexity int) int
		PublicKey  func(childComplexity int) int
	}

	ServerVersionResponse struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Spec struct {
		CategoryDescription func(childComplexity int) int
		ChaosExpCRDLink     func(childComplexity int) int
		ChaosType           func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		Experiments         func(childComplexity int) int
		Keywords            func(childComplexity int) int
		Links               func(childComplexity int) int
		Maintainers         func(childComplexity int) int
		Maturity            func(childComplexity int) int
		MinKubeVersion      func(childComplexity int) int
		Platforms           func(childComplexity int) int
		Provider            func(childComplexity int) int
	}

	SubData struct {
		Date        func(childComplexity int) int
		SubDataName func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	Subscription struct {
		ClusterConnect    func(childComplexity int, clusterInfo model.ClusterIdentity) int
		GetClusterEvents  func(childComplexity int, projectID string) int
		GetKubeObject     func(childComplexity int, request model.KubeObjectRequest) int
		GetPodLog         func(childComplexity int, request model.PodLogRequest) int
		GetWorkflowEvents func(childComplexity int, projectID string) int
		ViewDashboard     func(childComplexity int, dashboardID *string, promQueries []*model.PromQueryInput, dashboardQueryMap []*model.QueryMapForPanelGroup, dataVariables model.DataVars) int
	}

	TotalCount struct {
		Agents    func(childComplexity int) int
		Projects  func(childComplexity int) int
		Users     func(childComplexity int) int
		Workflows func(childComplexity int) int
	}

	UsageDataResponse struct {
		Projects     func(childComplexity int) int
		TotalCount   func(childComplexity int) int
		TotalEntries func(childComplexity int) int
	}

	Weightages struct {
		ExperimentName func(childComplexity int) int
		Weightage      func(childComplexity int) int
	}

	Workflow struct {
		ClusterID           func(childComplexity int) int
		ClusterName         func(childComplexity int) int
		ClusterType         func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		CronSyntax          func(childComplexity int) int
		IsCustomWorkflow    func(childComplexity int) int
		IsRemoved           func(childComplexity int) int
		LastUpdatedBy       func(childComplexity int) int
		ProjectID           func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		Weightages          func(childComplexity int) int
		WorkflowDescription func(childComplexity int) int
		WorkflowID          func(childComplexity int) int
		WorkflowManifest    func(childComplexity int) int
		WorkflowName        func(childComplexity int) int
	}

	WorkflowRun struct {
		ClusterID          func(childComplexity int) int
		ClusterName        func(childComplexity int) int
		ClusterType        func(childComplexity int) int
		ExecutedBy         func(childComplexity int) int
		ExecutionData      func(childComplexity int) int
		ExperimentsAwaited func(childComplexity int) int
		ExperimentsFailed  func(childComplexity int) int
		ExperimentsNa      func(childComplexity int) int
		ExperimentsPassed  func(childComplexity int) int
		ExperimentsStopped func(childComplexity int) int
		IsRemoved          func(childComplexity int) int
		LastUpdated        func(childComplexity int) int
		Phase              func(childComplexity int) int
		ProjectID          func(childComplexity int) int
		ResiliencyScore    func(childComplexity int) int
		TotalExperiments   func(childComplexity int) int
		Weightages         func(childComplexity int) int
		WorkflowID         func(childComplexity int) int
		WorkflowName       func(childComplexity int) int
		WorkflowRunID      func(childComplexity int) int
	}

	WorkflowRunDetails struct {
		DateStamp func(childComplexity int) int
		NoOfRuns  func(childComplexity int) int
	}

	WorkflowRunStatsResponse struct {
		AverageResiliencyScore         func(childComplexity int) int
		ExperimentsAwaited             func(childComplexity int) int
		ExperimentsFailed              func(childComplexity int) int
		ExperimentsNa                  func(childComplexity int) int
		ExperimentsPassed              func(childComplexity int) int
		ExperimentsStopped             func(childComplexity int) int
		FailedPercentage               func(childComplexity int) int
		FailedWorkflowRuns             func(childComplexity int) int
		PassedPercentage               func(childComplexity int) int
		RunningWorkflowRuns            func(childComplexity int) int
		SucceededWorkflowRuns          func(childComplexity int) int
		TotalExperiments               func(childComplexity int) int
		TotalWorkflowRuns              func(childComplexity int) int
		WorkflowRunFailedPercentage    func(childComplexity int) int
		WorkflowRunSucceededPercentage func(childComplexity int) int
	}

	WorkflowRunsData struct {
		Value             func(childComplexity int) int
		WorkflowRunDetail func(childComplexity int) int
	}

	WorkflowStat struct {
		ExpRuns   func(childComplexity int) int
		Runs      func(childComplexity int) int
		Schedules func(childComplexity int) int
	}

	WorkflowStatsResponse struct {
		Date  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	WorkflowTemplate struct {
		CreatedAt           func(childComplexity int) int
		IsCustomWorkflow    func(childComplexity int) int
		IsRemoved           func(childComplexity int) int
		Manifest            func(childComplexity int) int
		ProjectID           func(childComplexity int) int
		ProjectName         func(childComplexity int) int
		TemplateDescription func(childComplexity int) int
		TemplateID          func(childComplexity int) int
		TemplateName        func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateChaosWorkFlow(ctx context.Context, request model.ChaosWorkFlowRequest) (*model.ChaosWorkFlowResponse, error)
	ReRunChaosWorkFlow(ctx context.Context, projectID string, workflowID string) (string, error)
	UpdateChaosWorkflow(ctx context.Context, request *model.ChaosWorkFlowRequest) (*model.ChaosWorkFlowResponse, error)
	DeleteChaosWorkflow(ctx context.Context, projectID string, workflowID *string, workflowRunID *string) (bool, error)
	TerminateChaosWorkflow(ctx context.Context, projectID string, workflowID *string, workflowRunID *string) (bool, error)
	ChaosWorkflowRun(ctx context.Context, request model.WorkflowRunRequest) (string, error)
	SyncWorkflowRun(ctx context.Context, projectID string, workflowID string, workflowRunID string) (bool, error)
	CreateDataSource(ctx context.Context, datasource *model.DSInput) (*model.DSResponse, error)
	CreateDashBoard(ctx context.Context, dashboard *model.CreateDBInput) (*model.ListDashboardResponse, error)
	UpdateDataSource(ctx context.Context, datasource model.DSInput) (*model.DSResponse, error)
	UpdateDashboard(ctx context.Context, projectID string, dashboard model.UpdateDBInput, chaosQueryUpdate bool) (string, error)
	UpdatePanel(ctx context.Context, panelInput []*model.Panel) (string, error)
	DeleteDashboard(ctx context.Context, projectID string, dbID *string) (bool, error)
	DeleteDataSource(ctx context.Context, projectID string, input model.DeleteDSInput) (bool, error)
	RegisterCluster(ctx context.Context, request model.RegisterClusterRequest) (*model.RegisterClusterResponse, error)
	ConfirmClusterRegistration(ctx context.Context, request model.ClusterIdentity) (*model.ConfirmClusterRegistrationResponse, error)
	NewClusterEvent(ctx context.Context, request model.NewClusterEventRequest) (string, error)
	DeleteClusters(ctx context.Context, projectID string, clusterIDs []*string) (string, error)
	PodLog(ctx context.Context, request model.PodLog) (string, error)
	KubeObj(ctx context.Context, request model.KubeObjectData) (string, error)
	GitopsNotifier(ctx context.Context, clusterInfo model.ClusterIdentity, workflowID string) (string, error)
	EnableGitOps(ctx context.Context, config model.GitConfig) (bool, error)
	DisableGitOps(ctx context.Context, projectID string) (bool, error)
	UpdateGitOps(ctx context.Context, config model.GitConfig) (bool, error)
	CreateImageRegistry(ctx context.Context, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	UpdateImageRegistry(ctx context.Context, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	DeleteImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (string, error)
	AddChaosHub(ctx context.Context, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	AddRemoteChaosHub(ctx context.Context, request model.CreateRemoteMyHub) (*model.ChaosHub, error)
	SaveChaosHub(ctx context.Context, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	SyncChaosHub(ctx context.Context, id string, projectID string) (string, error)
	GenerateSSHKey(ctx context.Context) (*model.SSHKey, error)
	UpdateChaosHub(ctx context.Context, request model.UpdateChaosHubRequest) (*model.ChaosHub, error)
	DeleteChaosHub(ctx context.Context, projectID string, hubID string) (bool, error)
	CreateWorkflowTemplate(ctx context.Context, request *model.TemplateInput) (*model.WorkflowTemplate, error)
	DeleteWorkflowTemplate(ctx context.Context, projectID string, templateID string) (bool, error)
}
type QueryResolver interface {
	ListWorkflows(ctx context.Context, request model.ListWorkflowsRequest) (*model.ListWorkflowsResponse, error)
	ListWorkflowRuns(ctx context.Context, request model.ListWorkflowRunsRequest) (*model.ListWorkflowRunsResponse, error)
	ListHeatmapData(ctx context.Context, projectID string, workflowID string, year int) ([]*model.HeatmapDataResponse, error)
	ListWorkflowStats(ctx context.Context, projectID string, filter model.TimeFrequency, showWorkflowRuns bool) ([]*model.WorkflowStatsResponse, error)
	GetWorkflowRunStats(ctx context.Context, workflowRunStatsRequest model.WorkflowRunStatsRequest) (*model.WorkflowRunStatsResponse, error)
	ListDataSource(ctx context.Context, projectID string) ([]*model.DSResponse, error)
	GetPrometheusData(ctx context.Context, request *model.PrometheusDataRequest) (*model.PrometheusDataResponse, error)
	GetPromLabelNamesAndValues(ctx context.Context, request *model.PromSeriesInput) (*model.PromSeriesResponse, error)
	GetPromSeriesList(ctx context.Context, request *model.DsDetails) (*model.PromSeriesListResponse, error)
	ListDashboard(ctx context.Context, projectID string, clusterID *string, dbID *string) ([]*model.ListDashboardResponse, error)
	ListPortalDashboardData(ctx context.Context, projectID string, hubName string) ([]*model.PortalDashboardDataResponse, error)
	GetServerVersion(ctx context.Context) (*model.ServerVersionResponse, error)
	ListClusters(ctx context.Context, projectID string, clusterType *string) ([]*model.Cluster, error)
	GetAgentDetails(ctx context.Context, clusterID string, projectID string) (*model.Cluster, error)
	GetManifest(ctx context.Context, projectID string, clusterID string, accessKey string) (string, error)
	GetGitOpsDetails(ctx context.Context, projectID string) (*model.GitConfigResponse, error)
	ListImageRegistry(ctx context.Context, projectID string) ([]*model.ImageRegistryResponse, error)
	GetImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (*model.ImageRegistryResponse, error)
	ListCharts(ctx context.Context, hubName string, projectID string) ([]*model.Chart, error)
	GetHubExperiment(ctx context.Context, request model.ExperimentRequest) (*model.Chart, error)
	ListHubStatus(ctx context.Context, projectID string) ([]*model.ChaosHubStatus, error)
	GetYAMLData(ctx context.Context, request model.ExperimentRequest) (string, error)
	GetExperimentDetails(ctx context.Context, request model.ExperimentRequest) (*model.ExperimentDetails, error)
	ListPredefinedWorkflows(ctx context.Context, hubName string, projectID string) ([]*model.PredefinedWorkflowList, error)
	GetPredefinedExperimentYaml(ctx context.Context, request model.ExperimentRequest) (string, error)
	GetUsageData(ctx context.Context, request model.UsageDataRequest) (*model.UsageDataResponse, error)
	ListWorkflowManifests(ctx context.Context, projectID string) ([]*model.WorkflowTemplate, error)
	GetWorkflowManifestByID(ctx context.Context, projectID string, templateID string) (*model.WorkflowTemplate, error)
}
type SubscriptionResolver interface {
	GetWorkflowEvents(ctx context.Context, projectID string) (<-chan *model.WorkflowRun, error)
	ViewDashboard(ctx context.Context, dashboardID *string, promQueries []*model.PromQueryInput, dashboardQueryMap []*model.QueryMapForPanelGroup, dataVariables model.DataVars) (<-chan *model.DashboardPromResponse, error)
	GetClusterEvents(ctx context.Context, projectID string) (<-chan *model.ClusterEventResponse, error)
	ClusterConnect(ctx context.Context, clusterInfo model.ClusterIdentity) (<-chan *model.ClusterActionResponse, error)
	GetPodLog(ctx context.Context, request model.PodLogRequest) (<-chan *model.PodLogResponse, error)
	GetKubeObject(ctx context.Context, request model.KubeObjectRequest) (<-chan *model.KubeObjectResponse, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ActionPayload.externalData":
		if e.complexity.ActionPayload.ExternalData == nil {
			break
		}

		return e.complexity.ActionPayload.ExternalData(childComplexity), true

	case "ActionPayload.k8sManifest":
		if e.complexity.ActionPayload.K8sManifest == nil {
			break
		}

		return e.complexity.ActionPayload.K8sManifest(childComplexity), true

	case "ActionPayload.namespace":
		if e.complexity.ActionPayload.Namespace == nil {
			break
		}

		return e.complexity.ActionPayload.Namespace(childComplexity), true

	case "ActionPayload.requestType":
		if e.complexity.ActionPayload.RequestType == nil {
			break
		}

		return e.complexity.ActionPayload.RequestType(childComplexity), true

	case "ActionPayload.username":
		if e.complexity.ActionPayload.Username == nil {
			break
		}

		return e.complexity.ActionPayload.Username(childComplexity), true

	case "AgentStat.active":
		if e.complexity.AgentStat.Active == nil {
			break
		}

		return e.complexity.AgentStat.Active(childComplexity), true

	case "AgentStat.cluster":
		if e.complexity.AgentStat.Cluster == nil {
			break
		}

		return e.complexity.AgentStat.Cluster(childComplexity), true

	case "AgentStat.ns":
		if e.complexity.AgentStat.Ns == nil {
			break
		}

		return e.complexity.AgentStat.Ns(childComplexity), true

	case "AgentStat.total":
		if e.complexity.AgentStat.Total == nil {
			break
		}

		return e.complexity.AgentStat.Total(childComplexity), true

	case "Annotation.categories":
		if e.complexity.Annotation.Categories == nil {
			break
		}

		return e.complexity.Annotation.Categories(childComplexity), true

	case "Annotation.chartDescription":
		if e.complexity.Annotation.ChartDescription == nil {
			break
		}

		return e.complexity.Annotation.ChartDescription(childComplexity), true

	case "Annotation.createdAt":
		if e.complexity.Annotation.CreatedAt == nil {
			break
		}

		return e.complexity.Annotation.CreatedAt(childComplexity), true

	case "Annotation.repository":
		if e.complexity.Annotation.Repository == nil {
			break
		}

		return e.complexity.Annotation.Repository(childComplexity), true

	case "Annotation.support":
		if e.complexity.Annotation.Support == nil {
			break
		}

		return e.complexity.Annotation.Support(childComplexity), true

	case "Annotation.vendor":
		if e.complexity.Annotation.Vendor == nil {
			break
		}

		return e.complexity.Annotation.Vendor(childComplexity), true

	case "AnnotationsPromResponse.legends":
		if e.complexity.AnnotationsPromResponse.Legends == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.Legends(childComplexity), true

	case "AnnotationsPromResponse.queryID":
		if e.complexity.AnnotationsPromResponse.QueryID == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.QueryID(childComplexity), true

	case "AnnotationsPromResponse.subDataArray":
		if e.complexity.AnnotationsPromResponse.SubDataArray == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.SubDataArray(childComplexity), true

	case "AnnotationsPromResponse.tsvs":
		if e.complexity.AnnotationsPromResponse.Tsvs == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.Tsvs(childComplexity), true

	case "AnnotationsTimeStampValue.date":
		if e.complexity.AnnotationsTimeStampValue.Date == nil {
			break
		}

		return e.complexity.AnnotationsTimeStampValue.Date(childComplexity), true

	case "AnnotationsTimeStampValue.value":
		if e.complexity.AnnotationsTimeStampValue.Value == nil {
			break
		}

		return e.complexity.AnnotationsTimeStampValue.Value(childComplexity), true

	case "ApplicationMetadataResponse.applications":
		if e.complexity.ApplicationMetadataResponse.Applications == nil {
			break
		}

		return e.complexity.ApplicationMetadataResponse.Applications(childComplexity), true

	case "ApplicationMetadataResponse.namespace":
		if e.complexity.ApplicationMetadataResponse.Namespace == nil {
			break
		}

		return e.complexity.ApplicationMetadataResponse.Namespace(childComplexity), true

	case "ChaosHub.authType":
		if e.complexity.ChaosHub.AuthType == nil {
			break
		}

		return e.complexity.ChaosHub.AuthType(childComplexity), true

	case "ChaosHub.createdAt":
		if e.complexity.ChaosHub.CreatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.CreatedAt(childComplexity), true

	case "ChaosHub.hubName":
		if e.complexity.ChaosHub.HubName == nil {
			break
		}

		return e.complexity.ChaosHub.HubName(childComplexity), true

	case "ChaosHub.hubType":
		if e.complexity.ChaosHub.HubType == nil {
			break
		}

		return e.complexity.ChaosHub.HubType(childComplexity), true

	case "ChaosHub.id":
		if e.complexity.ChaosHub.ID == nil {
			break
		}

		return e.complexity.ChaosHub.ID(childComplexity), true

	case "ChaosHub.isPrivate":
		if e.complexity.ChaosHub.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHub.IsPrivate(childComplexity), true

	case "ChaosHub.isRemoved":
		if e.complexity.ChaosHub.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHub.IsRemoved(childComplexity), true

	case "ChaosHub.lastSyncedAt":
		if e.complexity.ChaosHub.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHub.LastSyncedAt(childComplexity), true

	case "ChaosHub.password":
		if e.complexity.ChaosHub.Password == nil {
			break
		}

		return e.complexity.ChaosHub.Password(childComplexity), true

	case "ChaosHub.projectID":
		if e.complexity.ChaosHub.ProjectID == nil {
			break
		}

		return e.complexity.ChaosHub.ProjectID(childComplexity), true

	case "ChaosHub.repoBranch":
		if e.complexity.ChaosHub.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHub.RepoBranch(childComplexity), true

	case "ChaosHub.repoURL":
		if e.complexity.ChaosHub.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHub.RepoURL(childComplexity), true

	case "ChaosHub.sshPrivateKey":
		if e.complexity.ChaosHub.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHub.SSHPrivateKey(childComplexity), true

	case "ChaosHub.token":
		if e.complexity.ChaosHub.Token == nil {
			break
		}

		return e.complexity.ChaosHub.Token(childComplexity), true

	case "ChaosHub.updatedAt":
		if e.complexity.ChaosHub.UpdatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.UpdatedAt(childComplexity), true

	case "ChaosHub.userName":
		if e.complexity.ChaosHub.UserName == nil {
			break
		}

		return e.complexity.ChaosHub.UserName(childComplexity), true

	case "ChaosHubStatus.authType":
		if e.complexity.ChaosHubStatus.AuthType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.AuthType(childComplexity), true

	case "ChaosHubStatus.hubName":
		if e.complexity.ChaosHubStatus.HubName == nil {
			break
		}

		return e.complexity.ChaosHubStatus.HubName(childComplexity), true

	case "ChaosHubStatus.hubType":
		if e.complexity.ChaosHubStatus.HubType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.HubType(childComplexity), true

	case "ChaosHubStatus.id":
		if e.complexity.ChaosHubStatus.ID == nil {
			break
		}

		return e.complexity.ChaosHubStatus.ID(childComplexity), true

	case "ChaosHubStatus.isAvailable":
		if e.complexity.ChaosHubStatus.IsAvailable == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsAvailable(childComplexity), true

	case "ChaosHubStatus.isPrivate":
		if e.complexity.ChaosHubStatus.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsPrivate(childComplexity), true

	case "ChaosHubStatus.isRemoved":
		if e.complexity.ChaosHubStatus.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsRemoved(childComplexity), true

	case "ChaosHubStatus.lastSyncedAt":
		if e.complexity.ChaosHubStatus.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.LastSyncedAt(childComplexity), true

	case "ChaosHubStatus.password":
		if e.complexity.ChaosHubStatus.Password == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Password(childComplexity), true

	case "ChaosHubStatus.repoBranch":
		if e.complexity.ChaosHubStatus.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoBranch(childComplexity), true

	case "ChaosHubStatus.repoURL":
		if e.complexity.ChaosHubStatus.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoURL(childComplexity), true

	case "ChaosHubStatus.sshPrivateKey":
		if e.complexity.ChaosHubStatus.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPrivateKey(childComplexity), true

	case "ChaosHubStatus.sshPublicKey":
		if e.complexity.ChaosHubStatus.SSHPublicKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPublicKey(childComplexity), true

	case "ChaosHubStatus.token":
		if e.complexity.ChaosHubStatus.Token == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Token(childComplexity), true

	case "ChaosHubStatus.totalExp":
		if e.complexity.ChaosHubStatus.TotalExp == nil {
			break
		}

		return e.complexity.ChaosHubStatus.TotalExp(childComplexity), true

	case "ChaosHubStatus.userName":
		if e.complexity.ChaosHubStatus.UserName == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UserName(childComplexity), true

	case "ChaosWorkFlowResponse.cronSyntax":
		if e.complexity.ChaosWorkFlowResponse.CronSyntax == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.CronSyntax(childComplexity), true

	case "ChaosWorkFlowResponse.isCustomWorkflow":
		if e.complexity.ChaosWorkFlowResponse.IsCustomWorkflow == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.IsCustomWorkflow(childComplexity), true

	case "ChaosWorkFlowResponse.workflowDescription":
		if e.complexity.ChaosWorkFlowResponse.WorkflowDescription == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.WorkflowDescription(childComplexity), true

	case "ChaosWorkFlowResponse.workflowID":
		if e.complexity.ChaosWorkFlowResponse.WorkflowID == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.WorkflowID(childComplexity), true

	case "ChaosWorkFlowResponse.workflowName":
		if e.complexity.ChaosWorkFlowResponse.WorkflowName == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.WorkflowName(childComplexity), true

	case "Chart.apiVersion":
		if e.complexity.Chart.APIVersion == nil {
			break
		}

		return e.complexity.Chart.APIVersion(childComplexity), true

	case "Chart.kind":
		if e.complexity.Chart.Kind == nil {
			break
		}

		return e.complexity.Chart.Kind(childComplexity), true

	case "Chart.metadata":
		if e.complexity.Chart.Metadata == nil {
			break
		}

		return e.complexity.Chart.Metadata(childComplexity), true

	case "Chart.packageInfo":
		if e.complexity.Chart.PackageInfo == nil {
			break
		}

		return e.complexity.Chart.PackageInfo(childComplexity), true

	case "Chart.spec":
		if e.complexity.Chart.Spec == nil {
			break
		}

		return e.complexity.Chart.Spec(childComplexity), true

	case "Cluster.accessKey":
		if e.complexity.Cluster.AccessKey == nil {
			break
		}

		return e.complexity.Cluster.AccessKey(childComplexity), true

	case "Cluster.agentNamespace":
		if e.complexity.Cluster.AgentNamespace == nil {
			break
		}

		return e.complexity.Cluster.AgentNamespace(childComplexity), true

	case "Cluster.agentNsExists":
		if e.complexity.Cluster.AgentNsExists == nil {
			break
		}

		return e.complexity.Cluster.AgentNsExists(childComplexity), true

	case "Cluster.agentSaExists":
		if e.complexity.Cluster.AgentSaExists == nil {
			break
		}

		return e.complexity.Cluster.AgentSaExists(childComplexity), true

	case "Cluster.agentScope":
		if e.complexity.Cluster.AgentScope == nil {
			break
		}

		return e.complexity.Cluster.AgentScope(childComplexity), true

	case "Cluster.clusterID":
		if e.complexity.Cluster.ClusterID == nil {
			break
		}

		return e.complexity.Cluster.ClusterID(childComplexity), true

	case "Cluster.clusterName":
		if e.complexity.Cluster.ClusterName == nil {
			break
		}

		return e.complexity.Cluster.ClusterName(childComplexity), true

	case "Cluster.clusterType":
		if e.complexity.Cluster.ClusterType == nil {
			break
		}

		return e.complexity.Cluster.ClusterType(childComplexity), true

	case "Cluster.createdAt":
		if e.complexity.Cluster.CreatedAt == nil {
			break
		}

		return e.complexity.Cluster.CreatedAt(childComplexity), true

	case "Cluster.description":
		if e.complexity.Cluster.Description == nil {
			break
		}

		return e.complexity.Cluster.Description(childComplexity), true

	case "Cluster.isActive":
		if e.complexity.Cluster.IsActive == nil {
			break
		}

		return e.complexity.Cluster.IsActive(childComplexity), true

	case "Cluster.isClusterConfirmed":
		if e.complexity.Cluster.IsClusterConfirmed == nil {
			break
		}

		return e.complexity.Cluster.IsClusterConfirmed(childComplexity), true

	case "Cluster.isRegistered":
		if e.complexity.Cluster.IsRegistered == nil {
			break
		}

		return e.complexity.Cluster.IsRegistered(childComplexity), true

	case "Cluster.lastWorkflowTimestamp":
		if e.complexity.Cluster.LastWorkflowTimestamp == nil {
			break
		}

		return e.complexity.Cluster.LastWorkflowTimestamp(childComplexity), true

	case "Cluster.noOfSchedules":
		if e.complexity.Cluster.NoOfSchedules == nil {
			break
		}

		return e.complexity.Cluster.NoOfSchedules(childComplexity), true

	case "Cluster.noOfWorkflows":
		if e.complexity.Cluster.NoOfWorkflows == nil {
			break
		}

		return e.complexity.Cluster.NoOfWorkflows(childComplexity), true

	case "Cluster.platformName":
		if e.complexity.Cluster.PlatformName == nil {
			break
		}

		return e.complexity.Cluster.PlatformName(childComplexity), true

	case "Cluster.projectID":
		if e.complexity.Cluster.ProjectID == nil {
			break
		}

		return e.complexity.Cluster.ProjectID(childComplexity), true

	case "Cluster.serviceAccount":
		if e.complexity.Cluster.ServiceAccount == nil {
			break
		}

		return e.complexity.Cluster.ServiceAccount(childComplexity), true

	case "Cluster.startTime":
		if e.complexity.Cluster.StartTime == nil {
			break
		}

		return e.complexity.Cluster.StartTime(childComplexity), true

	case "Cluster.token":
		if e.complexity.Cluster.Token == nil {
			break
		}

		return e.complexity.Cluster.Token(childComplexity), true

	case "Cluster.updatedAt":
		if e.complexity.Cluster.UpdatedAt == nil {
			break
		}

		return e.complexity.Cluster.UpdatedAt(childComplexity), true

	case "Cluster.version":
		if e.complexity.Cluster.Version == nil {
			break
		}

		return e.complexity.Cluster.Version(childComplexity), true

	case "ClusterActionResponse.action":
		if e.complexity.ClusterActionResponse.Action == nil {
			break
		}

		return e.complexity.ClusterActionResponse.Action(childComplexity), true

	case "ClusterActionResponse.projectID":
		if e.complexity.ClusterActionResponse.ProjectID == nil {
			break
		}

		return e.complexity.ClusterActionResponse.ProjectID(childComplexity), true

	case "ClusterEventResponse.cluster":
		if e.complexity.ClusterEventResponse.Cluster == nil {
			break
		}

		return e.complexity.ClusterEventResponse.Cluster(childComplexity), true

	case "ClusterEventResponse.description":
		if e.complexity.ClusterEventResponse.Description == nil {
			break
		}

		return e.complexity.ClusterEventResponse.Description(childComplexity), true

	case "ClusterEventResponse.eventID":
		if e.complexity.ClusterEventResponse.EventID == nil {
			break
		}

		return e.complexity.ClusterEventResponse.EventID(childComplexity), true

	case "ClusterEventResponse.eventName":
		if e.complexity.ClusterEventResponse.EventName == nil {
			break
		}

		return e.complexity.ClusterEventResponse.EventName(childComplexity), true

	case "ClusterEventResponse.eventType":
		if e.complexity.ClusterEventResponse.EventType == nil {
			break
		}

		return e.complexity.ClusterEventResponse.EventType(childComplexity), true

	case "ConfirmClusterRegistrationResponse.clusterID":
		if e.complexity.ConfirmClusterRegistrationResponse.ClusterID == nil {
			break
		}

		return e.complexity.ConfirmClusterRegistrationResponse.ClusterID(childComplexity), true

	case "ConfirmClusterRegistrationResponse.isClusterConfirmed":
		if e.complexity.ConfirmClusterRegistrationResponse.IsClusterConfirmed == nil {
			break
		}

		return e.complexity.ConfirmClusterRegistrationResponse.IsClusterConfirmed(childComplexity), true

	case "ConfirmClusterRegistrationResponse.newAccessKey":
		if e.complexity.ConfirmClusterRegistrationResponse.NewAccessKey == nil {
			break
		}

		return e.complexity.ConfirmClusterRegistrationResponse.NewAccessKey(childComplexity), true

	case "DSResponse.accessType":
		if e.complexity.DSResponse.AccessType == nil {
			break
		}

		return e.complexity.DSResponse.AccessType(childComplexity), true

	case "DSResponse.authType":
		if e.complexity.DSResponse.AuthType == nil {
			break
		}

		return e.complexity.DSResponse.AuthType(childComplexity), true

	case "DSResponse.basicAuthPassword":
		if e.complexity.DSResponse.BasicAuthPassword == nil {
			break
		}

		return e.complexity.DSResponse.BasicAuthPassword(childComplexity), true

	case "DSResponse.basicAuthUsername":
		if e.complexity.DSResponse.BasicAuthUsername == nil {
			break
		}

		return e.complexity.DSResponse.BasicAuthUsername(childComplexity), true

	case "DSResponse.createdAt":
		if e.complexity.DSResponse.CreatedAt == nil {
			break
		}

		return e.complexity.DSResponse.CreatedAt(childComplexity), true

	case "DSResponse.dsID":
		if e.complexity.DSResponse.DsID == nil {
			break
		}

		return e.complexity.DSResponse.DsID(childComplexity), true

	case "DSResponse.dsName":
		if e.complexity.DSResponse.DsName == nil {
			break
		}

		return e.complexity.DSResponse.DsName(childComplexity), true

	case "DSResponse.dsType":
		if e.complexity.DSResponse.DsType == nil {
			break
		}

		return e.complexity.DSResponse.DsType(childComplexity), true

	case "DSResponse.dsURL":
		if e.complexity.DSResponse.DsURL == nil {
			break
		}

		return e.complexity.DSResponse.DsURL(childComplexity), true

	case "DSResponse.httpMethod":
		if e.complexity.DSResponse.HTTPMethod == nil {
			break
		}

		return e.complexity.DSResponse.HTTPMethod(childComplexity), true

	case "DSResponse.healthStatus":
		if e.complexity.DSResponse.HealthStatus == nil {
			break
		}

		return e.complexity.DSResponse.HealthStatus(childComplexity), true

	case "DSResponse.projectID":
		if e.complexity.DSResponse.ProjectID == nil {
			break
		}

		return e.complexity.DSResponse.ProjectID(childComplexity), true

	case "DSResponse.queryTimeout":
		if e.complexity.DSResponse.QueryTimeout == nil {
			break
		}

		return e.complexity.DSResponse.QueryTimeout(childComplexity), true

	case "DSResponse.scrapeInterval":
		if e.complexity.DSResponse.ScrapeInterval == nil {
			break
		}

		return e.complexity.DSResponse.ScrapeInterval(childComplexity), true

	case "DSResponse.updatedAt":
		if e.complexity.DSResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.DSResponse.UpdatedAt(childComplexity), true

	case "DashboardPromResponse.annotationsResponse":
		if e.complexity.DashboardPromResponse.AnnotationsResponse == nil {
			break
		}

		return e.complexity.DashboardPromResponse.AnnotationsResponse(childComplexity), true

	case "DashboardPromResponse.dashboardMetricsResponse":
		if e.complexity.DashboardPromResponse.DashboardMetricsResponse == nil {
			break
		}

		return e.complexity.DashboardPromResponse.DashboardMetricsResponse(childComplexity), true

	case "ExperimentDetails.engineDetails":
		if e.complexity.ExperimentDetails.EngineDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.EngineDetails(childComplexity), true

	case "ExperimentDetails.experimentDetails":
		if e.complexity.ExperimentDetails.ExperimentDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.ExperimentDetails(childComplexity), true

	case "Experiments.CSV":
		if e.complexity.Experiments.Csv == nil {
			break
		}

		return e.complexity.Experiments.Csv(childComplexity), true

	case "Experiments.desc":
		if e.complexity.Experiments.Desc == nil {
			break
		}

		return e.complexity.Experiments.Desc(childComplexity), true

	case "Experiments.name":
		if e.complexity.Experiments.Name == nil {
			break
		}

		return e.complexity.Experiments.Name(childComplexity), true

	case "GitConfigResponse.authType":
		if e.complexity.GitConfigResponse.AuthType == nil {
			break
		}

		return e.complexity.GitConfigResponse.AuthType(childComplexity), true

	case "GitConfigResponse.branch":
		if e.complexity.GitConfigResponse.Branch == nil {
			break
		}

		return e.complexity.GitConfigResponse.Branch(childComplexity), true

	case "GitConfigResponse.enabled":
		if e.complexity.GitConfigResponse.Enabled == nil {
			break
		}

		return e.complexity.GitConfigResponse.Enabled(childComplexity), true

	case "GitConfigResponse.password":
		if e.complexity.GitConfigResponse.Password == nil {
			break
		}

		return e.complexity.GitConfigResponse.Password(childComplexity), true

	case "GitConfigResponse.projectID":
		if e.complexity.GitConfigResponse.ProjectID == nil {
			break
		}

		return e.complexity.GitConfigResponse.ProjectID(childComplexity), true

	case "GitConfigResponse.repoURL":
		if e.complexity.GitConfigResponse.RepoURL == nil {
			break
		}

		return e.complexity.GitConfigResponse.RepoURL(childComplexity), true

	case "GitConfigResponse.sshPrivateKey":
		if e.complexity.GitConfigResponse.SSHPrivateKey == nil {
			break
		}

		return e.complexity.GitConfigResponse.SSHPrivateKey(childComplexity), true

	case "GitConfigResponse.token":
		if e.complexity.GitConfigResponse.Token == nil {
			break
		}

		return e.complexity.GitConfigResponse.Token(childComplexity), true

	case "GitConfigResponse.userName":
		if e.complexity.GitConfigResponse.UserName == nil {
			break
		}

		return e.complexity.GitConfigResponse.UserName(childComplexity), true

	case "HeatmapDataResponse.bins":
		if e.complexity.HeatmapDataResponse.Bins == nil {
			break
		}

		return e.complexity.HeatmapDataResponse.Bins(childComplexity), true

	case "ImageRegistry.enableRegistry":
		if e.complexity.ImageRegistry.EnableRegistry == nil {
			break
		}

		return e.complexity.ImageRegistry.EnableRegistry(childComplexity), true

	case "ImageRegistry.imageRegistryName":
		if e.complexity.ImageRegistry.ImageRegistryName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryName(childComplexity), true

	case "ImageRegistry.imageRegistryType":
		if e.complexity.ImageRegistry.ImageRegistryType == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryType(childComplexity), true

	case "ImageRegistry.imageRepoName":
		if e.complexity.ImageRegistry.ImageRepoName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRepoName(childComplexity), true

	case "ImageRegistry.isDefault":
		if e.complexity.ImageRegistry.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistry.IsDefault(childComplexity), true

	case "ImageRegistry.secretName":
		if e.complexity.ImageRegistry.SecretName == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretName(childComplexity), true

	case "ImageRegistry.secretNamespace":
		if e.complexity.ImageRegistry.SecretNamespace == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretNamespace(childComplexity), true

	case "ImageRegistryResponse.createdAt":
		if e.complexity.ImageRegistryResponse.CreatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.CreatedAt(childComplexity), true

	case "ImageRegistryResponse.imageRegistryID":
		if e.complexity.ImageRegistryResponse.ImageRegistryID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryID(childComplexity), true

	case "ImageRegistryResponse.imageRegistryInfo":
		if e.complexity.ImageRegistryResponse.ImageRegistryInfo == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryInfo(childComplexity), true

	case "ImageRegistryResponse.isDefault":
		if e.complexity.ImageRegistryResponse.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsDefault(childComplexity), true

	case "ImageRegistryResponse.isRemoved":
		if e.complexity.ImageRegistryResponse.IsRemoved == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsRemoved(childComplexity), true

	case "ImageRegistryResponse.projectID":
		if e.complexity.ImageRegistryResponse.ProjectID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ProjectID(childComplexity), true

	case "ImageRegistryResponse.updatedAt":
		if e.complexity.ImageRegistryResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.UpdatedAt(childComplexity), true

	case "KubeObjectResponse.clusterID":
		if e.complexity.KubeObjectResponse.ClusterID == nil {
			break
		}

		return e.complexity.KubeObjectResponse.ClusterID(childComplexity), true

	case "KubeObjectResponse.kubeObj":
		if e.complexity.KubeObjectResponse.KubeObj == nil {
			break
		}

		return e.complexity.KubeObjectResponse.KubeObj(childComplexity), true

	case "LabelValue.label":
		if e.complexity.LabelValue.Label == nil {
			break
		}

		return e.complexity.LabelValue.Label(childComplexity), true

	case "LabelValue.values":
		if e.complexity.LabelValue.Values == nil {
			break
		}

		return e.complexity.LabelValue.Values(childComplexity), true

	case "Link.name":
		if e.complexity.Link.Name == nil {
			break
		}

		return e.complexity.Link.Name(childComplexity), true

	case "Link.url":
		if e.complexity.Link.URL == nil {
			break
		}

		return e.complexity.Link.URL(childComplexity), true

	case "ListDashboardResponse.applicationMetadataMap":
		if e.complexity.ListDashboardResponse.ApplicationMetadataMap == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ApplicationMetadataMap(childComplexity), true

	case "ListDashboardResponse.chaosEventQueryTemplate":
		if e.complexity.ListDashboardResponse.ChaosEventQueryTemplate == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ChaosEventQueryTemplate(childComplexity), true

	case "ListDashboardResponse.chaosVerdictQueryTemplate":
		if e.complexity.ListDashboardResponse.ChaosVerdictQueryTemplate == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ChaosVerdictQueryTemplate(childComplexity), true

	case "ListDashboardResponse.clusterID":
		if e.complexity.ListDashboardResponse.ClusterID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ClusterID(childComplexity), true

	case "ListDashboardResponse.clusterName":
		if e.complexity.ListDashboardResponse.ClusterName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ClusterName(childComplexity), true

	case "ListDashboardResponse.createdAt":
		if e.complexity.ListDashboardResponse.CreatedAt == nil {
			break
		}

		return e.complexity.ListDashboardResponse.CreatedAt(childComplexity), true

	case "ListDashboardResponse.dbID":
		if e.complexity.ListDashboardResponse.DbID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbID(childComplexity), true

	case "ListDashboardResponse.dbInformation":
		if e.complexity.ListDashboardResponse.DbInformation == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbInformation(childComplexity), true

	case "ListDashboardResponse.dbName":
		if e.complexity.ListDashboardResponse.DbName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbName(childComplexity), true

	case "ListDashboardResponse.dbTypeID":
		if e.complexity.ListDashboardResponse.DbTypeID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbTypeID(childComplexity), true

	case "ListDashboardResponse.dbTypeName":
		if e.complexity.ListDashboardResponse.DbTypeName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbTypeName(childComplexity), true

	case "ListDashboardResponse.dsHealthStatus":
		if e.complexity.ListDashboardResponse.DsHealthStatus == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsHealthStatus(childComplexity), true

	case "ListDashboardResponse.dsID":
		if e.complexity.ListDashboardResponse.DsID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsID(childComplexity), true

	case "ListDashboardResponse.dsName":
		if e.complexity.ListDashboardResponse.DsName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsName(childComplexity), true

	case "ListDashboardResponse.dsType":
		if e.complexity.ListDashboardResponse.DsType == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsType(childComplexity), true

	case "ListDashboardResponse.dsURL":
		if e.complexity.ListDashboardResponse.DsURL == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsURL(childComplexity), true

	case "ListDashboardResponse.endTime":
		if e.complexity.ListDashboardResponse.EndTime == nil {
			break
		}

		return e.complexity.ListDashboardResponse.EndTime(childComplexity), true

	case "ListDashboardResponse.panelGroups":
		if e.complexity.ListDashboardResponse.PanelGroups == nil {
			break
		}

		return e.complexity.ListDashboardResponse.PanelGroups(childComplexity), true

	case "ListDashboardResponse.projectID":
		if e.complexity.ListDashboardResponse.ProjectID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ProjectID(childComplexity), true

	case "ListDashboardResponse.refreshRate":
		if e.complexity.ListDashboardResponse.RefreshRate == nil {
			break
		}

		return e.complexity.ListDashboardResponse.RefreshRate(childComplexity), true

	case "ListDashboardResponse.startTime":
		if e.complexity.ListDashboardResponse.StartTime == nil {
			break
		}

		return e.complexity.ListDashboardResponse.StartTime(childComplexity), true

	case "ListDashboardResponse.updatedAt":
		if e.complexity.ListDashboardResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.ListDashboardResponse.UpdatedAt(childComplexity), true

	case "ListDashboardResponse.viewedAt":
		if e.complexity.ListDashboardResponse.ViewedAt == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ViewedAt(childComplexity), true

	case "ListWorkflowRunsResponse.totalNoOfWorkflowRuns":
		if e.complexity.ListWorkflowRunsResponse.TotalNoOfWorkflowRuns == nil {
			break
		}

		return e.complexity.ListWorkflowRunsResponse.TotalNoOfWorkflowRuns(childComplexity), true

	case "ListWorkflowRunsResponse.workflowRuns":
		if e.complexity.ListWorkflowRunsResponse.WorkflowRuns == nil {
			break
		}

		return e.complexity.ListWorkflowRunsResponse.WorkflowRuns(childComplexity), true

	case "ListWorkflowsResponse.totalNoOfWorkflows":
		if e.complexity.ListWorkflowsResponse.TotalNoOfWorkflows == nil {
			break
		}

		return e.complexity.ListWorkflowsResponse.TotalNoOfWorkflows(childComplexity), true

	case "ListWorkflowsResponse.workflows":
		if e.complexity.ListWorkflowsResponse.Workflows == nil {
			break
		}

		return e.complexity.ListWorkflowsResponse.Workflows(childComplexity), true

	case "Maintainer.email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Metadata.annotations":
		if e.complexity.Metadata.Annotations == nil {
			break
		}

		return e.complexity.Metadata.Annotations(childComplexity), true

	case "Metadata.name":
		if e.complexity.Metadata.Name == nil {
			break
		}

		return e.complexity.Metadata.Name(childComplexity), true

	case "Metadata.version":
		if e.complexity.Metadata.Version == nil {
			break
		}

		return e.complexity.Metadata.Version(childComplexity), true

	case "MetricDataForPanel.panelID":
		if e.complexity.MetricDataForPanel.PanelID == nil {
			break
		}

		return e.complexity.MetricDataForPanel.PanelID(childComplexity), true

	case "MetricDataForPanel.panelMetricsResponse":
		if e.complexity.MetricDataForPanel.PanelMetricsResponse == nil {
			break
		}

		return e.complexity.MetricDataForPanel.PanelMetricsResponse(childComplexity), true

	case "MetricDataForPanelGroup.panelGroupID":
		if e.complexity.MetricDataForPanelGroup.PanelGroupID == nil {
			break
		}

		return e.complexity.MetricDataForPanelGroup.PanelGroupID(childComplexity), true

	case "MetricDataForPanelGroup.panelGroupMetricsResponse":
		if e.complexity.MetricDataForPanelGroup.PanelGroupMetricsResponse == nil {
			break
		}

		return e.complexity.MetricDataForPanelGroup.PanelGroupMetricsResponse(childComplexity), true

	case "MetricsPromResponse.legends":
		if e.complexity.MetricsPromResponse.Legends == nil {
			break
		}

		return e.complexity.MetricsPromResponse.Legends(childComplexity), true

	case "MetricsPromResponse.queryID":
		if e.complexity.MetricsPromResponse.QueryID == nil {
			break
		}

		return e.complexity.MetricsPromResponse.QueryID(childComplexity), true

	case "MetricsPromResponse.tsvs":
		if e.complexity.MetricsPromResponse.Tsvs == nil {
			break
		}

		return e.complexity.MetricsPromResponse.Tsvs(childComplexity), true

	case "MetricsTimeStampValue.date":
		if e.complexity.MetricsTimeStampValue.Date == nil {
			break
		}

		return e.complexity.MetricsTimeStampValue.Date(childComplexity), true

	case "MetricsTimeStampValue.value":
		if e.complexity.MetricsTimeStampValue.Value == nil {
			break
		}

		return e.complexity.MetricsTimeStampValue.Value(childComplexity), true

	case "Mutation.addChaosHub":
		if e.complexity.Mutation.AddChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddChaosHub(childComplexity, args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.addRemoteChaosHub":
		if e.complexity.Mutation.AddRemoteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addRemoteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRemoteChaosHub(childComplexity, args["request"].(model.CreateRemoteMyHub)), true

	case "Mutation.chaosWorkflowRun":
		if e.complexity.Mutation.ChaosWorkflowRun == nil {
			break
		}

		args, err := ec.field_Mutation_chaosWorkflowRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChaosWorkflowRun(childComplexity, args["request"].(model.WorkflowRunRequest)), true

	case "Mutation.confirmClusterRegistration":
		if e.complexity.Mutation.ConfirmClusterRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_confirmClusterRegistration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmClusterRegistration(childComplexity, args["request"].(model.ClusterIdentity)), true

	case "Mutation.createChaosWorkFlow":
		if e.complexity.Mutation.CreateChaosWorkFlow == nil {
			break
		}

		args, err := ec.field_Mutation_createChaosWorkFlow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChaosWorkFlow(childComplexity, args["request"].(model.ChaosWorkFlowRequest)), true

	case "Mutation.createDashBoard":
		if e.complexity.Mutation.CreateDashBoard == nil {
			break
		}

		args, err := ec.field_Mutation_createDashBoard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDashBoard(childComplexity, args["dashboard"].(*model.CreateDBInput)), true

	case "Mutation.createDataSource":
		if e.complexity.Mutation.CreateDataSource == nil {
			break
		}

		args, err := ec.field_Mutation_createDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDataSource(childComplexity, args["datasource"].(*model.DSInput)), true

	case "Mutation.createImageRegistry":
		if e.complexity.Mutation.CreateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_createImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateImageRegistry(childComplexity, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "Mutation.createWorkflowTemplate":
		if e.complexity.Mutation.CreateWorkflowTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_createWorkflowTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateWorkflowTemplate(childComplexity, args["request"].(*model.TemplateInput)), true

	case "Mutation.deleteChaosHub":
		if e.complexity.Mutation.DeleteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosHub(childComplexity, args["projectID"].(string), args["hubID"].(string)), true

	case "Mutation.deleteChaosWorkflow":
		if e.complexity.Mutation.DeleteChaosWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosWorkflow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosWorkflow(childComplexity, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string)), true

	case "Mutation.deleteClusters":
		if e.complexity.Mutation.DeleteClusters == nil {
			break
		}

		args, err := ec.field_Mutation_deleteClusters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteClusters(childComplexity, args["projectID"].(string), args["clusterIDs"].([]*string)), true

	case "Mutation.deleteDashboard":
		if e.complexity.Mutation.DeleteDashboard == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDashboard(childComplexity, args["projectID"].(string), args["dbID"].(*string)), true

	case "Mutation.deleteDataSource":
		if e.complexity.Mutation.DeleteDataSource == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDataSource(childComplexity, args["projectID"].(string), args["input"].(model.DeleteDSInput)), true

	case "Mutation.deleteImageRegistry":
		if e.complexity.Mutation.DeleteImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_deleteImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Mutation.deleteWorkflowTemplate":
		if e.complexity.Mutation.DeleteWorkflowTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWorkflowTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWorkflowTemplate(childComplexity, args["projectID"].(string), args["templateID"].(string)), true

	case "Mutation.disableGitOps":
		if e.complexity.Mutation.DisableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_disableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableGitOps(childComplexity, args["projectID"].(string)), true

	case "Mutation.enableGitOps":
		if e.complexity.Mutation.EnableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_enableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableGitOps(childComplexity, args["config"].(model.GitConfig)), true

	case "Mutation.generateSSHKey":
		if e.complexity.Mutation.GenerateSSHKey == nil {
			break
		}

		return e.complexity.Mutation.GenerateSSHKey(childComplexity), true

	case "Mutation.gitopsNotifier":
		if e.complexity.Mutation.GitopsNotifier == nil {
			break
		}

		args, err := ec.field_Mutation_gitopsNotifier_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GitopsNotifier(childComplexity, args["clusterInfo"].(model.ClusterIdentity), args["workflowID"].(string)), true

	case "Mutation.kubeObj":
		if e.complexity.Mutation.KubeObj == nil {
			break
		}

		args, err := ec.field_Mutation_kubeObj_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.KubeObj(childComplexity, args["request"].(model.KubeObjectData)), true

	case "Mutation.newClusterEvent":
		if e.complexity.Mutation.NewClusterEvent == nil {
			break
		}

		args, err := ec.field_Mutation_newClusterEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewClusterEvent(childComplexity, args["request"].(model.NewClusterEventRequest)), true

	case "Mutation.podLog":
		if e.complexity.Mutation.PodLog == nil {
			break
		}

		args, err := ec.field_Mutation_podLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PodLog(childComplexity, args["request"].(model.PodLog)), true

	case "Mutation.reRunChaosWorkFlow":
		if e.complexity.Mutation.ReRunChaosWorkFlow == nil {
			break
		}

		args, err := ec.field_Mutation_reRunChaosWorkFlow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReRunChaosWorkFlow(childComplexity, args["projectID"].(string), args["workflowID"].(string)), true

	case "Mutation.registerCluster":
		if e.complexity.Mutation.RegisterCluster == nil {
			break
		}

		args, err := ec.field_Mutation_registerCluster_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterCluster(childComplexity, args["request"].(model.RegisterClusterRequest)), true

	case "Mutation.saveChaosHub":
		if e.complexity.Mutation.SaveChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_saveChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveChaosHub(childComplexity, args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.syncChaosHub":
		if e.complexity.Mutation.SyncChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_syncChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncChaosHub(childComplexity, args["id"].(string), args["projectID"].(string)), true

	case "Mutation.syncWorkflowRun":
		if e.complexity.Mutation.SyncWorkflowRun == nil {
			break
		}

		args, err := ec.field_Mutation_syncWorkflowRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncWorkflowRun(childComplexity, args["projectID"].(string), args["workflowID"].(string), args["workflowRunID"].(string)), true

	case "Mutation.terminateChaosWorkflow":
		if e.complexity.Mutation.TerminateChaosWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_terminateChaosWorkflow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TerminateChaosWorkflow(childComplexity, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string)), true

	case "Mutation.updateChaosHub":
		if e.complexity.Mutation.UpdateChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosHub(childComplexity, args["request"].(model.UpdateChaosHubRequest)), true

	case "Mutation.updateChaosWorkflow":
		if e.complexity.Mutation.UpdateChaosWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosWorkflow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosWorkflow(childComplexity, args["request"].(*model.ChaosWorkFlowRequest)), true

	case "Mutation.updateDashboard":
		if e.complexity.Mutation.UpdateDashboard == nil {
			break
		}

		args, err := ec.field_Mutation_updateDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDashboard(childComplexity, args["projectID"].(string), args["dashboard"].(model.UpdateDBInput), args["chaosQueryUpdate"].(bool)), true

	case "Mutation.updateDataSource":
		if e.complexity.Mutation.UpdateDataSource == nil {
			break
		}

		args, err := ec.field_Mutation_updateDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDataSource(childComplexity, args["datasource"].(model.DSInput)), true

	case "Mutation.updateGitOps":
		if e.complexity.Mutation.UpdateGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_updateGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGitOps(childComplexity, args["config"].(model.GitConfig)), true

	case "Mutation.updateImageRegistry":
		if e.complexity.Mutation.UpdateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_updateImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "Mutation.updatePanel":
		if e.complexity.Mutation.UpdatePanel == nil {
			break
		}

		args, err := ec.field_Mutation_updatePanel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePanel(childComplexity, args["panelInput"].([]*model.Panel)), true

	case "Option.name":
		if e.complexity.Option.Name == nil {
			break
		}

		return e.complexity.Option.Name(childComplexity), true

	case "PackageInformation.experiments":
		if e.complexity.PackageInformation.Experiments == nil {
			break
		}

		return e.complexity.PackageInformation.Experiments(childComplexity), true

	case "PackageInformation.packageName":
		if e.complexity.PackageInformation.PackageName == nil {
			break
		}

		return e.complexity.PackageInformation.PackageName(childComplexity), true

	case "PanelGroupResponse.panelGroupID":
		if e.complexity.PanelGroupResponse.PanelGroupID == nil {
			break
		}

		return e.complexity.PanelGroupResponse.PanelGroupID(childComplexity), true

	case "PanelGroupResponse.panelGroupName":
		if e.complexity.PanelGroupResponse.PanelGroupName == nil {
			break
		}

		return e.complexity.PanelGroupResponse.PanelGroupName(childComplexity), true

	case "PanelGroupResponse.panels":
		if e.complexity.PanelGroupResponse.Panels == nil {
			break
		}

		return e.complexity.PanelGroupResponse.Panels(childComplexity), true

	case "PanelOptionResponse.grIDs":
		if e.complexity.PanelOptionResponse.GrIDs == nil {
			break
		}

		return e.complexity.PanelOptionResponse.GrIDs(childComplexity), true

	case "PanelOptionResponse.leftAxis":
		if e.complexity.PanelOptionResponse.LeftAxis == nil {
			break
		}

		return e.complexity.PanelOptionResponse.LeftAxis(childComplexity), true

	case "PanelOptionResponse.points":
		if e.complexity.PanelOptionResponse.Points == nil {
			break
		}

		return e.complexity.PanelOptionResponse.Points(childComplexity), true

	case "PanelResponse.createdAt":
		if e.complexity.PanelResponse.CreatedAt == nil {
			break
		}

		return e.complexity.PanelResponse.CreatedAt(childComplexity), true

	case "PanelResponse.panelID":
		if e.complexity.PanelResponse.PanelID == nil {
			break
		}

		return e.complexity.PanelResponse.PanelID(childComplexity), true

	case "PanelResponse.panelName":
		if e.complexity.PanelResponse.PanelName == nil {
			break
		}

		return e.complexity.PanelResponse.PanelName(childComplexity), true

	case "PanelResponse.panelOptions":
		if e.complexity.PanelResponse.PanelOptions == nil {
			break
		}

		return e.complexity.PanelResponse.PanelOptions(childComplexity), true

	case "PanelResponse.promQueries":
		if e.complexity.PanelResponse.PromQueries == nil {
			break
		}

		return e.complexity.PanelResponse.PromQueries(childComplexity), true

	case "PanelResponse.unit":
		if e.complexity.PanelResponse.Unit == nil {
			break
		}

		return e.complexity.PanelResponse.Unit(childComplexity), true

	case "PanelResponse.xAxisDown":
		if e.complexity.PanelResponse.XAxisDown == nil {
			break
		}

		return e.complexity.PanelResponse.XAxisDown(childComplexity), true

	case "PanelResponse.yAxisLeft":
		if e.complexity.PanelResponse.YAxisLeft == nil {
			break
		}

		return e.complexity.PanelResponse.YAxisLeft(childComplexity), true

	case "PanelResponse.yAxisRight":
		if e.complexity.PanelResponse.YAxisRight == nil {
			break
		}

		return e.complexity.PanelResponse.YAxisRight(childComplexity), true

	case "PodLogResponse.log":
		if e.complexity.PodLogResponse.Log == nil {
			break
		}

		return e.complexity.PodLogResponse.Log(childComplexity), true

	case "PodLogResponse.podName":
		if e.complexity.PodLogResponse.PodName == nil {
			break
		}

		return e.complexity.PodLogResponse.PodName(childComplexity), true

	case "PodLogResponse.podType":
		if e.complexity.PodLogResponse.PodType == nil {
			break
		}

		return e.complexity.PodLogResponse.PodType(childComplexity), true

	case "PodLogResponse.workflowRunID":
		if e.complexity.PodLogResponse.WorkflowRunID == nil {
			break
		}

		return e.complexity.PodLogResponse.WorkflowRunID(childComplexity), true

	case "PortalDashboardDataResponse.dashboardData":
		if e.complexity.PortalDashboardDataResponse.DashboardData == nil {
			break
		}

		return e.complexity.PortalDashboardDataResponse.DashboardData(childComplexity), true

	case "PortalDashboardDataResponse.name":
		if e.complexity.PortalDashboardDataResponse.Name == nil {
			break
		}

		return e.complexity.PortalDashboardDataResponse.Name(childComplexity), true

	case "PredefinedWorkflowList.workflowCSV":
		if e.complexity.PredefinedWorkflowList.WorkflowCsv == nil {
			break
		}

		return e.complexity.PredefinedWorkflowList.WorkflowCsv(childComplexity), true

	case "PredefinedWorkflowList.workflowManifest":
		if e.complexity.PredefinedWorkflowList.WorkflowManifest == nil {
			break
		}

		return e.complexity.PredefinedWorkflowList.WorkflowManifest(childComplexity), true

	case "PredefinedWorkflowList.workflowName":
		if e.complexity.PredefinedWorkflowList.WorkflowName == nil {
			break
		}

		return e.complexity.PredefinedWorkflowList.WorkflowName(childComplexity), true

	case "ProjectData.agents":
		if e.complexity.ProjectData.Agents == nil {
			break
		}

		return e.complexity.ProjectData.Agents(childComplexity), true

	case "ProjectData.projectID":
		if e.complexity.ProjectData.ProjectID == nil {
			break
		}

		return e.complexity.ProjectData.ProjectID(childComplexity), true

	case "ProjectData.workflows":
		if e.complexity.ProjectData.Workflows == nil {
			break
		}

		return e.complexity.ProjectData.Workflows(childComplexity), true

	case "PromQueryResponse.closeArea":
		if e.complexity.PromQueryResponse.CloseArea == nil {
			break
		}

		return e.complexity.PromQueryResponse.CloseArea(childComplexity), true

	case "PromQueryResponse.legend":
		if e.complexity.PromQueryResponse.Legend == nil {
			break
		}

		return e.complexity.PromQueryResponse.Legend(childComplexity), true

	case "PromQueryResponse.line":
		if e.complexity.PromQueryResponse.Line == nil {
			break
		}

		return e.complexity.PromQueryResponse.Line(childComplexity), true

	case "PromQueryResponse.minstep":
		if e.complexity.PromQueryResponse.Minstep == nil {
			break
		}

		return e.complexity.PromQueryResponse.Minstep(childComplexity), true

	case "PromQueryResponse.promQueryName":
		if e.complexity.PromQueryResponse.PromQueryName == nil {
			break
		}

		return e.complexity.PromQueryResponse.PromQueryName(childComplexity), true

	case "PromQueryResponse.queryID":
		if e.complexity.PromQueryResponse.QueryID == nil {
			break
		}

		return e.complexity.PromQueryResponse.QueryID(childComplexity), true

	case "PromQueryResponse.resolution":
		if e.complexity.PromQueryResponse.Resolution == nil {
			break
		}

		return e.complexity.PromQueryResponse.Resolution(childComplexity), true

	case "PromSeriesListResponse.seriesList":
		if e.complexity.PromSeriesListResponse.SeriesList == nil {
			break
		}

		return e.complexity.PromSeriesListResponse.SeriesList(childComplexity), true

	case "PromSeriesResponse.labelValues":
		if e.complexity.PromSeriesResponse.LabelValues == nil {
			break
		}

		return e.complexity.PromSeriesResponse.LabelValues(childComplexity), true

	case "PromSeriesResponse.series":
		if e.complexity.PromSeriesResponse.Series == nil {
			break
		}

		return e.complexity.PromSeriesResponse.Series(childComplexity), true

	case "PrometheusDataResponse.annotationsResponse":
		if e.complexity.PrometheusDataResponse.AnnotationsResponse == nil {
			break
		}

		return e.complexity.PrometheusDataResponse.AnnotationsResponse(childComplexity), true

	case "PrometheusDataResponse.metricsResponse":
		if e.complexity.PrometheusDataResponse.MetricsResponse == nil {
			break
		}

		return e.complexity.PrometheusDataResponse.MetricsResponse(childComplexity), true

	case "Provider.name":
		if e.complexity.Provider.Name == nil {
			break
		}

		return e.complexity.Provider.Name(childComplexity), true

	case "Query.getAgentDetails":
		if e.complexity.Query.GetAgentDetails == nil {
			break
		}

		args, err := ec.field_Query_getAgentDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAgentDetails(childComplexity, args["clusterID"].(string), args["projectID"].(string)), true

	case "Query.getExperimentDetails":
		if e.complexity.Query.GetExperimentDetails == nil {
			break
		}

		args, err := ec.field_Query_getExperimentDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentDetails(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.getGitOpsDetails":
		if e.complexity.Query.GetGitOpsDetails == nil {
			break
		}

		args, err := ec.field_Query_getGitOpsDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGitOpsDetails(childComplexity, args["projectID"].(string)), true

	case "Query.getHubExperiment":
		if e.complexity.Query.GetHubExperiment == nil {
			break
		}

		args, err := ec.field_Query_getHubExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetHubExperiment(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.getImageRegistry":
		if e.complexity.Query.GetImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_getImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Query.getManifest":
		if e.complexity.Query.GetManifest == nil {
			break
		}

		args, err := ec.field_Query_getManifest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetManifest(childComplexity, args["projectID"].(string), args["clusterID"].(string), args["accessKey"].(string)), true

	case "Query.getPredefinedExperimentYAML":
		if e.complexity.Query.GetPredefinedExperimentYaml == nil {
			break
		}

		args, err := ec.field_Query_getPredefinedExperimentYAML_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPredefinedExperimentYaml(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.getPromLabelNamesAndValues":
		if e.complexity.Query.GetPromLabelNamesAndValues == nil {
			break
		}

		args, err := ec.field_Query_getPromLabelNamesAndValues_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPromLabelNamesAndValues(childComplexity, args["request"].(*model.PromSeriesInput)), true

	case "Query.getPromSeriesList":
		if e.complexity.Query.GetPromSeriesList == nil {
			break
		}

		args, err := ec.field_Query_getPromSeriesList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPromSeriesList(childComplexity, args["request"].(*model.DsDetails)), true

	case "Query.getPrometheusData":
		if e.complexity.Query.GetPrometheusData == nil {
			break
		}

		args, err := ec.field_Query_getPrometheusData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPrometheusData(childComplexity, args["request"].(*model.PrometheusDataRequest)), true

	case "Query.getServerVersion":
		if e.complexity.Query.GetServerVersion == nil {
			break
		}

		return e.complexity.Query.GetServerVersion(childComplexity), true

	case "Query.getUsageData":
		if e.complexity.Query.GetUsageData == nil {
			break
		}

		args, err := ec.field_Query_getUsageData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUsageData(childComplexity, args["request"].(model.UsageDataRequest)), true

	case "Query.getWorkflowManifestByID":
		if e.complexity.Query.GetWorkflowManifestByID == nil {
			break
		}

		args, err := ec.field_Query_getWorkflowManifestByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetWorkflowManifestByID(childComplexity, args["projectID"].(string), args["templateID"].(string)), true

	case "Query.getWorkflowRunStats":
		if e.complexity.Query.GetWorkflowRunStats == nil {
			break
		}

		args, err := ec.field_Query_getWorkflowRunStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetWorkflowRunStats(childComplexity, args["workflowRunStatsRequest"].(model.WorkflowRunStatsRequest)), true

	case "Query.getYAMLData":
		if e.complexity.Query.GetYAMLData == nil {
			break
		}

		args, err := ec.field_Query_getYAMLData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetYAMLData(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.listCharts":
		if e.complexity.Query.ListCharts == nil {
			break
		}

		args, err := ec.field_Query_listCharts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListCharts(childComplexity, args["hubName"].(string), args["projectID"].(string)), true

	case "Query.listClusters":
		if e.complexity.Query.ListClusters == nil {
			break
		}

		args, err := ec.field_Query_listClusters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListClusters(childComplexity, args["projectID"].(string), args["clusterType"].(*string)), true

	case "Query.listDashboard":
		if e.complexity.Query.ListDashboard == nil {
			break
		}

		args, err := ec.field_Query_listDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListDashboard(childComplexity, args["projectID"].(string), args["clusterID"].(*string), args["dbID"].(*string)), true

	case "Query.listDataSource":
		if e.complexity.Query.ListDataSource == nil {
			break
		}

		args, err := ec.field_Query_listDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListDataSource(childComplexity, args["projectID"].(string)), true

	case "Query.listHeatmapData":
		if e.complexity.Query.ListHeatmapData == nil {
			break
		}

		args, err := ec.field_Query_listHeatmapData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListHeatmapData(childComplexity, args["projectID"].(string), args["workflowID"].(string), args["year"].(int)), true

	case "Query.listHubStatus":
		if e.complexity.Query.ListHubStatus == nil {
			break
		}

		args, err := ec.field_Query_listHubStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListHubStatus(childComplexity, args["projectID"].(string)), true

	case "Query.listImageRegistry":
		if e.complexity.Query.ListImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_listImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListImageRegistry(childComplexity, args["projectID"].(string)), true

	case "Query.listPortalDashboardData":
		if e.complexity.Query.ListPortalDashboardData == nil {
			break
		}

		args, err := ec.field_Query_listPortalDashboardData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPortalDashboardData(childComplexity, args["projectID"].(string), args["hubName"].(string)), true

	case "Query.listPredefinedWorkflows":
		if e.complexity.Query.ListPredefinedWorkflows == nil {
			break
		}

		args, err := ec.field_Query_listPredefinedWorkflows_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPredefinedWorkflows(childComplexity, args["hubName"].(string), args["projectID"].(string)), true

	case "Query.listWorkflowManifests":
		if e.complexity.Query.ListWorkflowManifests == nil {
			break
		}

		args, err := ec.field_Query_listWorkflowManifests_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflowManifests(childComplexity, args["projectID"].(string)), true

	case "Query.listWorkflowRuns":
		if e.complexity.Query.ListWorkflowRuns == nil {
			break
		}

		args, err := ec.field_Query_listWorkflowRuns_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflowRuns(childComplexity, args["request"].(model.ListWorkflowRunsRequest)), true

	case "Query.listWorkflowStats":
		if e.complexity.Query.ListWorkflowStats == nil {
			break
		}

		args, err := ec.field_Query_listWorkflowStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflowStats(childComplexity, args["projectID"].(string), args["filter"].(model.TimeFrequency), args["showWorkflowRuns"].(bool)), true

	case "Query.listWorkflows":
		if e.complexity.Query.ListWorkflows == nil {
			break
		}

		args, err := ec.field_Query_listWorkflows_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflows(childComplexity, args["request"].(model.ListWorkflowsRequest)), true

	case "RegisterClusterResponse.clusterID":
		if e.complexity.RegisterClusterResponse.ClusterID == nil {
			break
		}

		return e.complexity.RegisterClusterResponse.ClusterID(childComplexity), true

	case "RegisterClusterResponse.clusterName":
		if e.complexity.RegisterClusterResponse.ClusterName == nil {
			break
		}

		return e.complexity.RegisterClusterResponse.ClusterName(childComplexity), true

	case "RegisterClusterResponse.token":
		if e.complexity.RegisterClusterResponse.Token == nil {
			break
		}

		return e.complexity.RegisterClusterResponse.Token(childComplexity), true

	case "ResourceResponse.kind":
		if e.complexity.ResourceResponse.Kind == nil {
			break
		}

		return e.complexity.ResourceResponse.Kind(childComplexity), true

	case "ResourceResponse.names":
		if e.complexity.ResourceResponse.Names == nil {
			break
		}

		return e.complexity.ResourceResponse.Names(childComplexity), true

	case "SSHKey.privateKey":
		if e.complexity.SSHKey.PrivateKey == nil {
			break
		}

		return e.complexity.SSHKey.PrivateKey(childComplexity), true

	case "SSHKey.publicKey":
		if e.complexity.SSHKey.PublicKey == nil {
			break
		}

		return e.complexity.SSHKey.PublicKey(childComplexity), true

	case "ServerVersionResponse.key":
		if e.complexity.ServerVersionResponse.Key == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Key(childComplexity), true

	case "ServerVersionResponse.value":
		if e.complexity.ServerVersionResponse.Value == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Value(childComplexity), true

	case "Spec.categoryDescription":
		if e.complexity.Spec.CategoryDescription == nil {
			break
		}

		return e.complexity.Spec.CategoryDescription(childComplexity), true

	case "Spec.chaosExpCRDLink":
		if e.complexity.Spec.ChaosExpCRDLink == nil {
			break
		}

		return e.complexity.Spec.ChaosExpCRDLink(childComplexity), true

	case "Spec.chaosType":
		if e.complexity.Spec.ChaosType == nil {
			break
		}

		return e.complexity.Spec.ChaosType(childComplexity), true

	case "Spec.displayName":
		if e.complexity.Spec.DisplayName == nil {
			break
		}

		return e.complexity.Spec.DisplayName(childComplexity), true

	case "Spec.experiments":
		if e.complexity.Spec.Experiments == nil {
			break
		}

		return e.complexity.Spec.Experiments(childComplexity), true

	case "Spec.keywords":
		if e.complexity.Spec.Keywords == nil {
			break
		}

		return e.complexity.Spec.Keywords(childComplexity), true

	case "Spec.links":
		if e.complexity.Spec.Links == nil {
			break
		}

		return e.complexity.Spec.Links(childComplexity), true

	case "Spec.maintainers":
		if e.complexity.Spec.Maintainers == nil {
			break
		}

		return e.complexity.Spec.Maintainers(childComplexity), true

	case "Spec.maturity":
		if e.complexity.Spec.Maturity == nil {
			break
		}

		return e.complexity.Spec.Maturity(childComplexity), true

	case "Spec.minKubeVersion":
		if e.complexity.Spec.MinKubeVersion == nil {
			break
		}

		return e.complexity.Spec.MinKubeVersion(childComplexity), true

	case "Spec.platforms":
		if e.complexity.Spec.Platforms == nil {
			break
		}

		return e.complexity.Spec.Platforms(childComplexity), true

	case "Spec.provider":
		if e.complexity.Spec.Provider == nil {
			break
		}

		return e.complexity.Spec.Provider(childComplexity), true

	case "SubData.date":
		if e.complexity.SubData.Date == nil {
			break
		}

		return e.complexity.SubData.Date(childComplexity), true

	case "SubData.subDataName":
		if e.complexity.SubData.SubDataName == nil {
			break
		}

		return e.complexity.SubData.SubDataName(childComplexity), true

	case "SubData.value":
		if e.complexity.SubData.Value == nil {
			break
		}

		return e.complexity.SubData.Value(childComplexity), true

	case "Subscription.clusterConnect":
		if e.complexity.Subscription.ClusterConnect == nil {
			break
		}

		args, err := ec.field_Subscription_clusterConnect_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ClusterConnect(childComplexity, args["clusterInfo"].(model.ClusterIdentity)), true

	case "Subscription.getClusterEvents":
		if e.complexity.Subscription.GetClusterEvents == nil {
			break
		}

		args, err := ec.field_Subscription_getClusterEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetClusterEvents(childComplexity, args["projectID"].(string)), true

	case "Subscription.getKubeObject":
		if e.complexity.Subscription.GetKubeObject == nil {
			break
		}

		args, err := ec.field_Subscription_getKubeObject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetKubeObject(childComplexity, args["request"].(model.KubeObjectRequest)), true

	case "Subscription.getPodLog":
		if e.complexity.Subscription.GetPodLog == nil {
			break
		}

		args, err := ec.field_Subscription_getPodLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetPodLog(childComplexity, args["request"].(model.PodLogRequest)), true

	case "Subscription.getWorkflowEvents":
		if e.complexity.Subscription.GetWorkflowEvents == nil {
			break
		}

		args, err := ec.field_Subscription_getWorkflowEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetWorkflowEvents(childComplexity, args["projectID"].(string)), true

	case "Subscription.viewDashboard":
		if e.complexity.Subscription.ViewDashboard == nil {
			break
		}

		args, err := ec.field_Subscription_viewDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ViewDashboard(childComplexity, args["dashboardID"].(*string), args["promQueries"].([]*model.PromQueryInput), args["dashboardQueryMap"].([]*model.QueryMapForPanelGroup), args["dataVariables"].(model.DataVars)), true

	case "TotalCount.agents":
		if e.complexity.TotalCount.Agents == nil {
			break
		}

		return e.complexity.TotalCount.Agents(childComplexity), true

	case "TotalCount.projects":
		if e.complexity.TotalCount.Projects == nil {
			break
		}

		return e.complexity.TotalCount.Projects(childComplexity), true

	case "TotalCount.users":
		if e.complexity.TotalCount.Users == nil {
			break
		}

		return e.complexity.TotalCount.Users(childComplexity), true

	case "TotalCount.workflows":
		if e.complexity.TotalCount.Workflows == nil {
			break
		}

		return e.complexity.TotalCount.Workflows(childComplexity), true

	case "UsageDataResponse.projects":
		if e.complexity.UsageDataResponse.Projects == nil {
			break
		}

		return e.complexity.UsageDataResponse.Projects(childComplexity), true

	case "UsageDataResponse.totalCount":
		if e.complexity.UsageDataResponse.TotalCount == nil {
			break
		}

		return e.complexity.UsageDataResponse.TotalCount(childComplexity), true

	case "UsageDataResponse.totalEntries":
		if e.complexity.UsageDataResponse.TotalEntries == nil {
			break
		}

		return e.complexity.UsageDataResponse.TotalEntries(childComplexity), true

	case "Weightages.experimentName":
		if e.complexity.Weightages.ExperimentName == nil {
			break
		}

		return e.complexity.Weightages.ExperimentName(childComplexity), true

	case "Weightages.weightage":
		if e.complexity.Weightages.Weightage == nil {
			break
		}

		return e.complexity.Weightages.Weightage(childComplexity), true

	case "Workflow.clusterID":
		if e.complexity.Workflow.ClusterID == nil {
			break
		}

		return e.complexity.Workflow.ClusterID(childComplexity), true

	case "Workflow.clusterName":
		if e.complexity.Workflow.ClusterName == nil {
			break
		}

		return e.complexity.Workflow.ClusterName(childComplexity), true

	case "Workflow.clusterType":
		if e.complexity.Workflow.ClusterType == nil {
			break
		}

		return e.complexity.Workflow.ClusterType(childComplexity), true

	case "Workflow.createdAt":
		if e.complexity.Workflow.CreatedAt == nil {
			break
		}

		return e.complexity.Workflow.CreatedAt(childComplexity), true

	case "Workflow.cronSyntax":
		if e.complexity.Workflow.CronSyntax == nil {
			break
		}

		return e.complexity.Workflow.CronSyntax(childComplexity), true

	case "Workflow.isCustomWorkflow":
		if e.complexity.Workflow.IsCustomWorkflow == nil {
			break
		}

		return e.complexity.Workflow.IsCustomWorkflow(childComplexity), true

	case "Workflow.isRemoved":
		if e.complexity.Workflow.IsRemoved == nil {
			break
		}

		return e.complexity.Workflow.IsRemoved(childComplexity), true

	case "Workflow.lastUpdatedBy":
		if e.complexity.Workflow.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Workflow.LastUpdatedBy(childComplexity), true

	case "Workflow.projectID":
		if e.complexity.Workflow.ProjectID == nil {
			break
		}

		return e.complexity.Workflow.ProjectID(childComplexity), true

	case "Workflow.updatedAt":
		if e.complexity.Workflow.UpdatedAt == nil {
			break
		}

		return e.complexity.Workflow.UpdatedAt(childComplexity), true

	case "Workflow.weightages":
		if e.complexity.Workflow.Weightages == nil {
			break
		}

		return e.complexity.Workflow.Weightages(childComplexity), true

	case "Workflow.workflowDescription":
		if e.complexity.Workflow.WorkflowDescription == nil {
			break
		}

		return e.complexity.Workflow.WorkflowDescription(childComplexity), true

	case "Workflow.workflowID":
		if e.complexity.Workflow.WorkflowID == nil {
			break
		}

		return e.complexity.Workflow.WorkflowID(childComplexity), true

	case "Workflow.workflowManifest":
		if e.complexity.Workflow.WorkflowManifest == nil {
			break
		}

		return e.complexity.Workflow.WorkflowManifest(childComplexity), true

	case "Workflow.workflowName":
		if e.complexity.Workflow.WorkflowName == nil {
			break
		}

		return e.complexity.Workflow.WorkflowName(childComplexity), true

	case "WorkflowRun.clusterID":
		if e.complexity.WorkflowRun.ClusterID == nil {
			break
		}

		return e.complexity.WorkflowRun.ClusterID(childComplexity), true

	case "WorkflowRun.clusterName":
		if e.complexity.WorkflowRun.ClusterName == nil {
			break
		}

		return e.complexity.WorkflowRun.ClusterName(childComplexity), true

	case "WorkflowRun.clusterType":
		if e.complexity.WorkflowRun.ClusterType == nil {
			break
		}

		return e.complexity.WorkflowRun.ClusterType(childComplexity), true

	case "WorkflowRun.executedBy":
		if e.complexity.WorkflowRun.ExecutedBy == nil {
			break
		}

		return e.complexity.WorkflowRun.ExecutedBy(childComplexity), true

	case "WorkflowRun.executionData":
		if e.complexity.WorkflowRun.ExecutionData == nil {
			break
		}

		return e.complexity.WorkflowRun.ExecutionData(childComplexity), true

	case "WorkflowRun.experimentsAwaited":
		if e.complexity.WorkflowRun.ExperimentsAwaited == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsAwaited(childComplexity), true

	case "WorkflowRun.experimentsFailed":
		if e.complexity.WorkflowRun.ExperimentsFailed == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsFailed(childComplexity), true

	case "WorkflowRun.experimentsNa":
		if e.complexity.WorkflowRun.ExperimentsNa == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsNa(childComplexity), true

	case "WorkflowRun.experimentsPassed":
		if e.complexity.WorkflowRun.ExperimentsPassed == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsPassed(childComplexity), true

	case "WorkflowRun.experimentsStopped":
		if e.complexity.WorkflowRun.ExperimentsStopped == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsStopped(childComplexity), true

	case "WorkflowRun.isRemoved":
		if e.complexity.WorkflowRun.IsRemoved == nil {
			break
		}

		return e.complexity.WorkflowRun.IsRemoved(childComplexity), true

	case "WorkflowRun.lastUpdated":
		if e.complexity.WorkflowRun.LastUpdated == nil {
			break
		}

		return e.complexity.WorkflowRun.LastUpdated(childComplexity), true

	case "WorkflowRun.phase":
		if e.complexity.WorkflowRun.Phase == nil {
			break
		}

		return e.complexity.WorkflowRun.Phase(childComplexity), true

	case "WorkflowRun.projectID":
		if e.complexity.WorkflowRun.ProjectID == nil {
			break
		}

		return e.complexity.WorkflowRun.ProjectID(childComplexity), true

	case "WorkflowRun.resiliencyScore":
		if e.complexity.WorkflowRun.ResiliencyScore == nil {
			break
		}

		return e.complexity.WorkflowRun.ResiliencyScore(childComplexity), true

	case "WorkflowRun.totalExperiments":
		if e.complexity.WorkflowRun.TotalExperiments == nil {
			break
		}

		return e.complexity.WorkflowRun.TotalExperiments(childComplexity), true

	case "WorkflowRun.weightages":
		if e.complexity.WorkflowRun.Weightages == nil {
			break
		}

		return e.complexity.WorkflowRun.Weightages(childComplexity), true

	case "WorkflowRun.workflowID":
		if e.complexity.WorkflowRun.WorkflowID == nil {
			break
		}

		return e.complexity.WorkflowRun.WorkflowID(childComplexity), true

	case "WorkflowRun.workflowName":
		if e.complexity.WorkflowRun.WorkflowName == nil {
			break
		}

		return e.complexity.WorkflowRun.WorkflowName(childComplexity), true

	case "WorkflowRun.workflowRunID":
		if e.complexity.WorkflowRun.WorkflowRunID == nil {
			break
		}

		return e.complexity.WorkflowRun.WorkflowRunID(childComplexity), true

	case "WorkflowRunDetails.dateStamp":
		if e.complexity.WorkflowRunDetails.DateStamp == nil {
			break
		}

		return e.complexity.WorkflowRunDetails.DateStamp(childComplexity), true

	case "WorkflowRunDetails.noOfRuns":
		if e.complexity.WorkflowRunDetails.NoOfRuns == nil {
			break
		}

		return e.complexity.WorkflowRunDetails.NoOfRuns(childComplexity), true

	case "WorkflowRunStatsResponse.averageResiliencyScore":
		if e.complexity.WorkflowRunStatsResponse.AverageResiliencyScore == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.AverageResiliencyScore(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsAwaited":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsAwaited == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsAwaited(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsFailed":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsFailed == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsFailed(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsNa":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsNa == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsNa(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsPassed":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsPassed == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsPassed(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsStopped":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsStopped == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsStopped(childComplexity), true

	case "WorkflowRunStatsResponse.failedPercentage":
		if e.complexity.WorkflowRunStatsResponse.FailedPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.FailedPercentage(childComplexity), true

	case "WorkflowRunStatsResponse.failedWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.FailedWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.FailedWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.passedPercentage":
		if e.complexity.WorkflowRunStatsResponse.PassedPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.PassedPercentage(childComplexity), true

	case "WorkflowRunStatsResponse.runningWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.RunningWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.RunningWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.succeededWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.SucceededWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.SucceededWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.totalExperiments":
		if e.complexity.WorkflowRunStatsResponse.TotalExperiments == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.TotalExperiments(childComplexity), true

	case "WorkflowRunStatsResponse.totalWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.TotalWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.TotalWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.workflowRunFailedPercentage":
		if e.complexity.WorkflowRunStatsResponse.WorkflowRunFailedPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.WorkflowRunFailedPercentage(childComplexity), true

	case "WorkflowRunStatsResponse.workflowRunSucceededPercentage":
		if e.complexity.WorkflowRunStatsResponse.WorkflowRunSucceededPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.WorkflowRunSucceededPercentage(childComplexity), true

	case "WorkflowRunsData.value":
		if e.complexity.WorkflowRunsData.Value == nil {
			break
		}

		return e.complexity.WorkflowRunsData.Value(childComplexity), true

	case "WorkflowRunsData.workflowRunDetail":
		if e.complexity.WorkflowRunsData.WorkflowRunDetail == nil {
			break
		}

		return e.complexity.WorkflowRunsData.WorkflowRunDetail(childComplexity), true

	case "WorkflowStat.expRuns":
		if e.complexity.WorkflowStat.ExpRuns == nil {
			break
		}

		return e.complexity.WorkflowStat.ExpRuns(childComplexity), true

	case "WorkflowStat.runs":
		if e.complexity.WorkflowStat.Runs == nil {
			break
		}

		return e.complexity.WorkflowStat.Runs(childComplexity), true

	case "WorkflowStat.schedules":
		if e.complexity.WorkflowStat.Schedules == nil {
			break
		}

		return e.complexity.WorkflowStat.Schedules(childComplexity), true

	case "WorkflowStatsResponse.date":
		if e.complexity.WorkflowStatsResponse.Date == nil {
			break
		}

		return e.complexity.WorkflowStatsResponse.Date(childComplexity), true

	case "WorkflowStatsResponse.value":
		if e.complexity.WorkflowStatsResponse.Value == nil {
			break
		}

		return e.complexity.WorkflowStatsResponse.Value(childComplexity), true

	case "WorkflowTemplate.createdAt":
		if e.complexity.WorkflowTemplate.CreatedAt == nil {
			break
		}

		return e.complexity.WorkflowTemplate.CreatedAt(childComplexity), true

	case "WorkflowTemplate.isCustomWorkflow":
		if e.complexity.WorkflowTemplate.IsCustomWorkflow == nil {
			break
		}

		return e.complexity.WorkflowTemplate.IsCustomWorkflow(childComplexity), true

	case "WorkflowTemplate.isRemoved":
		if e.complexity.WorkflowTemplate.IsRemoved == nil {
			break
		}

		return e.complexity.WorkflowTemplate.IsRemoved(childComplexity), true

	case "WorkflowTemplate.manifest":
		if e.complexity.WorkflowTemplate.Manifest == nil {
			break
		}

		return e.complexity.WorkflowTemplate.Manifest(childComplexity), true

	case "WorkflowTemplate.projectID":
		if e.complexity.WorkflowTemplate.ProjectID == nil {
			break
		}

		return e.complexity.WorkflowTemplate.ProjectID(childComplexity), true

	case "WorkflowTemplate.projectName":
		if e.complexity.WorkflowTemplate.ProjectName == nil {
			break
		}

		return e.complexity.WorkflowTemplate.ProjectName(childComplexity), true

	case "WorkflowTemplate.templateDescription":
		if e.complexity.WorkflowTemplate.TemplateDescription == nil {
			break
		}

		return e.complexity.WorkflowTemplate.TemplateDescription(childComplexity), true

	case "WorkflowTemplate.templateID":
		if e.complexity.WorkflowTemplate.TemplateID == nil {
			break
		}

		return e.complexity.WorkflowTemplate.TemplateID(childComplexity), true

	case "WorkflowTemplate.templateName":
		if e.complexity.WorkflowTemplate.TemplateName == nil {
			break
		}

		return e.complexity.WorkflowTemplate.TemplateName(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "graph/analytics.graphqls", Input: `input DSInput {
  dsID: String
  dsName: String!
  dsType: String!
  dsURL: String!
  accessType: String!
  authType: String!
  basicAuthUsername: String
  basicAuthPassword: String
  scrapeInterval: Int!
  queryTimeout: Int!
  httpMethod: String!
  projectID: String
}

type DSResponse {
  dsID: String
  dsName: String
  dsType: String
  dsURL: String
  accessType: String
  authType: String
  basicAuthUsername: String
  basicAuthPassword: String
  scrapeInterval: Int
  queryTimeout: Int
  httpMethod: String
  projectID: ID!
  healthStatus: String!
  createdAt: String
  updatedAt: String
}

input CreateDBInput {
  dsID: String!
  dbName: String!
  dbTypeName: String!
  dbTypeID: String!
  dbInformation: String
  chaosEventQueryTemplate: String!
  chaosVerdictQueryTemplate: String!
  applicationMetadataMap: [ApplicationMetadata]
  panelGroups: [PanelGroup]!
  endTime: String!
  startTime: String!
  projectID: ID!
  clusterID: ID!
  refreshRate: String!
}

input ApplicationMetadata {
  namespace: String!
  applications: [Resource]
}

input Resource {
  kind: String!
  names: [String]
}

input UpdateDBInput {
  dbID: String!
  dsID: String
  dbName: String
  dbTypeName: String
  dbTypeID: String
  dbInformation: String
  chaosEventQueryTemplate: String
  chaosVerdictQueryTemplate: String
  applicationMetadataMap: [ApplicationMetadata]
  panelGroups: [UpdatePanelGroupInput]
  endTime: String
  startTime: String
  clusterID: ID
  refreshRate: String
}

input UpdatePanelGroupInput {
  panelGroupName: String!
  panelGroupID: String!
  panels: [Panel]
}

input PanelGroup {
  panels: [Panel]
  panelGroupName: String!
}

input Panel {
  panelID: String
  dbID: String
  yAxisLeft: String
  yAxisRight: String
  xAxisDown: String
  unit: String
  panelGroupID: String
  createdAt: String
  promQueries: [PromQuery]
  panelOptions: PanelOption
  panelName: String!
}

input PanelOption {
  points: Boolean
  grIDs: Boolean
  leftAxis: Boolean
}

input PromQuery {
  queryID: String!
  promQueryName: String
  legend: String
  resolution: String
  minstep: String
  line: Boolean
  closeArea: Boolean
}

input PrometheusDataRequest {
  queries: [PromQueryInput]
  dsDetails: DsDetails!
}

input PromSeriesInput {
  series: String!
  dsDetails: DsDetails!
}

input DsDetails {
  url: String!
  start: String!
  end: String!
}

input PromQueryInput {
  queryID: String!
  query: String!
  legend: String
  resolution: String
  minstep: Int!
}

input QueryMapForPanel {
  panelID: String!
  queryIDs: [String!]!
}

input QueryMapForPanelGroup {
  panelGroupID: String!
  panelQueryMap: [QueryMapForPanel!]!
}

input DataVars {
  url: String!
  start: String!
  end: String!
  relativeTime: Int!
  refreshInterval: Int!
}

type MetricsPromResponse {
  queryID: String!
  legends: [String]
  tsvs: [[MetricsTimeStampValue]]
}

type MetricsTimeStampValue {
  date: Float
  value: Float
}

type SubData {
  date: Float
  value: String!
  subDataName: String!
}

type AnnotationsPromResponse {
  queryID: String!
  legends: [String]
  tsvs: [[AnnotationsTimeStampValue]]
  subDataArray: [[SubData]]
}

type AnnotationsTimeStampValue {
  date: Float
  value: Int
}

type PrometheusDataResponse {
  metricsResponse: [MetricsPromResponse]
  annotationsResponse: [AnnotationsPromResponse]
}

type MetricDataForPanel {
  panelID: String!
  panelMetricsResponse: [MetricsPromResponse]
}

type MetricDataForPanelGroup {
  panelGroupID: String!
  panelGroupMetricsResponse: [MetricDataForPanel]
}

type DashboardPromResponse {
  dashboardMetricsResponse: [MetricDataForPanelGroup]
  annotationsResponse: [AnnotationsPromResponse]
}

type PromSeriesResponse {
  series: String!
  labelValues: [LabelValue]
}

type PromSeriesListResponse {
  seriesList: [String]
}

type LabelValue {
  label: String!
  values: [Option]
}

type Option {
  name: String!
}

type ListDashboardResponse {
  dsID: String!
  dbID: String!
  dbName: String!
  dbTypeID: String!
  dbTypeName: String!
  dbInformation: String
  chaosEventQueryTemplate: String!
  chaosVerdictQueryTemplate: String!
  applicationMetadataMap: [ApplicationMetadataResponse]
  clusterName: String
  dsName: String
  dsType: String
  dsURL: String
  dsHealthStatus: String
  panelGroups: [PanelGroupResponse]!
  endTime: String!
  startTime: String!
  refreshRate: String!
  projectID: ID!
  clusterID: ID!
  createdAt: String
  updatedAt: String
  viewedAt: String
}

type ApplicationMetadataResponse {
  namespace: String!
  applications: [ResourceResponse]
}

type ResourceResponse {
  kind: String!
  names: [String]
}

type PanelGroupResponse {
  panels: [PanelResponse]
  panelGroupName: String!
  panelGroupID: String
}

type PanelResponse {
  panelID: String!
  yAxisLeft: String
  yAxisRight: String
  xAxisDown: String
  unit: String
  promQueries: [PromQueryResponse]
  panelOptions: PanelOptionResponse
  panelName: String
  createdAt: String
}

type PanelOptionResponse {
  points: Boolean
  grIDs: Boolean
  leftAxis: Boolean
}

type PromQueryResponse {
  queryID: ID!
  promQueryName: String
  legend: String
  resolution: String
  minstep: String
  line: Boolean
  closeArea: Boolean
}

input DeleteDSInput {
  forceDelete: Boolean!
  dsID: ID!
}

enum TimeFrequency {
  DAILY
  HOURLY
  MONTHLY
}

type WorkflowStatsResponse {
  date: Float!
  value: Int!
}

type WorkflowRunDetails {
  noOfRuns: Int!
  dateStamp: Float!
}

type WorkflowRunsData {
  value: Float
  workflowRunDetail: WorkflowRunDetails
}

type HeatmapDataResponse {
  bins: [WorkflowRunsData]!
}

input WorkflowRunStatsRequest {
  projectID: ID!
  workflowIDs: [ID]
}

type WorkflowRunStatsResponse {
  totalWorkflowRuns: Int!
  succeededWorkflowRuns: Int!
  failedWorkflowRuns: Int!
  runningWorkflowRuns: Int!
  averageResiliencyScore: Float!
  totalExperiments: Int!
  experimentsPassed: Int!
  experimentsFailed: Int!
  experimentsAwaited: Int!
  experimentsStopped: Int!
  experimentsNa: Int!
  passedPercentage: Float!
  failedPercentage: Float!
  workflowRunSucceededPercentage: Float!
  workflowRunFailedPercentage: Float!
}

type PortalDashboardDataResponse {
  name: String!
  dashboardData: String!
}


extend type Mutation {
  # ANALYTICS OPERATIONS
  """
  Creates a new datasource
  """
  createDataSource(datasource: DSInput): DSResponse @authorized

  """
  Creates a new analytics dashboard
  """
  createDashBoard(dashboard: CreateDBInput): ListDashboardResponse! @authorized

  """
  Updates a datasource
  """
  updateDataSource(datasource: DSInput!): DSResponse! @authorized

  """
  Updates a dashboard
  """
  updateDashboard(
    projectID: String!
    dashboard: UpdateDBInput!
    chaosQueryUpdate: Boolean!
  ): String! @authorized

  """
  Updates a dashboard panel
  """
  updatePanel(panelInput: [Panel]): String! @authorized

  """
  Deletes a dashboard
  """
  deleteDashboard(projectID: String!, dbID: String): Boolean! @authorized

  """
  Deletes a datasource
  """
  deleteDataSource(projectID: String!, input: DeleteDSInput!): Boolean!
  @authorized
}

extend type Query {
  # ANALYTICS OPERATIONS
  """
  Returns the workflow run data for a particular workflow in heatmap bins format
  """
  listHeatmapData(
    projectID: String!
    workflowID: String!
    year: Int!
  ): [HeatmapDataResponse]! @authorized

  """
  Returns the workflow and runs data divided in time frequency (hourly/daily/monthly)
  """
  listWorkflowStats(
    projectID: ID!
    filter: TimeFrequency!
    showWorkflowRuns: Boolean!
  ): [WorkflowStatsResponse]! @authorized

  """
  Returns metadata for multiple workflowIDs
  """
  getWorkflowRunStats(
    workflowRunStatsRequest: WorkflowRunStatsRequest!
  ): WorkflowRunStatsResponse! @authorized

  """
  Returns all the data sources for the projectID
  """
  listDataSource(projectID: String!): [DSResponse]! @authorized

  """
  Takes prometheus queries and returns response for annotations and metrics with a query map
  """
  getPrometheusData(request: PrometheusDataRequest): PrometheusDataResponse!
  @authorized

  """
  Return the prometheus labels and values for a given input
  """
  getPromLabelNamesAndValues(request: PromSeriesInput): PromSeriesResponse!
  @authorized

  """
  Return a list of all the prometheus series
  """
  getPromSeriesList(request: DsDetails): PromSeriesListResponse! @authorized

  """
  Returns a list of all the dashboards given an input
  """
  listDashboard(
    projectID: String!
    clusterID: String
    dbID: String
  ): [ListDashboardResponse] @authorized

  """
  Returns the portal dashboard data from the ChaosHub
  """
  listPortalDashboardData(
    projectID: String!
    hubName: String!
  ): [PortalDashboardDataResponse!]! @authorized
}

extend type Subscription {
  # ANALYTICS OPERATIONS
  """
  Takes a dashboard view id, prometheus queries, dashboard query map
  and data variables to query prometheus and send data periodically to the subscribed client
  """
  viewDashboard(
    dashboardID: String
    promQueries: [PromQueryInput!]!
    dashboardQueryMap: [QueryMapForPanelGroup!]!
    dataVariables: DataVars!
  ): DashboardPromResponse! @authorized
}
`, BuiltIn: false},
	&ast.Source{Name: "graph/cluster.graphqls", Input: `"""
Defines the details for a cluster
"""
type Cluster {
    """
    ID of the cluster
    """
    clusterID: ID!
    """
    Project ID the cluster is being connected to
    """
    projectID: ID!
    """
    Name of the cluster
    """
    clusterName: String!
    """
    Description of the cluster
    """
    description: String
    """
    Cluster Platform Name eg. GKE,AWS, Others
    """
    platformName: String!

    accessKey: String!
    """
    Bool value indicating if the cluster agent is registered or not
    """
    isRegistered: Boolean!
    """
    Bool value indicating if the cluster agent is confirmed or not
    """
    isClusterConfirmed: Boolean!
    """
    Bool value indicating if the cluster agent is active or not
    """
    isActive: Boolean!
    """
    Timestamp when the cluster agent was last updated
    """
    updatedAt: String!
    """
    Timestamp when the cluster agent was created
    """
    createdAt: String!
    """
    Cluster type : Internal or External
    """
    clusterType: String!
    """
    Number of schedules created in the cluster agent
    """
    noOfSchedules: Int
    """
    Number of workflows run in the cluster agent
    """
    noOfWorkflows: Int
    """
    Token used to verify and retrieve the cluster agent manifest
    """
    token: String!
    """
    Namespace where the cluster agent is being installed
    """
    agentNamespace: String
    """
    Name of service account used by cluster agent
    """
    serviceAccount: String
    """
    Scope of the cluster agent : ns or cluster
    """
    agentScope: String!
    """
    Bool value indicating whether agent ns used already exists on cluster or not
    """
    agentNsExists: Boolean
    """
    Bool value indicating whether service account used already exists on cluster or not
    """
    agentSaExists: Boolean
    """
    Timestamp of the last workflow run in the cluster agent
    """
    lastWorkflowTimestamp: String!
    """
    Timestamp when the cluster agent got connected
    """
    startTime: String!
    """
    Version of the cluster agent
    """
    version: String!
}

"""
Defines the details for the new cluster being connected
"""
input RegisterClusterRequest {
    """
    Name of the cluster
    """
    clusterName: String!
    """
    Description of the cluster
    """
    description: String
    """
    Cluster Platform Name eg. GKE,AWS, Others
    """
    platformName: String!
    """
    Project ID the cluster is being connected to
    """
    projectID: ID!
    """
    Cluster type : Internal or External
    """
    clusterType: String!
    """
    Namespace where the cluster agent is being installed
    """
    agentNamespace: String
    """
    Name of service account used by cluster agent
    """
    serviceAccount: String
    """
    Scope of the cluster agent : ns or cluster
    """
    agentScope: String!
    """
    Bool value indicating whether agent ns used already exists on cluster or not
    """
    agentNsExists: Boolean
    """
    Bool value indicating whether service account used already exists on cluster or not
    """
    agentSaExists: Boolean
    """
    Bool value indicating whether agent will skip ssl checks or not
    """
    skipSsl: Boolean
    """
    Node selectors used by cluster agent
    """
    nodeSelector: String
    """
    Node tolerations used by cluster agent
    """
    tolerations: [Toleration]
}

input Toleration {
    tolerationSeconds: Int
    key: String
    operator: String
    effect: String
    value: String
}

type ClusterEventResponse {
    eventID: ID!
    eventType: String!
    eventName: String!
    description: String!
    cluster: Cluster!
}

type ActionPayload {
    requestType: String!
    k8sManifest: String!
    namespace: String!
    externalData: String
    username: String
}

type ClusterActionResponse {
    projectID: ID!
    action: ActionPayload!
}

input NewClusterEventRequest {
    eventName: String!
    description: String!
    clusterID: String!
    accessKey: String!
}

input ClusterIdentity {
    clusterID: String!
    accessKey: String!
    version: String!
}

type ConfirmClusterRegistrationResponse {
    isClusterConfirmed: Boolean!
    newAccessKey: String
    clusterID: String
}

"""
Response received for registering a new cluster
"""
type RegisterClusterResponse {

    """
    Token used to verify and retrieve the cluster agent manifest
    """
    token: String!
    """
    Unique ID for the newly registered cluster
    """
    clusterID: String!
    """
    Cluster name as sent in request
    """
    clusterName: String!
}

type ServerVersionResponse {
    key: String!
    value: String!
}

extend type Query {
    """
    Returns version of gql server
    """
    getServerVersion: ServerVersionResponse!
    # CLUSTER OPERATIONS
    """
    Returns clusters with a particular cluster type in the project
    """
    listClusters(projectID: String!, clusterType: String): [Cluster!]! @authorized

    """
    Query to fetch agent details based on projectID and agentName
    """
    getAgentDetails(clusterID: String!, projectID: String!): Cluster! @authorized

    # MANIFEST OPERATIONS
    """
    Returns the manifest given projectID, clusterID and accessKey
    """
    getManifest(
        projectID: String!
        clusterID: String!
        accessKey: String!
    ): String! @authorized
}

extend type Mutation {
    # CLUSTER OPERATIONS
    """
    Registers a new cluster for a user in a specified project
    """
    registerCluster(request: RegisterClusterRequest!): RegisterClusterResponse!
    @authorized

    """
    Confirms the subscriber's registration with the control plane
    """
    # authorized directive not required
    confirmClusterRegistration(
        request: ClusterIdentity!
    ): ConfirmClusterRegistrationResponse!

    """
    Sends cluster related events to the subscriber
    """
    # authorized directive not required
    newClusterEvent(request: NewClusterEventRequest!): String!

    """
    Disconnects a cluster/agent and deletes its agent configuration from the control plane
    """
    deleteClusters(projectID: String!, clusterIDs: [String]!): String! @authorized

    """
    Receives pod logs for experiments from agent
    """
    # authorized directive not required
    podLog(request: PodLog!): String!

    """
    Receives kubernetes object data from subscriber
    """
    # authorized directive not required
    kubeObj(request: KubeObjectData!): String!
}

extend type Subscription {
    # CLUSTER OPERATIONS
    """
    Listens cluster events from the graphql server
    """
    getClusterEvents(projectID: String!): ClusterEventResponse! @authorized

    """
    Listens cluster operation request from the graphql server
    """
    # authorized directive not required
    clusterConnect(clusterInfo: ClusterIdentity!): ClusterActionResponse!

    """
    Returns experiment logs from the pods
    """
    getPodLog(request: PodLogRequest!): PodLogResponse! @authorized

    # K8S OPERATIONS
    """
    Returns a kubernetes object given an input
    """
    getKubeObject(request: KubeObjectRequest!): KubeObjectResponse!
    @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/gitops.graphqls", Input: `
"""
Defines the SSHKey details
"""
type SSHKey {
    """
    Public SSH key authenticating into git repository
    """
    publicKey: String!
    """
    Private SSH key authenticating into git repository
    """
    privateKey: String!
}

"""
Details of setting a Git repository
"""
input GitConfig {
    """
    ID of the project where GitOps is configured
    """
    projectID: String!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String!
    """
    URL of the Git repository
    """
    repoURL: String!
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType!
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

"""
Response received after configuring GitOps
"""
type GitConfigResponse {
    """
    Bool value indicating whether GitOps is enabled or not
    """
    enabled: Boolean!
    """
    ID of the project where GitOps is configured
    """
    projectID: String!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String
    """
    URL of the Git repository
    """
    repoURL: String
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

extend type Query {
    # GIT-OPS OPERATIONS
    """
    Returns the git configuration for gitops
    """
    getGitOpsDetails(projectID: String!): GitConfigResponse! @authorized
}

extend type Mutation {
    # GIT-OPS OPERATIONS
    """
    Sends workflow run request(single run workflow only) to agent on gitops notification
    """
    # authorized directive not required
    gitopsNotifier(clusterInfo: ClusterIdentity!, workflowID: String!): String!

    """
    Enables gitops settings in the project
    """
    enableGitOps(config: GitConfig!): Boolean! @authorized

    """
    Disables gitops settings in the project
    """
    disableGitOps(projectID: String!): Boolean! @authorized

    """
    Updates gitops settings in the project
    """
    updateGitOps(config: GitConfig!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/image_registry.graphqls", Input: `"""
Defines details for image registry
"""
type ImageRegistry {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines input data for querying the details of an image registry
"""
input ImageRegistryInput {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines response data for image registry
"""
type ImageRegistryResponse {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Information Image Registry
  """
  imageRegistryInfo: ImageRegistry
  """
  ID of the image registry
  """
  imageRegistryID: String!
  """
  ID of the project in which image registry is created
  """
  projectID: String!
  """
  Timestamp when the image registry was last updated
  """
  updatedAt: String
  """
  Timestamp when the image registry was created
  """
  createdAt: String
  """
  Bool value indicating if the image registry has been removed
  """
  isRemoved: Boolean
}

extend type Query {
  # IMAGE REGISTRY OPERATIONS
  listImageRegistry(projectID: String!): [ImageRegistryResponse!] @authorized

  getImageRegistry(
    imageRegistryID: String!
    projectID: String!
  ): ImageRegistryResponse! @authorized
}

extend type Mutation {
  # IMAGE REGISTRY OPERATIONS
  """
  Create an Image Registry configuration
  """
  createImageRegistry(
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Update the Image Registry configuration
  """
  updateImageRegistry(
    imageRegistryID: String!
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Delete the Image Registry
  """
  deleteImageRegistry(imageRegistryID: String!, projectID: String!): String!
  @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/k8s.graphqls", Input: `
"""
Response received for querying Kubernetes Object
"""
type KubeObjectResponse {
    """
    ID of the cluster in which the Kubernetes object is present
    """
    clusterID: ID!
    """
    Type of the Kubernetes object
    """
    kubeObj: String!
}

"""
Defines the details of Kubernetes object
"""
input KubeObjectData {
    """
    Unique request ID for fetching Kubernetes object details
    """
    requestID: ID!
    """
    ID of the cluster in which the Kubernetes object is present
    """
    clusterID: ClusterIdentity!
    """
    Type of the Kubernetes object
    """
    kubeObj: String!
}

"""
Defines details for fetching Kubernetes object data
"""
input KubeObjectRequest {
    """
    ID of the cluster in which the Kubernetes object is present
    """
    clusterID: ID!
    """
    Type of the Kubernetes object to be fetched
    """
    objectType: String!
    kubeObjRequest: KubeGVRRequest!
}

input KubeGVRRequest {
    group: String!
    version: String!
    resource: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "graph/myhub.graphqls", Input: `enum AuthType {
  BASIC
  NONE
  SSH
  TOKEN
}

enum FileType {
  EXPERIMENT
  ENGINE
  WORKFLOW
  CSV
}

enum HubType {
  GIT
  REMOTE
}

type ChaosHub {
  """
  ID of the chaos hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  ID of the project in which the chaos hub is present
  """
  projectID: String!
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Bool value indicating if the chaos hub is removed
  """
  isRemoved: Boolean!
  """
  Timestamp when the chaos hub was created
  """
  createdAt: String!
  """
  Timestamp when the chaos hub was last updated
  """
  updatedAt: String!
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
}

#type Charts {
#	charts: [Chart!]!
#}

type Chart {
  apiVersion: String!
  kind: String!
  metadata: Metadata!
  spec: Spec!
  packageInfo: PackageInformation!
}

"""
Defines the details of the maintainer
"""
type Maintainer {
  """
  Name of the maintainer
  """
  name: String!
  """
  Email of the maintainer
  """
  email: String!
}

type Link {
  name: String!
  url: String!
}

type Metadata {
  name: String!
  version: String!
  annotations: Annotation!
}

type Annotation {
  categories: String!
  vendor: String!
  createdAt: String!
  repository: String!
  support: String!
  chartDescription: String!
}

type Spec {
  displayName: String!
  categoryDescription: String!
  keywords: [String!]!
  maturity: String!
  maintainers: [Maintainer!]!
  minKubeVersion: String!
  provider: Provider!
  links: [Link!]!
  experiments: [String!]!
  chaosExpCRDLink: String!
  platforms: [String!]!
  chaosType: String
}

type Provider {
	name: String!
}

type PackageInformation {
  packageName: String!
  experiments: [Experiments!]!
}

type Experiments {
  name: String!
  CSV: String!
  desc: String!
}

type ChaosHubStatus {
  """
  ID of the hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is available or not.
  """
  isAvailable: Boolean!
  """
  Total number of experiments in the hub
  """
  totalExp: String!
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Bool value indicating whether the hub is private or not.
  """
  isRemoved: Boolean!
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
}

"""
Defines the details required for creating a chaos hub
"""
input CreateChaosHubRequest {
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Project ID associated with this chaos hub
  """
  projectID: String!
}

input ExperimentRequest {
  """
  ID of the project
  """
  projectID: String!
  """
  Name of the chart being used
  """
  chartName: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Name of the hub
  """
  hubName: String!
  """
  Type of thr file for workflow: chaosEngine/ experimentInput
  """
  fileType: String
}

input CloningInput {
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  ID of the project
  """
  projectID: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  sshPrivateKey: String
}

input CreateRemoteMyHub {
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  ProjectID of the ChaosHub
  """
  projectID: String!
}


input UpdateChaosHubRequest {
  """
  ID of the chaos hub
  """
  id: String!
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Project ID associated with this chaos hub
  """
  projectID: String!
}

type ExperimentDetails{
  """
  Engine Manifest
  """
  engineDetails: String!

  """
  Experiment Manifest
  """
  experimentDetails: String!
}

type PredefinedWorkflowList {
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Workflow CSV
  """
  workflowCSV: String!
  """
  Workflow Manifest
  """
  workflowManifest: String!
}

extend type Query {
  # CHAOS-HUB OPERATIONS
  """
  List the Charts details of a ChaosHub
  """
  listCharts(hubName: String!, projectID: String!): [Chart!]! @authorized

  """
  Get the Experiment list from a ChaosHub
  """
  getHubExperiment(request: ExperimentRequest!): Chart! @authorized

  """
  List the status of all the connected ChaosHub
  """
  listHubStatus(projectID: String!): [ChaosHubStatus]! @authorized

  """
  Get the YAML manifest of ChaosEngine/ChaosExperiment
  """
  getYAMLData(request: ExperimentRequest!): String! @authorized

  """
  Get Engine and Experiment YAML
  """
  getExperimentDetails(request: ExperimentRequest!): ExperimentDetails! @authorized

  """
  List the PredefinedWorkflows present in the hub
  """
  listPredefinedWorkflows(hubName: String!, projectID: String!): [PredefinedWorkflowList!]! @authorized

  """
  Get the predefined workflow YAML
  """
  getPredefinedExperimentYAML(request: ExperimentRequest!): String! @authorized
}

extend type Mutation {
  # CHAOS-HUB OPERATIONS
  """
  Add a ChaosHub (includes the git clone operation)
  """
  addChaosHub(request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Add a ChaosHub (remote hub download)
  """
  addRemoteChaosHub(request: CreateRemoteMyHub!): ChaosHub! @authorized

  """
  Save a ChaosHub configuration without cloning it
  """
  saveChaosHub(request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Sync changes from the Git repository of a ChaosHub
  """
  syncChaosHub(id: ID!, projectID: String!): String! @authorized

  """
  Generates Private and Public key for SSH authentication
  """
  generateSSHKey: SSHKey! @authorized

  """
  Update the configuration of a ChaosHub
  """
  updateChaosHub(request: UpdateChaosHubRequest!): ChaosHub! @authorized

  """
  Delete the ChaosHub
  """
  deleteChaosHub(projectID: String!, hubID: String!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/project.graphqls", Input: `enum Invitation {
  Accepted
  Pending
}

enum MemberRole {
  Owner
  Editor
  Viewer
}
`, BuiltIn: false},
	&ast.Source{Name: "graph/usage.graphqls", Input: `"""
Defines details of workflow statistics
"""
type WorkflowStat {
  """
  Number of schedules
  """
  schedules: Int!
  """
  Number of workflow runs
  """
  runs: Int!
  """
  Number of experiment runs
  """
  expRuns: Int!
}

"""
Defines details of agent statistics
"""
type AgentStat {
  """
  Number of namespaces
  """
  ns: Int!
  """
  Number of clusters
  """
  cluster: Int!
  """
  Total number of agents
  """
  total: Int!
  """
  Number of active agents
  """
  active: Int!
}

"""
Defines all the stats under a project
"""
type ProjectData {
  """
  Workflow related statistics
  """
  workflows: WorkflowStat!
  """
  Agent related statistics
  """
  agents: AgentStat!
  """
  ID of the project
  """
  projectID: String!
}

"""
Defines total number of projects, users, agents and workflows
"""
type TotalCount {
  """
  Total number of projects
  """
  projects: Int!
  """
  Total number of users
  """
  users: Int!
  """
  Total number of agents
  """
  agents: AgentStat!
  """
  Total number of workflows
  """
  workflows: WorkflowStat!
}

"""
Defines total usage data
"""
type UsageDataResponse {
  """
  Project related data
  """
  projects: [ProjectData]!
  """
  Total number of entries
  """
  totalEntries: Int!
  """
  Total number of projects, users, agents and workflows
  """
  totalCount: TotalCount!
}

enum UsageSort {
  AGENTS
  EXPERIMENT_RUNS
  OWNER
  PROJECT
  SCHEDULES
  TEAM_MEMBERS
  WORKFLOW_RUNS
}

"""
Defines details required for sorting the data for a particular field
"""
input UsageSortInput {
  """
  Field for which sorting will be done
  """
  field: UsageSort!
  """
  Bool value indicating if sorting will be done in descending order or not
  """
  descending: Boolean!
}

"""
Defines input details for querying the total usage related details
"""
input UsageDataRequest {
  """
  Pagination detail to fetch only a required number of data at a time
  """
  pagination: Pagination
  """
  Rage of dates between which the data will be fetched
  """
  dateRange: DateRange!
  """
  Sorting details to fetch the data in a sorted manner
  """
  sort: UsageSortInput
  """
  Search field to search for a particular project and fetch it's data
  """
  searchProject: String
}

extend type Query {
  # USAGE OPERATIONS
  """
  Returns the portal's usage overview
  """
  getUsageData(request: UsageDataRequest!): UsageDataResponse! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/workflow.graphqls", Input: `directive @authorized on FIELD_DEFINITION

"""
Defines the details of the weightages of each chaos experiment in the workflow
"""
input WeightagesInput {
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Weightage of the experiment
  """
  weightage: Int!
}

"""
Defines the details for a chaos workflow
"""
input ChaosWorkFlowRequest {
  """
  ID of the workflow
  """
  workflowID: String
  """
  Manifest of the workflow
  """
  workflowManifest: String!
  """
  Cron syntax of the workflow schedule
  """
  cronSyntax: String!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Description of the workflow
  """
  workflowDescription: String!
  """
  Array containing weightage and name of each chaos experiment in the workflow
  """
  weightages: [WeightagesInput!]!
  """
  Bool value indicating whether the workflow is a custom workflow or not
  """
  isCustomWorkflow: Boolean!
  """
  ID of the project under which the workflow is scheduled
  """
  projectID: ID!
  """
  ID of the target cluster in which the workflow will run
  """
  clusterID: ID!
}

"""
Defines the response received for querying the details of chaos workflow
"""
type ChaosWorkFlowResponse {
  """
  ID of the workflow
  """
  workflowID: String!
  """
  Cron syntax of the workflow schedule
  """
  cronSyntax: String!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Description of the workflow
  """
  workflowDescription: String!
  """
  Bool value indicating whether the workflow is a custom workflow or not
  """
  isCustomWorkflow: Boolean!
}

"""
Defines the details for a workflow run
"""
input WorkflowRunRequest {
  """
  ID of the workflow
  """
  workflowID: ID!
  """
  ID of the workflow run which is to be queried
  """
  workflowRunID: ID!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Provides audit context to workflow run i.e who ran the workflow
  """
  executedBy: String!
  """
  Stores all the workflow run details related to the nodes of DAG graph and chaos results of the experiments
  """
  executionData: String!
  """
  ID of the cluster agent in which the workflow is running
  """
  clusterID: ClusterIdentity!
  """
  Bool value indicating if the workflow run has completed
  """
  completed: Boolean!
  """
  Bool value indicating if the workflow run has removed
  """
  isRemoved: Boolean
}

"""
Defines the response received for querying querying the pod logs
"""
type PodLogResponse {
  """
  ID of the workflow run which is to be queried
  """
  workflowRunID: ID!
  """
  Name of the pod for which logs are queried
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

"""
Response received for querying pod logs
"""
input PodLog {
  """
  ID of the cluster
  """
  clusterID: ClusterIdentity!
  """
  Unique request ID of a particular node which is being queried
  """
  requestID: ID!
  """
  ID of a workflow run
  """
  workflowRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

"""
Defines the details for fetching the pod logs
"""
input PodLogRequest {
  """
  ID of the cluster
  """
  clusterID: ID!
  """
  ID of a workflow run
  """
  workflowRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Namespace where the pod is running
  """
  podNamespace: String!
  """
  Type of the pod: chaosEngine or not pod
  """
  podType: String!
  """
  Name of the experiment pod fetched from execution data
  """
  expPod: String
  """
  Name of the runner pod fetched from execution data
  """
  runnerPod: String
  """
  Namespace where the experiment is executing
  """
  chaosNamespace: String
}

enum WorkflowRunStatus {
  All
  Failed
  Running
  Succeeded
  Terminated
}

"""
Defines the start date and end date for the filtering the data
"""
input DateRange {
  """
  Start date
  """
  startDate: String!
  """
  End date
  """
  endDate: String
}

"""
Defines input type for workflow run filter
"""
input WorkflowRunFilterInput {
  """
  Name of the workflow
  """
  workflowName: String
  """
  Name of the cluster agent
  """
  clusterName: String
  """
  Status of the workflow run
  """
  workflowStatus: WorkflowRunStatus
  """
  Date range for filtering purpose
  """
  dateRange: DateRange
}

"""
Defines data required to fetch paginated data
"""
input Pagination {
  """
  Page number for which data will be fetched
  """
  page: Int!
  """
  Number of data to be fetched
  """
  limit: Int!
}

enum WorkflowSortingField {
  NAME
  TIME
}

"""
Defines sorting options for workflow runs
"""
input WorkflowRunSortInput {
  """
  Field in which sorting will be done
  """
  field: WorkflowSortingField!
  """
  Bool value indicating whether the sorting will be done in descending order
  """
  descending: Boolean
}

"""
Defines the details for workflow runs
"""
input ListWorkflowRunsRequest {
  """
  ID of the project
  """
  projectID: ID!
  """
  Array of workflow run IDs for which details will be fetched
  """
  workflowRunIDs: [ID]
  """
  Array of workflow IDs for which details will be fetched
  """
  workflowIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: WorkflowRunSortInput
  """
  Details for fetching filtered data
  """
  filter: WorkflowRunFilterInput
}

"""
Defines the details of the weightages of each chaos experiment in the workflow
"""
type Weightages {
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Weightage of the experiment
  """
  weightage: Int!
}

"""
Defines the details of a workflow run
"""
type WorkflowRun {
  """
  ID of the workflow run which is to be queried
  """
  workflowRunID: ID!
  """
  ID of the workflow
  """
  workflowID: ID!
  """
  Name of the cluster agent in which the workflow is running
  """
  clusterName: String!
  """
  Array containing weightage and name of each chaos experiment in the workflow
  """
  weightages: [Weightages!]!
  """
  Timestamp at which workflow run was last updated
  """
  lastUpdated: String!
  """
  ID of the project
  """
  projectID: ID!
  """
  ID of the target cluster in which the workflow is running
  """
  clusterID: ID!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Cluster type : Internal or External
  """
  clusterType: String
  """
  Phase of the workflow run
  """
  phase: String!
  """
  Resiliency score of the workflow
  """
  resiliencyScore: Float
  """
  Number of experiments passed
  """
  experimentsPassed: Int
  """
  Number of experiments failed
  """
  experimentsFailed: Int
  """
  Number of experiments awaited
  """
  experimentsAwaited: Int
  """
  Number of experiments stopped
  """
  experimentsStopped: Int
  """
  Number of experiments which are not available
  """
  experimentsNa: Int
  """
  Total number of experiments
  """
  totalExperiments: Int
  """
  Stores all the workflow run details related to the nodes of DAG graph and chaos results of the experiments
  """
  executionData: String!
  """
  Bool value indicating if the workflow run has removed
  """
  isRemoved: Boolean
  """
  Provides audit context to workflow run i.e who ran the workflow
  """
  executedBy: String!
}

"""
Defines the details of a workflow to sent as response
"""
type ListWorkflowRunsResponse {
  """
  Total number of workflow runs
  """
  totalNoOfWorkflowRuns: Int!
  """
  Defines details of workflow runs
  """
  workflowRuns: [WorkflowRun]!
}

"""
Defines filter options for workflows
"""
input WorkflowFilterInput {
  """
  Name of the workflow
  """
  workflowName: String
  """
  Name of the cluster agent in which the workflow is running
  """
  clusterName: String
}

"""
Defines the details for a workflow
"""
input ListWorkflowsRequest {
  """
  ID of the project
  """
  projectID: ID!
  """
  Array of workflow IDs for which details will be fetched
  """
  workflowIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: WorkflowSortInput
  """
  Details for fetching filtered data
  """
  filter: WorkflowFilterInput
}

"""
Defines sorting options for workflow
"""
input WorkflowSortInput {
  """
  Field in which sorting will be done
  """
  field: WorkflowSortingField!
  """
  Bool value indicating whether the sorting will be done in descending order
  """
  descending: Boolean
}

"""
Defines the details for a workflow
"""
type Workflow {
  """
  ID of the workflow
  """
  workflowID: String!
  """
  Manifest of the workflow
  """
  workflowManifest: String!
  """
  Cron syntax of the workflow schedule
  """
  cronSyntax: String!
  """
  Name of the target cluster in which the workflow is running
  """
  clusterName: String!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Description of the workflow
  """
  workflowDescription: String!
  """
  Array containing weightage and name of each chaos experiment in the workflow
  """
  weightages: [Weightages!]!
  """
  Bool value indicating whether the workflow is a custom workflow or not
  """
  isCustomWorkflow: Boolean!
  """
  Timestamp when the workflow was last updated
  """
  updatedAt: String!
  """
  Timestamp when the workflow was created
  """
  createdAt: String!
  """
  ID of the project under which the workflow is scheduled
  """
  projectID: ID!
  """
  ID of the target cluster in which the workflow will run
  """
  clusterID: ID!
  """
  Cluster type : Internal or External
  """
  clusterType: String!
  """
  Bool value indicating if the workflow has removed
  """
  isRemoved: Boolean!
  """
  Provides audit context to workflow i.e who ran the workflow
  """
  lastUpdatedBy: String
}

"""
Defines the details for a workflow with total workflow count
"""
type ListWorkflowsResponse {
  """
  Total number of workflows
  """
  totalNoOfWorkflows: Int!
  """
  Details related to the workflows
  """
  workflows: [Workflow]!
}

type Query {
  # WORKFLOW OPERATIONS
  """
  Returns the list of workflows in a project based on various filter parameters
  """
  listWorkflows(request: ListWorkflowsRequest!): ListWorkflowsResponse!
  @authorized

  """
  Returns the list of workflow runs in a project based on various filter parameters
  """
  listWorkflowRuns(
    request: ListWorkflowRunsRequest!
  ): ListWorkflowRunsResponse! @authorized
}

type Mutation {
  # WORKFLOW OPERATIONS
  """
  Creates a new workflow and applies its manifest
  """
  createChaosWorkFlow(request: ChaosWorkFlowRequest!): ChaosWorkFlowResponse!
  @authorized

  """
  Reruns the workflow and applies its manifest
  """
  reRunChaosWorkFlow(projectID: String!, workflowID: String!): String!
  @authorized

  """
  Updates the workflow
  """
  updateChaosWorkflow(request: ChaosWorkFlowRequest): ChaosWorkFlowResponse!
  @authorized

  """
  Removes a workflow from cluster
  """
  deleteChaosWorkflow(
    projectID: String!
    workflowID: String
    workflowRunID: String
  ): Boolean! @authorized

  """
  Removes workflow run from the cluster only
  """
  terminateChaosWorkflow(
    projectID: String!
    workflowID: String
    workflowRunID: String
  ): Boolean! @authorized

  """
  Creates a new workflow run and sends it to subscriber
  """
  # authorized directive not required
  chaosWorkflowRun(request: WorkflowRunRequest!): String!

  """
  Manually sync the status of the workflow run
  """
  syncWorkflowRun(
    projectID: String!
    workflowID: String!
    workflowRunID: String!
  ): Boolean! @authorized
}

type Subscription {
  # WORKFLOW OPERATIONS
  """
  Sends workflow events to the subscriber
  """
  getWorkflowEvents(projectID: String!): WorkflowRun! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/workflow_template.graphqls", Input: `"""
Details for a workflow template
"""
type WorkflowTemplate {
    """
    ID of the template
    """
    templateID: ID!
    """
    Workflow manifest in JSON escaped string
    """
    manifest: String!
    """
    Name of the template
    """
    templateName: String!
    """
    Description of the template
    """
    templateDescription: String!
    """
    ID of the project
    """
    projectID: String!
    """
    Name of the project
    """
    projectName: String!
    """
    Time at which the manifest template was created
    """
    createdAt: String!
    """
    Bool value indicating if the workflow template has removed
    """
    isRemoved: Boolean!
    """
    Bool value indicating whether the workflow template is a custom or not
    """
    isCustomWorkflow: Boolean!
}

"""
Details for saving the template
"""
input TemplateInput {
    """
    Workflow manifest in JSON escaped format
    """
    manifest: String!
    """
    Name of the template
    """
    templateName: String!
    """
    Description of the template
    """
    templateDescription: String!
    """
    Name of the project
    """
    projectID: String!
    """
    Bool value indicating whether the workflow is a custom workflow or not
    """
    isCustomWorkflow: Boolean!
}

extend type Query {
    # WORKFLOW TEMPLATE OPERATIONS
    """
    Returns all the workflow templates for the projectID
    """
    listWorkflowManifests(projectID: String!): [WorkflowTemplate]! @authorized

    """
    Returns a single workflow templates given a projectID and a templateID
    """
    getWorkflowManifestByID(
        projectID: String!
        templateID: String!
    ): WorkflowTemplate! @authorized
}

extend type Mutation {
    # WORKFLOW TEMPLATE OPERATIONS
    """
    Creates a workflow template manifest
    """
    createWorkflowTemplate(request: TemplateInput): WorkflowTemplate! @authorized

    """
    Removes a workflow template manifest
    """
    deleteWorkflowTemplate(projectID: String!, templateID: String!): Boolean!
    @authorized
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNCreateChaosHubRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addRemoteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateRemoteMyHub
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNCreateRemoteMyHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateRemoteMyHub(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_chaosWorkflowRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.WorkflowRunRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNWorkflowRunRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmClusterRegistration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ClusterIdentity
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createChaosWorkFlow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ChaosWorkFlowRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNChaosWorkFlowRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDashBoard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CreateDBInput
	if tmp, ok := rawArgs["dashboard"]; ok {
		arg0, err = ec.unmarshalOCreateDBInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateDBInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboard"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.DSInput
	if tmp, ok := rawArgs["datasource"]; ok {
		arg0, err = ec.unmarshalODSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["datasource"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg1, err = ec.unmarshalNImageRegistryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createWorkflowTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.TemplateInput
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOTemplateInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTemplateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosWorkflow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["workflowRunID"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteClusters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["clusterIDs"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterIDs"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["dbID"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dbID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.DeleteDSInput
	if tmp, ok := rawArgs["input"]; ok {
		arg1, err = ec.unmarshalNDeleteDSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDeleteDSInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWorkflowTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["templateID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["templateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_disableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_enableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["config"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["config"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_gitopsNotifier_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ClusterIdentity
	if tmp, ok := rawArgs["clusterInfo"]; ok {
		arg0, err = ec.unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterInfo"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_kubeObj_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectData
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeObjectData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_newClusterEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewClusterEventRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNNewClusterEventRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelNewClusterEventRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_podLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLog
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLog2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPodLog(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_reRunChaosWorkFlow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_registerCluster_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RegisterClusterRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNRegisterClusterRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelRegisterClusterRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_saveChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNCreateChaosHubRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_syncChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_syncWorkflowRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["workflowRunID"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_terminateChaosWorkflow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["workflowRunID"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNUpdateChaosHubRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosWorkflow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ChaosWorkFlowRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOChaosWorkFlowRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.UpdateDBInput
	if tmp, ok := rawArgs["dashboard"]; ok {
		arg1, err = ec.unmarshalNUpdateDBInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdateDBInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboard"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["chaosQueryUpdate"]; ok {
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chaosQueryUpdate"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DSInput
	if tmp, ok := rawArgs["datasource"]; ok {
		arg0, err = ec.unmarshalNDSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["datasource"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["config"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["config"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	var arg2 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg2, err = ec.unmarshalNImageRegistryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePanel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.Panel
	if tmp, ok := rawArgs["panelInput"]; ok {
		arg0, err = ec.unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["panelInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAgentDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clusterID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getGitOpsDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getHubExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getManifest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["clusterID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["accessKey"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accessKey"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getPredefinedExperimentYAML_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPromLabelNamesAndValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PromSeriesInput
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOPromSeriesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPromSeriesList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.DsDetails
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalODsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPrometheusData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PrometheusDataRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOPrometheusDataRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPrometheusDataRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUsageData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UsageDataRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNUsageDataRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageDataRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getWorkflowManifestByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["templateID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["templateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getWorkflowRunStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.WorkflowRunStatsRequest
	if tmp, ok := rawArgs["workflowRunStatsRequest"]; ok {
		arg0, err = ec.unmarshalNWorkflowRunStatsRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatsRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunStatsRequest"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getYAMLData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listCharts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubName"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listClusters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["clusterType"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["clusterID"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["dbID"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dbID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_listDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listHeatmapData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["year"]; ok {
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["year"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_listHubStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listPortalDashboardData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["hubName"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubName"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listPredefinedWorkflows_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubName"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflowManifests_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflowRuns_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ListWorkflowRunsRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNListWorkflowRunsRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowRunsRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflowStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.TimeFrequency
	if tmp, ok := rawArgs["filter"]; ok {
		arg1, err = ec.unmarshalNTimeFrequency2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTimeFrequency(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["showWorkflowRuns"]; ok {
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showWorkflowRuns"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflows_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ListWorkflowsRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNListWorkflowsRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowsRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_clusterConnect_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ClusterIdentity
	if tmp, ok := rawArgs["clusterInfo"]; ok {
		arg0, err = ec.unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterInfo"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getClusterEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getKubeObject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeObjectRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getPodLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLogRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLogRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPodLogRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getWorkflowEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_viewDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["dashboardID"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboardID"] = arg0
	var arg1 []*model.PromQueryInput
	if tmp, ok := rawArgs["promQueries"]; ok {
		arg1, err = ec.unmarshalNPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["promQueries"] = arg1
	var arg2 []*model.QueryMapForPanelGroup
	if tmp, ok := rawArgs["dashboardQueryMap"]; ok {
		arg2, err = ec.unmarshalNQueryMapForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanelGroup(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboardQueryMap"] = arg2
	var arg3 model.DataVars
	if tmp, ok := rawArgs["dataVariables"]; ok {
		arg3, err = ec.unmarshalNDataVars2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDataVars(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dataVariables"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActionPayload_requestType(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_k8sManifest(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.K8sManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_externalData(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_username(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_ns(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_cluster(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cluster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_total(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_active(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_categories(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Categories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_vendor(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_repository(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_support(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Support, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_chartDescription(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChartDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_queryID(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_legends(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legends, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_tsvs(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tsvs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]*model.AnnotationsTimeStampValue)
	fc.Result = res
	return ec.marshalOAnnotationsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsTimeStampValue(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_subDataArray(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubDataArray, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]*model.SubData)
	fc.Result = res
	return ec.marshalOSubData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSubData(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsTimeStampValue_date(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsTimeStampValue_value(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationMetadataResponse_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationMetadataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ApplicationMetadataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationMetadataResponse_applications(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationMetadataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ApplicationMetadataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Applications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceResponse)
	fc.Result = res
	return ec.marshalOResourceResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResourceResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_hubName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isAvailable(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_totalExp(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_hubName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPublicKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_workflowID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_workflowDescription(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_isCustomWorkflow(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomWorkflow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_kind(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Metadata)
	fc.Result = res
	return ec.marshalNMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_spec(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Spec)
	fc.Result = res
	return ec.marshalNSpec2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_packageInfo(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PackageInformation)
	fc.Result = res
	return ec.marshalNPackageInformation2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPackageInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_description(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_platformName(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_accessKey(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_isRegistered(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRegistered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_isClusterConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsClusterConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_isActive(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_clusterType(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_noOfSchedules(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfSchedules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_noOfWorkflows(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfWorkflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_token(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentNamespace(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentScope(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentScope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentNsExists(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentNsExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentSaExists(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentSaExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_lastWorkflowTimestamp(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastWorkflowTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_startTime(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_version(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterActionResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ClusterActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterActionResponse_action(ctx context.Context, field graphql.CollectedField, obj *model.ClusterActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ActionPayload)
	fc.Result = res
	return ec.marshalNActionPayload2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelActionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_eventID(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_eventType(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_eventName(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_description(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_cluster(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cluster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Cluster)
	fc.Result = res
	return ec.marshalNCluster2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCluster(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmClusterRegistrationResponse_isClusterConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmClusterRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmClusterRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsClusterConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmClusterRegistrationResponse_newAccessKey(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmClusterRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmClusterRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewAccessKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmClusterRegistrationResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmClusterRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmClusterRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsID(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsName(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsType(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsURL(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_accessType(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_authType(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_basicAuthUsername(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasicAuthUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_basicAuthPassword(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasicAuthPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_scrapeInterval(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScrapeInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_queryTimeout(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryTimeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_httpMethod(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTTPMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_healthStatus(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DashboardPromResponse_dashboardMetricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.DashboardPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DashboardPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DashboardMetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricDataForPanelGroup)
	fc.Result = res
	return ec.marshalOMetricDataForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _DashboardPromResponse_annotationsResponse(ctx context.Context, field graphql.CollectedField, obj *model.DashboardPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DashboardPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnnotationsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AnnotationsPromResponse)
	fc.Result = res
	return ec.marshalOAnnotationsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_engineDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EngineDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_experimentDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_name(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_CSV(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_desc(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_enabled(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_branch(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_authType(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuthType)
	fc.Result = res
	return ec.marshalOAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_userName(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_password(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HeatmapDataResponse_bins(ctx context.Context, field graphql.CollectedField, obj *model.HeatmapDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "HeatmapDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowRunsData)
	fc.Result = res
	return ec.marshalNWorkflowRunsData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunsData(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRepoName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRepoName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryType(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretNamespace(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_enableRegistry(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnableRegistry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryInfo(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistry)
	fc.Result = res
	return ec.marshalOImageRegistry2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_kubeObj(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KubeObj, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _LabelValue_label(ctx context.Context, field graphql.CollectedField, obj *model.LabelValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "LabelValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _LabelValue_values(ctx context.Context, field graphql.CollectedField, obj *model.LabelValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "LabelValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Option)
	fc.Result = res
	return ec.marshalOOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelOption(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_name(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_url(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbTypeID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbTypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbTypeName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbTypeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbInformation(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbInformation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_chaosEventQueryTemplate(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosEventQueryTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_chaosVerdictQueryTemplate(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosVerdictQueryTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_applicationMetadataMap(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationMetadataMap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ApplicationMetadataResponse)
	fc.Result = res
	return ec.marshalOApplicationMetadataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsType(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsURL(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsHealthStatus(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsHealthStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_panelGroups(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PanelGroupResponse)
	fc.Result = res
	return ec.marshalNPanelGroupResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroupResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_endTime(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_startTime(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_refreshRate(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_viewedAt(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowRunsResponse_totalNoOfWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowRunsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowRunsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowRunsResponse_workflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowRunsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowRunsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowRun)
	fc.Result = res
	return ec.marshalNWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowsResponse_totalNoOfWorkflows(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfWorkflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowsResponse_workflows(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Workflow)
	fc.Result = res
	return ec.marshalNWorkflow2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflow(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_name(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_email(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_version(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Annotation)
	fc.Result = res
	return ec.marshalNAnnotation2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanel_panelID(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanel) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanel",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanel_panelMetricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanel) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanel",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelMetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricsPromResponse)
	fc.Result = res
	return ec.marshalOMetricsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanelGroup_panelGroupID(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanelGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanelGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanelGroup_panelGroupMetricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanelGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanelGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupMetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricDataForPanel)
	fc.Result = res
	return ec.marshalOMetricDataForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanel(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsPromResponse_queryID(ctx context.Context, field graphql.CollectedField, obj *model.MetricsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsPromResponse_legends(ctx context.Context, field graphql.CollectedField, obj *model.MetricsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legends, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsPromResponse_tsvs(ctx context.Context, field graphql.CollectedField, obj *model.MetricsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tsvs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]*model.MetricsTimeStampValue)
	fc.Result = res
	return ec.marshalOMetricsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsTimeStampValue(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsTimeStampValue_date(ctx context.Context, field graphql.CollectedField, obj *model.MetricsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsTimeStampValue_value(ctx context.Context, field graphql.CollectedField, obj *model.MetricsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createChaosWorkFlow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createChaosWorkFlow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateChaosWorkFlow(rctx, args["request"].(model.ChaosWorkFlowRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosWorkFlowResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosWorkFlowResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosWorkFlowResponse)
	fc.Result = res
	return ec.marshalNChaosWorkFlowResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_reRunChaosWorkFlow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_reRunChaosWorkFlow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ReRunChaosWorkFlow(rctx, args["projectID"].(string), args["workflowID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosWorkflow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateChaosWorkflow(rctx, args["request"].(*model.ChaosWorkFlowRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosWorkFlowResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosWorkFlowResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosWorkFlowResponse)
	fc.Result = res
	return ec.marshalNChaosWorkFlowResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosWorkflow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteChaosWorkflow(rctx, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_terminateChaosWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_terminateChaosWorkflow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TerminateChaosWorkflow(rctx, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_chaosWorkflowRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_chaosWorkflowRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ChaosWorkflowRun(rctx, args["request"].(model.WorkflowRunRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_syncWorkflowRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_syncWorkflowRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncWorkflowRun(rctx, args["projectID"].(string), args["workflowID"].(string), args["workflowRunID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateDataSource(rctx, args["datasource"].(*model.DSInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DSResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DSResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DSResponse)
	fc.Result = res
	return ec.marshalODSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createDashBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createDashBoard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateDashBoard(rctx, args["dashboard"].(*model.CreateDBInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListDashboardResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListDashboardResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListDashboardResponse)
	fc.Result = res
	return ec.marshalNListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateDataSource(rctx, args["datasource"].(model.DSInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DSResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DSResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DSResponse)
	fc.Result = res
	return ec.marshalNDSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateDashboard(rctx, args["projectID"].(string), args["dashboard"].(model.UpdateDBInput), args["chaosQueryUpdate"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePanel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePanel_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdatePanel(rctx, args["panelInput"].([]*model.Panel))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDashboard(rctx, args["projectID"].(string), args["dbID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDataSource(rctx, args["projectID"].(string), args["input"].(model.DeleteDSInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_registerCluster(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_registerCluster_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterCluster(rctx, args["request"].(model.RegisterClusterRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RegisterClusterResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.RegisterClusterResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegisterClusterResponse)
	fc.Result = res
	return ec.marshalNRegisterClusterResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelRegisterClusterResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_confirmClusterRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_confirmClusterRegistration_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmClusterRegistration(rctx, args["request"].(model.ClusterIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConfirmClusterRegistrationResponse)
	fc.Result = res
	return ec.marshalNConfirmClusterRegistrationResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelConfirmClusterRegistrationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_newClusterEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_newClusterEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NewClusterEvent(rctx, args["request"].(model.NewClusterEventRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteClusters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteClusters_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteClusters(rctx, args["projectID"].(string), args["clusterIDs"].([]*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_podLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_podLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PodLog(rctx, args["request"].(model.PodLog))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_kubeObj(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_kubeObj_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().KubeObj(rctx, args["request"].(model.KubeObjectData))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_gitopsNotifier(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_gitopsNotifier_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GitopsNotifier(rctx, args["clusterInfo"].(model.ClusterIdentity), args["workflowID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_enableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_enableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EnableGitOps(rctx, args["config"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_disableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_disableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DisableGitOps(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGitOps(rctx, args["config"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateImageRegistry(rctx, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddChaosHub(rctx, args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addRemoteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addRemoteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddRemoteChaosHub(rctx, args["request"].(model.CreateRemoteMyHub))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_saveChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_saveChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SaveChaosHub(rctx, args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_syncChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_syncChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncChaosHub(rctx, args["id"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_generateSSHKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().GenerateSSHKey(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SSHKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.SSHKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SSHKey)
	fc.Result = res
	return ec.marshalNSSHKey2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSSHKey(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateChaosHub(rctx, args["request"].(model.UpdateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteChaosHub(rctx, args["projectID"].(string), args["hubID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createWorkflowTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createWorkflowTemplate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateWorkflowTemplate(rctx, args["request"].(*model.TemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WorkflowTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowTemplate)
	fc.Result = res
	return ec.marshalNWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteWorkflowTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteWorkflowTemplate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteWorkflowTemplate(rctx, args["projectID"].(string), args["templateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Option_name(ctx context.Context, field graphql.CollectedField, obj *model.Option) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Option",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_packageName(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_experiments(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Experiments)
	fc.Result = res
	return ec.marshalNExperiments2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperiments(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelGroupResponse_panels(ctx context.Context, field graphql.CollectedField, obj *model.PanelGroupResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelGroupResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Panels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PanelResponse)
	fc.Result = res
	return ec.marshalOPanelResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelGroupResponse_panelGroupName(ctx context.Context, field graphql.CollectedField, obj *model.PanelGroupResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelGroupResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelGroupResponse_panelGroupID(ctx context.Context, field graphql.CollectedField, obj *model.PanelGroupResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelGroupResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelOptionResponse_points(ctx context.Context, field graphql.CollectedField, obj *model.PanelOptionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelOptionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Points, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelOptionResponse_grIDs(ctx context.Context, field graphql.CollectedField, obj *model.PanelOptionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelOptionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelOptionResponse_leftAxis(ctx context.Context, field graphql.CollectedField, obj *model.PanelOptionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelOptionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LeftAxis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_panelID(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_yAxisLeft(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YAxisLeft, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_yAxisRight(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YAxisRight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_xAxisDown(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XAxisDown, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_unit(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_promQueries(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromQueries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PromQueryResponse)
	fc.Result = res
	return ec.marshalOPromQueryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_panelOptions(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PanelOptionResponse)
	fc.Result = res
	return ec.marshalOPanelOptionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelOptionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_panelName(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_workflowRunID(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podName(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podType(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_log(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Log, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PortalDashboardDataResponse_name(ctx context.Context, field graphql.CollectedField, obj *model.PortalDashboardDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PortalDashboardDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PortalDashboardDataResponse_dashboardData(ctx context.Context, field graphql.CollectedField, obj *model.PortalDashboardDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PortalDashboardDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DashboardData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedWorkflowList_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedWorkflowList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedWorkflowList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedWorkflowList_workflowCSV(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedWorkflowList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedWorkflowList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowCsv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedWorkflowList_workflowManifest(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedWorkflowList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedWorkflowList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ProjectData_workflows(ctx context.Context, field graphql.CollectedField, obj *model.ProjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ProjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowStat)
	fc.Result = res
	return ec.marshalNWorkflowStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStat(ctx, field.Selections, res)
}

func (ec *executionContext) _ProjectData_agents(ctx context.Context, field graphql.CollectedField, obj *model.ProjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ProjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AgentStat)
	fc.Result = res
	return ec.marshalNAgentStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAgentStat(ctx, field.Selections, res)
}

func (ec *executionContext) _ProjectData_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ProjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ProjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_queryID(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_promQueryName(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromQueryName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_legend(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legend, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_resolution(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_minstep(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minstep, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_line(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Line, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_closeArea(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseArea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _PromSeriesListResponse_seriesList(ctx context.Context, field graphql.CollectedField, obj *model.PromSeriesListResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromSeriesListResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeriesList, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromSeriesResponse_series(ctx context.Context, field graphql.CollectedField, obj *model.PromSeriesResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromSeriesResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromSeriesResponse_labelValues(ctx context.Context, field graphql.CollectedField, obj *model.PromSeriesResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromSeriesResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LabelValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.LabelValue)
	fc.Result = res
	return ec.marshalOLabelValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLabelValue(ctx, field.Selections, res)
}

func (ec *executionContext) _PrometheusDataResponse_metricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.PrometheusDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PrometheusDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricsPromResponse)
	fc.Result = res
	return ec.marshalOMetricsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PrometheusDataResponse_annotationsResponse(ctx context.Context, field graphql.CollectedField, obj *model.PrometheusDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PrometheusDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnnotationsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AnnotationsPromResponse)
	fc.Result = res
	return ec.marshalOAnnotationsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Provider_name(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Provider",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflows(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflows_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflows(rctx, args["request"].(model.ListWorkflowsRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListWorkflowsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListWorkflowsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListWorkflowsResponse)
	fc.Result = res
	return ec.marshalNListWorkflowsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflowRuns(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflowRuns_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflowRuns(rctx, args["request"].(model.ListWorkflowRunsRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListWorkflowRunsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListWorkflowRunsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListWorkflowRunsResponse)
	fc.Result = res
	return ec.marshalNListWorkflowRunsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowRunsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listHeatmapData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listHeatmapData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListHeatmapData(rctx, args["projectID"].(string), args["workflowID"].(string), args["year"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.HeatmapDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.HeatmapDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.HeatmapDataResponse)
	fc.Result = res
	return ec.marshalNHeatmapDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHeatmapDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflowStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflowStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflowStats(rctx, args["projectID"].(string), args["filter"].(model.TimeFrequency), args["showWorkflowRuns"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.WorkflowStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowStatsResponse)
	fc.Result = res
	return ec.marshalNWorkflowStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getWorkflowRunStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getWorkflowRunStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetWorkflowRunStats(rctx, args["workflowRunStatsRequest"].(model.WorkflowRunStatsRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WorkflowRunStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowRunStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowRunStatsResponse)
	fc.Result = res
	return ec.marshalNWorkflowRunStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListDataSource(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.DSResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DSResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DSResponse)
	fc.Result = res
	return ec.marshalNDSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPrometheusData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPrometheusData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPrometheusData(rctx, args["request"].(*model.PrometheusDataRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PrometheusDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PrometheusDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PrometheusDataResponse)
	fc.Result = res
	return ec.marshalNPrometheusDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPrometheusDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPromLabelNamesAndValues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPromLabelNamesAndValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPromLabelNamesAndValues(rctx, args["request"].(*model.PromSeriesInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PromSeriesResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PromSeriesResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PromSeriesResponse)
	fc.Result = res
	return ec.marshalNPromSeriesResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPromSeriesList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPromSeriesList_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPromSeriesList(rctx, args["request"].(*model.DsDetails))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PromSeriesListResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PromSeriesListResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PromSeriesListResponse)
	fc.Result = res
	return ec.marshalNPromSeriesListResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListDashboard(rctx, args["projectID"].(string), args["clusterID"].(*string), args["dbID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ListDashboardResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListDashboardResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ListDashboardResponse)
	fc.Result = res
	return ec.marshalOListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listPortalDashboardData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listPortalDashboardData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListPortalDashboardData(rctx, args["projectID"].(string), args["hubName"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PortalDashboardDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PortalDashboardDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PortalDashboardDataResponse)
	fc.Result = res
	return ec.marshalNPortalDashboardDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPortalDashboardDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getServerVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetServerVersion(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ServerVersionResponse)
	fc.Result = res
	return ec.marshalNServerVersionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelServerVersionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listClusters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listClusters_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListClusters(rctx, args["projectID"].(string), args["clusterType"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Cluster); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Cluster`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Cluster)
	fc.Result = res
	return ec.marshalNCluster2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCluster(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getAgentDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getAgentDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAgentDetails(rctx, args["clusterID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Cluster); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Cluster`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Cluster)
	fc.Result = res
	return ec.marshalNCluster2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCluster(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getManifest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getManifest_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetManifest(rctx, args["projectID"].(string), args["clusterID"].(string), args["accessKey"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getGitOpsDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getGitOpsDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetGitOpsDetails(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GitConfigResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.GitConfigResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GitConfigResponse)
	fc.Result = res
	return ec.marshalNGitConfigResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelGitConfigResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListImageRegistry(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalOImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listCharts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listCharts_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListCharts(rctx, args["hubName"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Chart); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Chart`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Chart)
	fc.Result = res
	return ec.marshalNChart2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChart(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getHubExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getHubExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetHubExperiment(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Chart); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Chart`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Chart)
	fc.Result = res
	return ec.marshalNChart2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChart(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listHubStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listHubStatus_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListHubStatus(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ChaosHubStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHubStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChaosHubStatus)
	fc.Result = res
	return ec.marshalNChaosHubStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHubStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getYAMLData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getYAMLData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetYAMLData(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetExperimentDetails(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ExperimentDetails); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ExperimentDetails`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ExperimentDetails)
	fc.Result = res
	return ec.marshalNExperimentDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listPredefinedWorkflows(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listPredefinedWorkflows_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListPredefinedWorkflows(rctx, args["hubName"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PredefinedWorkflowList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PredefinedWorkflowList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PredefinedWorkflowList)
	fc.Result = res
	return ec.marshalNPredefinedWorkflowList2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPredefinedWorkflowList(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPredefinedExperimentYAML(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPredefinedExperimentYAML_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPredefinedExperimentYaml(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getUsageData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getUsageData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUsageData(rctx, args["request"].(model.UsageDataRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UsageDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.UsageDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UsageDataResponse)
	fc.Result = res
	return ec.marshalNUsageDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflowManifests(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflowManifests_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflowManifests(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.WorkflowTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowTemplate)
	fc.Result = res
	return ec.marshalNWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getWorkflowManifestByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getWorkflowManifestByID_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetWorkflowManifestByID(rctx, args["projectID"].(string), args["templateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WorkflowTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowTemplate)
	fc.Result = res
	return ec.marshalNWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterClusterResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.RegisterClusterResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterClusterResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterClusterResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.RegisterClusterResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterClusterResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterClusterResponse_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.RegisterClusterResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterClusterResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ResourceResponse_kind(ctx context.Context, field graphql.CollectedField, obj *model.ResourceResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResourceResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ResourceResponse_names(ctx context.Context, field graphql.CollectedField, obj *model.ResourceResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResourceResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Names, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_publicKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_key(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_value(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_displayName(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_categoryDescription(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CategoryDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_keywords(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maturity(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maturity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maintainers(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_minKubeVersion(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinKubeVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_provider(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Provider)
	fc.Result = res
	return ec.marshalNProvider2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProvider(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_links(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Links, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Link)
	fc.Result = res
	return ec.marshalNLink2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLink(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_experiments(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosExpCRDLink(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosExpCRDLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_platforms(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platforms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosType(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SubData_date(ctx context.Context, field graphql.CollectedField, obj *model.SubData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SubData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _SubData_value(ctx context.Context, field graphql.CollectedField, obj *model.SubData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SubData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SubData_subDataName(ctx context.Context, field graphql.CollectedField, obj *model.SubData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SubData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubDataName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Subscription_getWorkflowEvents(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getWorkflowEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetWorkflowEvents(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.WorkflowRun); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowRun`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.WorkflowRun)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_viewDashboard(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_viewDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().ViewDashboard(rctx, args["dashboardID"].(*string), args["promQueries"].([]*model.PromQueryInput), args["dashboardQueryMap"].([]*model.QueryMapForPanelGroup), args["dataVariables"].(model.DataVars))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.DashboardPromResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DashboardPromResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.DashboardPromResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNDashboardPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDashboardPromResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getClusterEvents(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getClusterEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetClusterEvents(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.ClusterEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ClusterEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.ClusterEventResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNClusterEventResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterEventResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_clusterConnect(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_clusterConnect_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ClusterConnect(rctx, args["clusterInfo"].(model.ClusterIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.ClusterActionResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNClusterActionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterActionResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getPodLog(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getPodLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetPodLog(rctx, args["request"].(model.PodLogRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.PodLogResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PodLogResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.PodLogResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNPodLogResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPodLogResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getKubeObject(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getKubeObject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetKubeObject(rctx, args["request"].(model.KubeObjectRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.KubeObjectResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.KubeObjectResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.KubeObjectResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNKubeObjectResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeObjectResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _TotalCount_projects(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TotalCount_users(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TotalCount_agents(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AgentStat)
	fc.Result = res
	return ec.marshalNAgentStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAgentStat(ctx, field.Selections, res)
}

func (ec *executionContext) _TotalCount_workflows(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowStat)
	fc.Result = res
	return ec.marshalNWorkflowStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStat(ctx, field.Selections, res)
}

func (ec *executionContext) _UsageDataResponse_projects(ctx context.Context, field graphql.CollectedField, obj *model.UsageDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UsageDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ProjectData)
	fc.Result = res
	return ec.marshalNProjectData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProjectData(ctx, field.Selections, res)
}

func (ec *executionContext) _UsageDataResponse_totalEntries(ctx context.Context, field graphql.CollectedField, obj *model.UsageDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UsageDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _UsageDataResponse_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.UsageDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UsageDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TotalCount)
	fc.Result = res
	return ec.marshalNTotalCount2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTotalCount(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_weightage(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowID(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowManifest(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowDescription(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_weightages(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightages(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_isCustomWorkflow(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomWorkflow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_clusterType(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_workflowRunID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_workflowID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_weightages(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightages(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_projectID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_clusterType(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_phase(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_resiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsPassed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsFailed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsAwaited(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsAwaited, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsStopped(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsStopped, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsNa(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsNa, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_executionData(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_executedBy(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunDetails_noOfRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunDetails_dateStamp(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateStamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_totalWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_succeededWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SucceededWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_failedWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_runningWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunningWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_averageResiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AverageResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsPassed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsFailed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsAwaited(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsAwaited, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsStopped(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsStopped, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsNa(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsNa, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_passedPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PassedPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_failedPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_workflowRunSucceededPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunSucceededPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_workflowRunFailedPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunFailedPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunsData_value(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunsData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunsData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunsData_workflowRunDetail(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunsData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunsData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunDetail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowRunDetails)
	fc.Result = res
	return ec.marshalOWorkflowRunDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStat_schedules(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schedules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStat_runs(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStat_expRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStatsResponse_date(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStatsResponse_value(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_templateID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_manifest(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_templateName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemplateName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_templateDescription(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemplateDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_projectID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_projectName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_isCustomWorkflow(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomWorkflow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputApplicationMetadata(ctx context.Context, obj interface{}) (model.ApplicationMetadata, error) {
	var it model.ApplicationMetadata
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "namespace":
			var err error
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "applications":
			var err error
			it.Applications, err = ec.unmarshalOResource2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResource(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChaosWorkFlowRequest(ctx context.Context, obj interface{}) (model.ChaosWorkFlowRequest, error) {
	var it model.ChaosWorkFlowRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowID":
			var err error
			it.WorkflowID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowManifest":
			var err error
			it.WorkflowManifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cronSyntax":
			var err error
			it.CronSyntax, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowDescription":
			var err error
			it.WorkflowDescription, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightages":
			var err error
			it.Weightages, err = ec.unmarshalNWeightagesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightagesInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "isCustomWorkflow":
			var err error
			it.IsCustomWorkflow, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCloningInput(ctx context.Context, obj interface{}) (model.CloningInput, error) {
	var it model.CloningInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputClusterIdentity(ctx context.Context, obj interface{}) (model.ClusterIdentity, error) {
	var it model.ClusterIdentity
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChaosHubRequest(ctx context.Context, obj interface{}) (model.CreateChaosHubRequest, error) {
	var it model.CreateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDBInput(ctx context.Context, obj interface{}) (model.CreateDBInput, error) {
	var it model.CreateDBInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbName":
			var err error
			it.DbName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeName":
			var err error
			it.DbTypeName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeID":
			var err error
			it.DbTypeID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbInformation":
			var err error
			it.DbInformation, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosEventQueryTemplate":
			var err error
			it.ChaosEventQueryTemplate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosVerdictQueryTemplate":
			var err error
			it.ChaosVerdictQueryTemplate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "applicationMetadataMap":
			var err error
			it.ApplicationMetadataMap, err = ec.unmarshalOApplicationMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadata(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroups":
			var err error
			it.PanelGroups, err = ec.unmarshalNPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroup(ctx, v)
			if err != nil {
				return it, err
			}
		case "endTime":
			var err error
			it.EndTime, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "refreshRate":
			var err error
			it.RefreshRate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRemoteMyHub(ctx context.Context, obj interface{}) (model.CreateRemoteMyHub, error) {
	var it model.CreateRemoteMyHub
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDSInput(ctx context.Context, obj interface{}) (model.DSInput, error) {
	var it model.DSInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsName":
			var err error
			it.DsName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsType":
			var err error
			it.DsType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsURL":
			var err error
			it.DsURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessType":
			var err error
			it.AccessType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "basicAuthUsername":
			var err error
			it.BasicAuthUsername, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "basicAuthPassword":
			var err error
			it.BasicAuthPassword, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "scrapeInterval":
			var err error
			it.ScrapeInterval, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "queryTimeout":
			var err error
			it.QueryTimeout, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "httpMethod":
			var err error
			it.HTTPMethod, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataVars(ctx context.Context, obj interface{}) (model.DataVars, error) {
	var it model.DataVars
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "url":
			var err error
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "start":
			var err error
			it.Start, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "end":
			var err error
			it.End, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "relativeTime":
			var err error
			it.RelativeTime, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "refreshInterval":
			var err error
			it.RefreshInterval, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateRange(ctx context.Context, obj interface{}) (model.DateRange, error) {
	var it model.DateRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDSInput(ctx context.Context, obj interface{}) (model.DeleteDSInput, error) {
	var it model.DeleteDSInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "forceDelete":
			var err error
			it.ForceDelete, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDsDetails(ctx context.Context, obj interface{}) (model.DsDetails, error) {
	var it model.DsDetails
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "url":
			var err error
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "start":
			var err error
			it.Start, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "end":
			var err error
			it.End, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRequest(ctx context.Context, obj interface{}) (model.ExperimentRequest, error) {
	var it model.ExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chartName":
			var err error
			it.ChartName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fileType":
			var err error
			it.FileType, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitConfig(ctx context.Context, obj interface{}) (model.GitConfig, error) {
	var it model.GitConfig
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "branch":
			var err error
			it.Branch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageRegistryInput(ctx context.Context, obj interface{}) (model.ImageRegistryInput, error) {
	var it model.ImageRegistryInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "isDefault":
			var err error
			it.IsDefault, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryName":
			var err error
			it.ImageRegistryName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRepoName":
			var err error
			it.ImageRepoName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryType":
			var err error
			it.ImageRegistryType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretName":
			var err error
			it.SecretName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretNamespace":
			var err error
			it.SecretNamespace, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "enableRegistry":
			var err error
			it.EnableRegistry, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeGVRRequest(ctx context.Context, obj interface{}) (model.KubeGVRRequest, error) {
	var it model.KubeGVRRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "group":
			var err error
			it.Group, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectData(ctx context.Context, obj interface{}) (model.KubeObjectData, error) {
	var it model.KubeObjectData
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObj":
			var err error
			it.KubeObj, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectRequest(ctx context.Context, obj interface{}) (model.KubeObjectRequest, error) {
	var it model.KubeObjectRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "objectType":
			var err error
			it.ObjectType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObjRequest":
			var err error
			it.KubeObjRequest, err = ec.unmarshalNKubeGVRRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeGVRRequest(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListWorkflowRunsRequest(ctx context.Context, obj interface{}) (model.ListWorkflowRunsRequest, error) {
	var it model.ListWorkflowRunsRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunIDs":
			var err error
			it.WorkflowRunIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowIDs":
			var err error
			it.WorkflowIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOWorkflowRunSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOWorkflowRunFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListWorkflowsRequest(ctx context.Context, obj interface{}) (model.ListWorkflowsRequest, error) {
	var it model.ListWorkflowsRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowIDs":
			var err error
			it.WorkflowIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOWorkflowSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOWorkflowFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewClusterEventRequest(ctx context.Context, obj interface{}) (model.NewClusterEventRequest, error) {
	var it model.NewClusterEventRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eventName":
			var err error
			it.EventName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj interface{}) (model.Pagination, error) {
	var it model.Pagination
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "page":
			var err error
			it.Page, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPanel(ctx context.Context, obj interface{}) (model.Panel, error) {
	var it model.Panel
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelID":
			var err error
			it.PanelID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbID":
			var err error
			it.DbID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "yAxisLeft":
			var err error
			it.YAxisLeft, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "yAxisRight":
			var err error
			it.YAxisRight, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "xAxisDown":
			var err error
			it.XAxisDown, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unit":
			var err error
			it.Unit, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroupID":
			var err error
			it.PanelGroupID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "promQueries":
			var err error
			it.PromQueries, err = ec.unmarshalOPromQuery2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQuery(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelOptions":
			var err error
			it.PanelOptions, err = ec.unmarshalOPanelOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelOption(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelName":
			var err error
			it.PanelName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPanelGroup(ctx context.Context, obj interface{}) (model.PanelGroup, error) {
	var it model.PanelGroup
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panels":
			var err error
			it.Panels, err = ec.unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroupName":
			var err error
			it.PanelGroupName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPanelOption(ctx context.Context, obj interface{}) (model.PanelOption, error) {
	var it model.PanelOption
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "points":
			var err error
			it.Points, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "grIDs":
			var err error
			it.GrIDs, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "leftAxis":
			var err error
			it.LeftAxis, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLog(ctx context.Context, obj interface{}) (model.PodLog, error) {
	var it model.PodLog
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunID":
			var err error
			it.WorkflowRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "log":
			var err error
			it.Log, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLogRequest(ctx context.Context, obj interface{}) (model.PodLogRequest, error) {
	var it model.PodLogRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunID":
			var err error
			it.WorkflowRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podNamespace":
			var err error
			it.PodNamespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expPod":
			var err error
			it.ExpPod, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runnerPod":
			var err error
			it.RunnerPod, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosNamespace":
			var err error
			it.ChaosNamespace, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromQuery(ctx context.Context, obj interface{}) (model.PromQuery, error) {
	var it model.PromQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "queryID":
			var err error
			it.QueryID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "promQueryName":
			var err error
			it.PromQueryName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "legend":
			var err error
			it.Legend, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resolution":
			var err error
			it.Resolution, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minstep":
			var err error
			it.Minstep, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "line":
			var err error
			it.Line, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "closeArea":
			var err error
			it.CloseArea, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromQueryInput(ctx context.Context, obj interface{}) (model.PromQueryInput, error) {
	var it model.PromQueryInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "queryID":
			var err error
			it.QueryID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "query":
			var err error
			it.Query, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "legend":
			var err error
			it.Legend, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resolution":
			var err error
			it.Resolution, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minstep":
			var err error
			it.Minstep, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromSeriesInput(ctx context.Context, obj interface{}) (model.PromSeriesInput, error) {
	var it model.PromSeriesInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "series":
			var err error
			it.Series, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsDetails":
			var err error
			it.DsDetails, err = ec.unmarshalNDsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPrometheusDataRequest(ctx context.Context, obj interface{}) (model.PrometheusDataRequest, error) {
	var it model.PrometheusDataRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "queries":
			var err error
			it.Queries, err = ec.unmarshalOPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsDetails":
			var err error
			it.DsDetails, err = ec.unmarshalNDsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQueryMapForPanel(ctx context.Context, obj interface{}) (model.QueryMapForPanel, error) {
	var it model.QueryMapForPanel
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelID":
			var err error
			it.PanelID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "queryIDs":
			var err error
			it.QueryIDs, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQueryMapForPanelGroup(ctx context.Context, obj interface{}) (model.QueryMapForPanelGroup, error) {
	var it model.QueryMapForPanelGroup
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelGroupID":
			var err error
			it.PanelGroupID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelQueryMap":
			var err error
			it.PanelQueryMap, err = ec.unmarshalNQueryMapForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanel(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegisterClusterRequest(ctx context.Context, obj interface{}) (model.RegisterClusterRequest, error) {
	var it model.RegisterClusterRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterName":
			var err error
			it.ClusterName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName":
			var err error
			it.PlatformName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterType":
			var err error
			it.ClusterType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentNamespace":
			var err error
			it.AgentNamespace, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serviceAccount":
			var err error
			it.ServiceAccount, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentScope":
			var err error
			it.AgentScope, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentNsExists":
			var err error
			it.AgentNsExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentSaExists":
			var err error
			it.AgentSaExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipSsl":
			var err error
			it.SkipSsl, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeSelector":
			var err error
			it.NodeSelector, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tolerations":
			var err error
			it.Tolerations, err = ec.unmarshalOToleration2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelToleration(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResource(ctx context.Context, obj interface{}) (model.Resource, error) {
	var it model.Resource
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "kind":
			var err error
			it.Kind, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "names":
			var err error
			it.Names, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTemplateInput(ctx context.Context, obj interface{}) (model.TemplateInput, error) {
	var it model.TemplateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "manifest":
			var err error
			it.Manifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "templateName":
			var err error
			it.TemplateName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "templateDescription":
			var err error
			it.TemplateDescription, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isCustomWorkflow":
			var err error
			it.IsCustomWorkflow, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToleration(ctx context.Context, obj interface{}) (model.Toleration, error) {
	var it model.Toleration
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tolerationSeconds":
			var err error
			it.TolerationSeconds, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "key":
			var err error
			it.Key, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "operator":
			var err error
			it.Operator, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "effect":
			var err error
			it.Effect, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateChaosHubRequest(ctx context.Context, obj interface{}) (model.UpdateChaosHubRequest, error) {
	var it model.UpdateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDBInput(ctx context.Context, obj interface{}) (model.UpdateDBInput, error) {
	var it model.UpdateDBInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "dbID":
			var err error
			it.DbID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbName":
			var err error
			it.DbName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeName":
			var err error
			it.DbTypeName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeID":
			var err error
			it.DbTypeID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbInformation":
			var err error
			it.DbInformation, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosEventQueryTemplate":
			var err error
			it.ChaosEventQueryTemplate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosVerdictQueryTemplate":
			var err error
			it.ChaosVerdictQueryTemplate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "applicationMetadataMap":
			var err error
			it.ApplicationMetadataMap, err = ec.unmarshalOApplicationMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadata(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroups":
			var err error
			it.PanelGroups, err = ec.unmarshalOUpdatePanelGroupInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdatePanelGroupInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "endTime":
			var err error
			it.EndTime, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "refreshRate":
			var err error
			it.RefreshRate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePanelGroupInput(ctx context.Context, obj interface{}) (model.UpdatePanelGroupInput, error) {
	var it model.UpdatePanelGroupInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelGroupName":
			var err error
			it.PanelGroupName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroupID":
			var err error
			it.PanelGroupID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "panels":
			var err error
			it.Panels, err = ec.unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUsageDataRequest(ctx context.Context, obj interface{}) (model.UsageDataRequest, error) {
	var it model.UsageDataRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalNDateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOUsageSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "searchProject":
			var err error
			it.SearchProject, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUsageSortInput(ctx context.Context, obj interface{}) (model.UsageSortInput, error) {
	var it model.UsageSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNUsageSort2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageSort(ctx, v)
			if err != nil {
				return it, err
			}
		case "descending":
			var err error
			it.Descending, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeightagesInput(ctx context.Context, obj interface{}) (model.WeightagesInput, error) {
	var it model.WeightagesInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightage":
			var err error
			it.Weightage, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowFilterInput(ctx context.Context, obj interface{}) (model.WorkflowFilterInput, error) {
	var it model.WorkflowFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterName":
			var err error
			it.ClusterName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunFilterInput(ctx context.Context, obj interface{}) (model.WorkflowRunFilterInput, error) {
	var it model.WorkflowRunFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterName":
			var err error
			it.ClusterName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowStatus":
			var err error
			it.WorkflowStatus, err = ec.unmarshalOWorkflowRunStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalODateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunRequest(ctx context.Context, obj interface{}) (model.WorkflowRunRequest, error) {
	var it model.WorkflowRunRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowID":
			var err error
			it.WorkflowID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunID":
			var err error
			it.WorkflowRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "executedBy":
			var err error
			it.ExecutedBy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "executionData":
			var err error
			it.ExecutionData, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "completed":
			var err error
			it.Completed, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isRemoved":
			var err error
			it.IsRemoved, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunSortInput(ctx context.Context, obj interface{}) (model.WorkflowRunSortInput, error) {
	var it model.WorkflowRunSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNWorkflowSortingField2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "descending":
			var err error
			it.Descending, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunStatsRequest(ctx context.Context, obj interface{}) (model.WorkflowRunStatsRequest, error) {
	var it model.WorkflowRunStatsRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowIDs":
			var err error
			it.WorkflowIDs, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowSortInput(ctx context.Context, obj interface{}) (model.WorkflowSortInput, error) {
	var it model.WorkflowSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNWorkflowSortingField2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "descending":
			var err error
			it.Descending, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actionPayloadImplementors = []string{"ActionPayload"}

func (ec *executionContext) _ActionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ActionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionPayload")
		case "requestType":
			out.Values[i] = ec._ActionPayload_requestType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "k8sManifest":
			out.Values[i] = ec._ActionPayload_k8sManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "namespace":
			out.Values[i] = ec._ActionPayload_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "externalData":
			out.Values[i] = ec._ActionPayload_externalData(ctx, field, obj)
		case "username":
			out.Values[i] = ec._ActionPayload_username(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentStatImplementors = []string{"AgentStat"}

func (ec *executionContext) _AgentStat(ctx context.Context, sel ast.SelectionSet, obj *model.AgentStat) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentStatImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentStat")
		case "ns":
			out.Values[i] = ec._AgentStat_ns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cluster":
			out.Values[i] = ec._AgentStat_cluster(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "total":
			out.Values[i] = ec._AgentStat_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "active":
			out.Values[i] = ec._AgentStat_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.Annotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "categories":
			out.Values[i] = ec._Annotation_categories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "vendor":
			out.Values[i] = ec._Annotation_vendor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Annotation_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repository":
			out.Values[i] = ec._Annotation_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "support":
			out.Values[i] = ec._Annotation_support(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chartDescription":
			out.Values[i] = ec._Annotation_chartDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationsPromResponseImplementors = []string{"AnnotationsPromResponse"}

func (ec *executionContext) _AnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AnnotationsPromResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationsPromResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnnotationsPromResponse")
		case "queryID":
			out.Values[i] = ec._AnnotationsPromResponse_queryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "legends":
			out.Values[i] = ec._AnnotationsPromResponse_legends(ctx, field, obj)
		case "tsvs":
			out.Values[i] = ec._AnnotationsPromResponse_tsvs(ctx, field, obj)
		case "subDataArray":
			out.Values[i] = ec._AnnotationsPromResponse_subDataArray(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationsTimeStampValueImplementors = []string{"AnnotationsTimeStampValue"}

func (ec *executionContext) _AnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, obj *model.AnnotationsTimeStampValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationsTimeStampValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnnotationsTimeStampValue")
		case "date":
			out.Values[i] = ec._AnnotationsTimeStampValue_date(ctx, field, obj)
		case "value":
			out.Values[i] = ec._AnnotationsTimeStampValue_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationMetadataResponseImplementors = []string{"ApplicationMetadataResponse"}

func (ec *executionContext) _ApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationMetadataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationMetadataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMetadataResponse")
		case "namespace":
			out.Values[i] = ec._ApplicationMetadataResponse_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "applications":
			out.Values[i] = ec._ApplicationMetadataResponse_applications(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubImplementors = []string{"ChaosHub"}

func (ec *executionContext) _ChaosHub(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHub) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHub")
		case "id":
			out.Values[i] = ec._ChaosHub_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHub_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHub_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ChaosHub_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubName":
			out.Values[i] = ec._ChaosHub_hubName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubType":
			out.Values[i] = ec._ChaosHub_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHub_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHub_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHub_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHub_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHub_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHub_sshPrivateKey(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHub_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ChaosHub_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ChaosHub_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHub_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubStatusImplementors = []string{"ChaosHubStatus"}

func (ec *executionContext) _ChaosHubStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHubStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubStatusImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHubStatus")
		case "id":
			out.Values[i] = ec._ChaosHubStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHubStatus_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHubStatus_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isAvailable":
			out.Values[i] = ec._ChaosHubStatus_isAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExp":
			out.Values[i] = ec._ChaosHubStatus_totalExp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubName":
			out.Values[i] = ec._ChaosHubStatus_hubName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubType":
			out.Values[i] = ec._ChaosHubStatus_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHubStatus_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHubStatus_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHubStatus_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHubStatus_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHubStatus_password(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHubStatus_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHubStatus_sshPrivateKey(ctx, field, obj)
		case "sshPublicKey":
			out.Values[i] = ec._ChaosHubStatus_sshPublicKey(ctx, field, obj)
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHubStatus_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosWorkFlowResponseImplementors = []string{"ChaosWorkFlowResponse"}

func (ec *executionContext) _ChaosWorkFlowResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosWorkFlowResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosWorkFlowResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosWorkFlowResponse")
		case "workflowID":
			out.Values[i] = ec._ChaosWorkFlowResponse_workflowID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._ChaosWorkFlowResponse_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowName":
			out.Values[i] = ec._ChaosWorkFlowResponse_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowDescription":
			out.Values[i] = ec._ChaosWorkFlowResponse_workflowDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomWorkflow":
			out.Values[i] = ec._ChaosWorkFlowResponse_isCustomWorkflow(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chartImplementors = []string{"Chart"}

func (ec *executionContext) _Chart(ctx context.Context, sel ast.SelectionSet, obj *model.Chart) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chartImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Chart")
		case "apiVersion":
			out.Values[i] = ec._Chart_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kind":
			out.Values[i] = ec._Chart_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._Chart_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._Chart_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "packageInfo":
			out.Values[i] = ec._Chart_packageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clusterImplementors = []string{"Cluster"}

func (ec *executionContext) _Cluster(ctx context.Context, sel ast.SelectionSet, obj *model.Cluster) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clusterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Cluster")
		case "clusterID":
			out.Values[i] = ec._Cluster_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._Cluster_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._Cluster_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Cluster_description(ctx, field, obj)
		case "platformName":
			out.Values[i] = ec._Cluster_platformName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "accessKey":
			out.Values[i] = ec._Cluster_accessKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRegistered":
			out.Values[i] = ec._Cluster_isRegistered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isClusterConfirmed":
			out.Values[i] = ec._Cluster_isClusterConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isActive":
			out.Values[i] = ec._Cluster_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Cluster_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Cluster_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterType":
			out.Values[i] = ec._Cluster_clusterType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "noOfSchedules":
			out.Values[i] = ec._Cluster_noOfSchedules(ctx, field, obj)
		case "noOfWorkflows":
			out.Values[i] = ec._Cluster_noOfWorkflows(ctx, field, obj)
		case "token":
			out.Values[i] = ec._Cluster_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agentNamespace":
			out.Values[i] = ec._Cluster_agentNamespace(ctx, field, obj)
		case "serviceAccount":
			out.Values[i] = ec._Cluster_serviceAccount(ctx, field, obj)
		case "agentScope":
			out.Values[i] = ec._Cluster_agentScope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agentNsExists":
			out.Values[i] = ec._Cluster_agentNsExists(ctx, field, obj)
		case "agentSaExists":
			out.Values[i] = ec._Cluster_agentSaExists(ctx, field, obj)
		case "lastWorkflowTimestamp":
			out.Values[i] = ec._Cluster_lastWorkflowTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startTime":
			out.Values[i] = ec._Cluster_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Cluster_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clusterActionResponseImplementors = []string{"ClusterActionResponse"}

func (ec *executionContext) _ClusterActionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ClusterActionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clusterActionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterActionResponse")
		case "projectID":
			out.Values[i] = ec._ClusterActionResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "action":
			out.Values[i] = ec._ClusterActionResponse_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clusterEventResponseImplementors = []string{"ClusterEventResponse"}

func (ec *executionContext) _ClusterEventResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ClusterEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clusterEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterEventResponse")
		case "eventID":
			out.Values[i] = ec._ClusterEventResponse_eventID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":
			out.Values[i] = ec._ClusterEventResponse_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventName":
			out.Values[i] = ec._ClusterEventResponse_eventName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._ClusterEventResponse_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cluster":
			out.Values[i] = ec._ClusterEventResponse_cluster(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var confirmClusterRegistrationResponseImplementors = []string{"ConfirmClusterRegistrationResponse"}

func (ec *executionContext) _ConfirmClusterRegistrationResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ConfirmClusterRegistrationResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, confirmClusterRegistrationResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfirmClusterRegistrationResponse")
		case "isClusterConfirmed":
			out.Values[i] = ec._ConfirmClusterRegistrationResponse_isClusterConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newAccessKey":
			out.Values[i] = ec._ConfirmClusterRegistrationResponse_newAccessKey(ctx, field, obj)
		case "clusterID":
			out.Values[i] = ec._ConfirmClusterRegistrationResponse_clusterID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dSResponseImplementors = []string{"DSResponse"}

func (ec *executionContext) _DSResponse(ctx context.Context, sel ast.SelectionSet, obj *model.DSResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dSResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DSResponse")
		case "dsID":
			out.Values[i] = ec._DSResponse_dsID(ctx, field, obj)
		case "dsName":
			out.Values[i] = ec._DSResponse_dsName(ctx, field, obj)
		case "dsType":
			out.Values[i] = ec._DSResponse_dsType(ctx, field, obj)
		case "dsURL":
			out.Values[i] = ec._DSResponse_dsURL(ctx, field, obj)
		case "accessType":
			out.Values[i] = ec._DSResponse_accessType(ctx, field, obj)
		case "authType":
			out.Values[i] = ec._DSResponse_authType(ctx, field, obj)
		case "basicAuthUsername":
			out.Values[i] = ec._DSResponse_basicAuthUsername(ctx, field, obj)
		case "basicAuthPassword":
			out.Values[i] = ec._DSResponse_basicAuthPassword(ctx, field, obj)
		case "scrapeInterval":
			out.Values[i] = ec._DSResponse_scrapeInterval(ctx, field, obj)
		case "queryTimeout":
			out.Values[i] = ec._DSResponse_queryTimeout(ctx, field, obj)
		case "httpMethod":
			out.Values[i] = ec._DSResponse_httpMethod(ctx, field, obj)
		case "projectID":
			out.Values[i] = ec._DSResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "healthStatus":
			out.Values[i] = ec._DSResponse_healthStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._DSResponse_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._DSResponse_updatedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dashboardPromResponseImplementors = []string{"DashboardPromResponse"}

func (ec *executionContext) _DashboardPromResponse(ctx context.Context, sel ast.SelectionSet, obj *model.DashboardPromResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dashboardPromResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DashboardPromResponse")
		case "dashboardMetricsResponse":
			out.Values[i] = ec._DashboardPromResponse_dashboardMetricsResponse(ctx, field, obj)
		case "annotationsResponse":
			out.Values[i] = ec._DashboardPromResponse_annotationsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentDetailsImplementors = []string{"ExperimentDetails"}

func (ec *executionContext) _ExperimentDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ExperimentDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentDetails")
		case "engineDetails":
			out.Values[i] = ec._ExperimentDetails_engineDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentDetails":
			out.Values[i] = ec._ExperimentDetails_experimentDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentsImplementors = []string{"Experiments"}

func (ec *executionContext) _Experiments(ctx context.Context, sel ast.SelectionSet, obj *model.Experiments) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiments")
		case "name":
			out.Values[i] = ec._Experiments_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CSV":
			out.Values[i] = ec._Experiments_CSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "desc":
			out.Values[i] = ec._Experiments_desc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitConfigResponseImplementors = []string{"GitConfigResponse"}

func (ec *executionContext) _GitConfigResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GitConfigResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitConfigResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitConfigResponse")
		case "enabled":
			out.Values[i] = ec._GitConfigResponse_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._GitConfigResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "branch":
			out.Values[i] = ec._GitConfigResponse_branch(ctx, field, obj)
		case "repoURL":
			out.Values[i] = ec._GitConfigResponse_repoURL(ctx, field, obj)
		case "authType":
			out.Values[i] = ec._GitConfigResponse_authType(ctx, field, obj)
		case "token":
			out.Values[i] = ec._GitConfigResponse_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._GitConfigResponse_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._GitConfigResponse_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._GitConfigResponse_sshPrivateKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var heatmapDataResponseImplementors = []string{"HeatmapDataResponse"}

func (ec *executionContext) _HeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.HeatmapDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, heatmapDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HeatmapDataResponse")
		case "bins":
			out.Values[i] = ec._HeatmapDataResponse_bins(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryImplementors = []string{"ImageRegistry"}

func (ec *executionContext) _ImageRegistry(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistry")
		case "isDefault":
			out.Values[i] = ec._ImageRegistry_isDefault(ctx, field, obj)
		case "imageRegistryName":
			out.Values[i] = ec._ImageRegistry_imageRegistryName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRepoName":
			out.Values[i] = ec._ImageRegistry_imageRepoName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryType":
			out.Values[i] = ec._ImageRegistry_imageRegistryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "secretName":
			out.Values[i] = ec._ImageRegistry_secretName(ctx, field, obj)
		case "secretNamespace":
			out.Values[i] = ec._ImageRegistry_secretNamespace(ctx, field, obj)
		case "enableRegistry":
			out.Values[i] = ec._ImageRegistry_enableRegistry(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryResponseImplementors = []string{"ImageRegistryResponse"}

func (ec *executionContext) _ImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistryResponse")
		case "isDefault":
			out.Values[i] = ec._ImageRegistryResponse_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryInfo":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryInfo(ctx, field, obj)
		case "imageRegistryID":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ImageRegistryResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ImageRegistryResponse_updatedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ImageRegistryResponse_createdAt(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ImageRegistryResponse_isRemoved(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kubeObjectResponseImplementors = []string{"KubeObjectResponse"}

func (ec *executionContext) _KubeObjectResponse(ctx context.Context, sel ast.SelectionSet, obj *model.KubeObjectResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kubeObjectResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeObjectResponse")
		case "clusterID":
			out.Values[i] = ec._KubeObjectResponse_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._KubeObjectResponse_kubeObj(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var labelValueImplementors = []string{"LabelValue"}

func (ec *executionContext) _LabelValue(ctx context.Context, sel ast.SelectionSet, obj *model.LabelValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelValue")
		case "label":
			out.Values[i] = ec._LabelValue_label(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "values":
			out.Values[i] = ec._LabelValue_values(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var linkImplementors = []string{"Link"}

func (ec *executionContext) _Link(ctx context.Context, sel ast.SelectionSet, obj *model.Link) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linkImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Link")
		case "name":
			out.Values[i] = ec._Link_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Link_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listDashboardResponseImplementors = []string{"ListDashboardResponse"}

func (ec *executionContext) _ListDashboardResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListDashboardResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listDashboardResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListDashboardResponse")
		case "dsID":
			out.Values[i] = ec._ListDashboardResponse_dsID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbID":
			out.Values[i] = ec._ListDashboardResponse_dbID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbName":
			out.Values[i] = ec._ListDashboardResponse_dbName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbTypeID":
			out.Values[i] = ec._ListDashboardResponse_dbTypeID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbTypeName":
			out.Values[i] = ec._ListDashboardResponse_dbTypeName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbInformation":
			out.Values[i] = ec._ListDashboardResponse_dbInformation(ctx, field, obj)
		case "chaosEventQueryTemplate":
			out.Values[i] = ec._ListDashboardResponse_chaosEventQueryTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosVerdictQueryTemplate":
			out.Values[i] = ec._ListDashboardResponse_chaosVerdictQueryTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "applicationMetadataMap":
			out.Values[i] = ec._ListDashboardResponse_applicationMetadataMap(ctx, field, obj)
		case "clusterName":
			out.Values[i] = ec._ListDashboardResponse_clusterName(ctx, field, obj)
		case "dsName":
			out.Values[i] = ec._ListDashboardResponse_dsName(ctx, field, obj)
		case "dsType":
			out.Values[i] = ec._ListDashboardResponse_dsType(ctx, field, obj)
		case "dsURL":
			out.Values[i] = ec._ListDashboardResponse_dsURL(ctx, field, obj)
		case "dsHealthStatus":
			out.Values[i] = ec._ListDashboardResponse_dsHealthStatus(ctx, field, obj)
		case "panelGroups":
			out.Values[i] = ec._ListDashboardResponse_panelGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endTime":
			out.Values[i] = ec._ListDashboardResponse_endTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startTime":
			out.Values[i] = ec._ListDashboardResponse_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "refreshRate":
			out.Values[i] = ec._ListDashboardResponse_refreshRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ListDashboardResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._ListDashboardResponse_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ListDashboardResponse_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._ListDashboardResponse_updatedAt(ctx, field, obj)
		case "viewedAt":
			out.Values[i] = ec._ListDashboardResponse_viewedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listWorkflowRunsResponseImplementors = []string{"ListWorkflowRunsResponse"}

func (ec *executionContext) _ListWorkflowRunsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListWorkflowRunsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listWorkflowRunsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListWorkflowRunsResponse")
		case "totalNoOfWorkflowRuns":
			out.Values[i] = ec._ListWorkflowRunsResponse_totalNoOfWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowRuns":
			out.Values[i] = ec._ListWorkflowRunsResponse_workflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listWorkflowsResponseImplementors = []string{"ListWorkflowsResponse"}

func (ec *executionContext) _ListWorkflowsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListWorkflowsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listWorkflowsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListWorkflowsResponse")
		case "totalNoOfWorkflows":
			out.Values[i] = ec._ListWorkflowsResponse_totalNoOfWorkflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflows":
			out.Values[i] = ec._ListWorkflowsResponse_workflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *model.Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "name":
			out.Values[i] = ec._Maintainer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._Maintainer_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metadataImplementors = []string{"Metadata"}

func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *model.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Metadata_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricDataForPanelImplementors = []string{"MetricDataForPanel"}

func (ec *executionContext) _MetricDataForPanel(ctx context.Context, sel ast.SelectionSet, obj *model.MetricDataForPanel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricDataForPanelImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricDataForPanel")
		case "panelID":
			out.Values[i] = ec._MetricDataForPanel_panelID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "panelMetricsResponse":
			out.Values[i] = ec._MetricDataForPanel_panelMetricsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricDataForPanelGroupImplementors = []string{"MetricDataForPanelGroup"}

func (ec *executionContext) _MetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, obj *model.MetricDataForPanelGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricDataForPanelGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricDataForPanelGroup")
		case "panelGroupID":
			out.Values[i] = ec._MetricDataForPanelGroup_panelGroupID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "panelGroupMetricsResponse":
			out.Values[i] = ec._MetricDataForPanelGroup_panelGroupMetricsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricsPromResponseImplementors = []string{"MetricsPromResponse"}

func (ec *executionContext) _MetricsPromResponse(ctx context.Context, sel ast.SelectionSet, obj *model.MetricsPromResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsPromResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricsPromResponse")
		case "queryID":
			out.Values[i] = ec._MetricsPromResponse_queryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "legends":
			out.Values[i] = ec._MetricsPromResponse_legends(ctx, field, obj)
		case "tsvs":
			out.Values[i] = ec._MetricsPromResponse_tsvs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricsTimeStampValueImplementors = []string{"MetricsTimeStampValue"}

func (ec *executionContext) _MetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, obj *model.MetricsTimeStampValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsTimeStampValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricsTimeStampValue")
		case "date":
			out.Values[i] = ec._MetricsTimeStampValue_date(ctx, field, obj)
		case "value":
			out.Values[i] = ec._MetricsTimeStampValue_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createChaosWorkFlow":
			out.Values[i] = ec._Mutation_createChaosWorkFlow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "reRunChaosWorkFlow":
			out.Values[i] = ec._Mutation_reRunChaosWorkFlow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosWorkflow":
			out.Values[i] = ec._Mutation_updateChaosWorkflow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosWorkflow":
			out.Values[i] = ec._Mutation_deleteChaosWorkflow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "terminateChaosWorkflow":
			out.Values[i] = ec._Mutation_terminateChaosWorkflow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosWorkflowRun":
			out.Values[i] = ec._Mutation_chaosWorkflowRun(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "syncWorkflowRun":
			out.Values[i] = ec._Mutation_syncWorkflowRun(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDataSource":
			out.Values[i] = ec._Mutation_createDataSource(ctx, field)
		case "createDashBoard":
			out.Values[i] = ec._Mutation_createDashBoard(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateDataSource":
			out.Values[i] = ec._Mutation_updateDataSource(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateDashboard":
			out.Values[i] = ec._Mutation_updateDashboard(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePanel":
			out.Values[i] = ec._Mutation_updatePanel(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDashboard":
			out.Values[i] = ec._Mutation_deleteDashboard(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDataSource":
			out.Values[i] = ec._Mutation_deleteDataSource(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "registerCluster":
			out.Values[i] = ec._Mutation_registerCluster(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "confirmClusterRegistration":
			out.Values[i] = ec._Mutation_confirmClusterRegistration(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newClusterEvent":
			out.Values[i] = ec._Mutation_newClusterEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteClusters":
			out.Values[i] = ec._Mutation_deleteClusters(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podLog":
			out.Values[i] = ec._Mutation_podLog(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._Mutation_kubeObj(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gitopsNotifier":
			out.Values[i] = ec._Mutation_gitopsNotifier(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "enableGitOps":
			out.Values[i] = ec._Mutation_enableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "disableGitOps":
			out.Values[i] = ec._Mutation_disableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateGitOps":
			out.Values[i] = ec._Mutation_updateGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createImageRegistry":
			out.Values[i] = ec._Mutation_createImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateImageRegistry":
			out.Values[i] = ec._Mutation_updateImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteImageRegistry":
			out.Values[i] = ec._Mutation_deleteImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addChaosHub":
			out.Values[i] = ec._Mutation_addChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addRemoteChaosHub":
			out.Values[i] = ec._Mutation_addRemoteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveChaosHub":
			out.Values[i] = ec._Mutation_saveChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "syncChaosHub":
			out.Values[i] = ec._Mutation_syncChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "generateSSHKey":
			out.Values[i] = ec._Mutation_generateSSHKey(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosHub":
			out.Values[i] = ec._Mutation_updateChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosHub":
			out.Values[i] = ec._Mutation_deleteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createWorkflowTemplate":
			out.Values[i] = ec._Mutation_createWorkflowTemplate(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteWorkflowTemplate":
			out.Values[i] = ec._Mutation_deleteWorkflowTemplate(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var optionImplementors = []string{"Option"}

func (ec *executionContext) _Option(ctx context.Context, sel ast.SelectionSet, obj *model.Option) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, optionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Option")
		case "name":
			out.Values[i] = ec._Option_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageInformationImplementors = []string{"PackageInformation"}

func (ec *executionContext) _PackageInformation(ctx context.Context, sel ast.SelectionSet, obj *model.PackageInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageInformation")
		case "packageName":
			out.Values[i] = ec._PackageInformation_packageName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._PackageInformation_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var panelGroupResponseImplementors = []string{"PanelGroupResponse"}

func (ec *executionContext) _PanelGroupResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PanelGroupResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, panelGroupResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PanelGroupResponse")
		case "panels":
			out.Values[i] = ec._PanelGroupResponse_panels(ctx, field, obj)
		case "panelGroupName":
			out.Values[i] = ec._PanelGroupResponse_panelGroupName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "panelGroupID":
			out.Values[i] = ec._PanelGroupResponse_panelGroupID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var panelOptionResponseImplementors = []string{"PanelOptionResponse"}

func (ec *executionContext) _PanelOptionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PanelOptionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, panelOptionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PanelOptionResponse")
		case "points":
			out.Values[i] = ec._PanelOptionResponse_points(ctx, field, obj)
		case "grIDs":
			out.Values[i] = ec._PanelOptionResponse_grIDs(ctx, field, obj)
		case "leftAxis":
			out.Values[i] = ec._PanelOptionResponse_leftAxis(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var panelResponseImplementors = []string{"PanelResponse"}

func (ec *executionContext) _PanelResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PanelResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, panelResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PanelResponse")
		case "panelID":
			out.Values[i] = ec._PanelResponse_panelID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "yAxisLeft":
			out.Values[i] = ec._PanelResponse_yAxisLeft(ctx, field, obj)
		case "yAxisRight":
			out.Values[i] = ec._PanelResponse_yAxisRight(ctx, field, obj)
		case "xAxisDown":
			out.Values[i] = ec._PanelResponse_xAxisDown(ctx, field, obj)
		case "unit":
			out.Values[i] = ec._PanelResponse_unit(ctx, field, obj)
		case "promQueries":
			out.Values[i] = ec._PanelResponse_promQueries(ctx, field, obj)
		case "panelOptions":
			out.Values[i] = ec._PanelResponse_panelOptions(ctx, field, obj)
		case "panelName":
			out.Values[i] = ec._PanelResponse_panelName(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._PanelResponse_createdAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podLogResponseImplementors = []string{"PodLogResponse"}

func (ec *executionContext) _PodLogResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PodLogResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podLogResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodLogResponse")
		case "workflowRunID":
			out.Values[i] = ec._PodLogResponse_workflowRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podName":
			out.Values[i] = ec._PodLogResponse_podName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podType":
			out.Values[i] = ec._PodLogResponse_podType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "log":
			out.Values[i] = ec._PodLogResponse_log(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var portalDashboardDataResponseImplementors = []string{"PortalDashboardDataResponse"}

func (ec *executionContext) _PortalDashboardDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PortalDashboardDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, portalDashboardDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PortalDashboardDataResponse")
		case "name":
			out.Values[i] = ec._PortalDashboardDataResponse_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dashboardData":
			out.Values[i] = ec._PortalDashboardDataResponse_dashboardData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var predefinedWorkflowListImplementors = []string{"PredefinedWorkflowList"}

func (ec *executionContext) _PredefinedWorkflowList(ctx context.Context, sel ast.SelectionSet, obj *model.PredefinedWorkflowList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, predefinedWorkflowListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PredefinedWorkflowList")
		case "workflowName":
			out.Values[i] = ec._PredefinedWorkflowList_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowCSV":
			out.Values[i] = ec._PredefinedWorkflowList_workflowCSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowManifest":
			out.Values[i] = ec._PredefinedWorkflowList_workflowManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectDataImplementors = []string{"ProjectData"}

func (ec *executionContext) _ProjectData(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectData")
		case "workflows":
			out.Values[i] = ec._ProjectData_workflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agents":
			out.Values[i] = ec._ProjectData_agents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ProjectData_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var promQueryResponseImplementors = []string{"PromQueryResponse"}

func (ec *executionContext) _PromQueryResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PromQueryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, promQueryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PromQueryResponse")
		case "queryID":
			out.Values[i] = ec._PromQueryResponse_queryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "promQueryName":
			out.Values[i] = ec._PromQueryResponse_promQueryName(ctx, field, obj)
		case "legend":
			out.Values[i] = ec._PromQueryResponse_legend(ctx, field, obj)
		case "resolution":
			out.Values[i] = ec._PromQueryResponse_resolution(ctx, field, obj)
		case "minstep":
			out.Values[i] = ec._PromQueryResponse_minstep(ctx, field, obj)
		case "line":
			out.Values[i] = ec._PromQueryResponse_line(ctx, field, obj)
		case "closeArea":
			out.Values[i] = ec._PromQueryResponse_closeArea(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var promSeriesListResponseImplementors = []string{"PromSeriesListResponse"}

func (ec *executionContext) _PromSeriesListResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PromSeriesListResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, promSeriesListResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PromSeriesListResponse")
		case "seriesList":
			out.Values[i] = ec._PromSeriesListResponse_seriesList(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var promSeriesResponseImplementors = []string{"PromSeriesResponse"}

func (ec *executionContext) _PromSeriesResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PromSeriesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, promSeriesResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PromSeriesResponse")
		case "series":
			out.Values[i] = ec._PromSeriesResponse_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "labelValues":
			out.Values[i] = ec._PromSeriesResponse_labelValues(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var prometheusDataResponseImplementors = []string{"PrometheusDataResponse"}

func (ec *executionContext) _PrometheusDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PrometheusDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, prometheusDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrometheusDataResponse")
		case "metricsResponse":
			out.Values[i] = ec._PrometheusDataResponse_metricsResponse(ctx, field, obj)
		case "annotationsResponse":
			out.Values[i] = ec._PrometheusDataResponse_annotationsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var providerImplementors = []string{"Provider"}

func (ec *executionContext) _Provider(ctx context.Context, sel ast.SelectionSet, obj *model.Provider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Provider")
		case "name":
			out.Values[i] = ec._Provider_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "listWorkflows":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflows(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listWorkflowRuns":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflowRuns(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listHeatmapData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listHeatmapData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listWorkflowStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflowStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getWorkflowRunStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getWorkflowRunStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listDataSource":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listDataSource(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPrometheusData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPrometheusData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPromLabelNamesAndValues":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPromLabelNamesAndValues(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPromSeriesList":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPromSeriesList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listDashboard":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listDashboard(ctx, field)
				return res
			})
		case "listPortalDashboardData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listPortalDashboardData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getServerVersion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getServerVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listClusters":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listClusters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getAgentDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAgentDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getManifest":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getManifest(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getGitOpsDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGitOpsDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listImageRegistry(ctx, field)
				return res
			})
		case "getImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getImageRegistry(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listCharts":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listCharts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getHubExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getHubExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listHubStatus":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listHubStatus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getYAMLData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getYAMLData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperimentDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listPredefinedWorkflows":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listPredefinedWorkflows(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPredefinedExperimentYAML":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPredefinedExperimentYAML(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getUsageData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUsageData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listWorkflowManifests":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflowManifests(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getWorkflowManifestByID":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getWorkflowManifestByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var registerClusterResponseImplementors = []string{"RegisterClusterResponse"}

func (ec *executionContext) _RegisterClusterResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RegisterClusterResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registerClusterResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegisterClusterResponse")
		case "token":
			out.Values[i] = ec._RegisterClusterResponse_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._RegisterClusterResponse_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._RegisterClusterResponse_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourceResponseImplementors = []string{"ResourceResponse"}

func (ec *executionContext) _ResourceResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceResponse")
		case "kind":
			out.Values[i] = ec._ResourceResponse_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "names":
			out.Values[i] = ec._ResourceResponse_names(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sSHKeyImplementors = []string{"SSHKey"}

func (ec *executionContext) _SSHKey(ctx context.Context, sel ast.SelectionSet, obj *model.SSHKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sSHKeyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SSHKey")
		case "publicKey":
			out.Values[i] = ec._SSHKey_publicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "privateKey":
			out.Values[i] = ec._SSHKey_privateKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverVersionResponseImplementors = []string{"ServerVersionResponse"}

func (ec *executionContext) _ServerVersionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ServerVersionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverVersionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerVersionResponse")
		case "key":
			out.Values[i] = ec._ServerVersionResponse_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._ServerVersionResponse_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var specImplementors = []string{"Spec"}

func (ec *executionContext) _Spec(ctx context.Context, sel ast.SelectionSet, obj *model.Spec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, specImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Spec")
		case "displayName":
			out.Values[i] = ec._Spec_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "categoryDescription":
			out.Values[i] = ec._Spec_categoryDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keywords":
			out.Values[i] = ec._Spec_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maturity":
			out.Values[i] = ec._Spec_maturity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._Spec_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "minKubeVersion":
			out.Values[i] = ec._Spec_minKubeVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "provider":
			out.Values[i] = ec._Spec_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "links":
			out.Values[i] = ec._Spec_links(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._Spec_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosExpCRDLink":
			out.Values[i] = ec._Spec_chaosExpCRDLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "platforms":
			out.Values[i] = ec._Spec_platforms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosType":
			out.Values[i] = ec._Spec_chaosType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subDataImplementors = []string{"SubData"}

func (ec *executionContext) _SubData(ctx context.Context, sel ast.SelectionSet, obj *model.SubData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubData")
		case "date":
			out.Values[i] = ec._SubData_date(ctx, field, obj)
		case "value":
			out.Values[i] = ec._SubData_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "subDataName":
			out.Values[i] = ec._SubData_subDataName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "getWorkflowEvents":
		return ec._Subscription_getWorkflowEvents(ctx, fields[0])
	case "viewDashboard":
		return ec._Subscription_viewDashboard(ctx, fields[0])
	case "getClusterEvents":
		return ec._Subscription_getClusterEvents(ctx, fields[0])
	case "clusterConnect":
		return ec._Subscription_clusterConnect(ctx, fields[0])
	case "getPodLog":
		return ec._Subscription_getPodLog(ctx, fields[0])
	case "getKubeObject":
		return ec._Subscription_getKubeObject(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var totalCountImplementors = []string{"TotalCount"}

func (ec *executionContext) _TotalCount(ctx context.Context, sel ast.SelectionSet, obj *model.TotalCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, totalCountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TotalCount")
		case "projects":
			out.Values[i] = ec._TotalCount_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "users":
			out.Values[i] = ec._TotalCount_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agents":
			out.Values[i] = ec._TotalCount_agents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflows":
			out.Values[i] = ec._TotalCount_workflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var usageDataResponseImplementors = []string{"UsageDataResponse"}

func (ec *executionContext) _UsageDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.UsageDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usageDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsageDataResponse")
		case "projects":
			out.Values[i] = ec._UsageDataResponse_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalEntries":
			out.Values[i] = ec._UsageDataResponse_totalEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":
			out.Values[i] = ec._UsageDataResponse_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var weightagesImplementors = []string{"Weightages"}

func (ec *executionContext) _Weightages(ctx context.Context, sel ast.SelectionSet, obj *model.Weightages) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weightagesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Weightages")
		case "experimentName":
			out.Values[i] = ec._Weightages_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightage":
			out.Values[i] = ec._Weightages_weightage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowImplementors = []string{"Workflow"}

func (ec *executionContext) _Workflow(ctx context.Context, sel ast.SelectionSet, obj *model.Workflow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Workflow")
		case "workflowID":
			out.Values[i] = ec._Workflow_workflowID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowManifest":
			out.Values[i] = ec._Workflow_workflowManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._Workflow_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._Workflow_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowName":
			out.Values[i] = ec._Workflow_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowDescription":
			out.Values[i] = ec._Workflow_workflowDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._Workflow_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomWorkflow":
			out.Values[i] = ec._Workflow_isCustomWorkflow(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Workflow_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Workflow_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._Workflow_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._Workflow_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterType":
			out.Values[i] = ec._Workflow_clusterType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._Workflow_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdatedBy":
			out.Values[i] = ec._Workflow_lastUpdatedBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunImplementors = []string{"WorkflowRun"}

func (ec *executionContext) _WorkflowRun(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRun")
		case "workflowRunID":
			out.Values[i] = ec._WorkflowRun_workflowRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowID":
			out.Values[i] = ec._WorkflowRun_workflowID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._WorkflowRun_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._WorkflowRun_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdated":
			out.Values[i] = ec._WorkflowRun_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._WorkflowRun_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._WorkflowRun_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowName":
			out.Values[i] = ec._WorkflowRun_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterType":
			out.Values[i] = ec._WorkflowRun_clusterType(ctx, field, obj)
		case "phase":
			out.Values[i] = ec._WorkflowRun_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resiliencyScore":
			out.Values[i] = ec._WorkflowRun_resiliencyScore(ctx, field, obj)
		case "experimentsPassed":
			out.Values[i] = ec._WorkflowRun_experimentsPassed(ctx, field, obj)
		case "experimentsFailed":
			out.Values[i] = ec._WorkflowRun_experimentsFailed(ctx, field, obj)
		case "experimentsAwaited":
			out.Values[i] = ec._WorkflowRun_experimentsAwaited(ctx, field, obj)
		case "experimentsStopped":
			out.Values[i] = ec._WorkflowRun_experimentsStopped(ctx, field, obj)
		case "experimentsNa":
			out.Values[i] = ec._WorkflowRun_experimentsNa(ctx, field, obj)
		case "totalExperiments":
			out.Values[i] = ec._WorkflowRun_totalExperiments(ctx, field, obj)
		case "executionData":
			out.Values[i] = ec._WorkflowRun_executionData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._WorkflowRun_isRemoved(ctx, field, obj)
		case "executedBy":
			out.Values[i] = ec._WorkflowRun_executedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunDetailsImplementors = []string{"WorkflowRunDetails"}

func (ec *executionContext) _WorkflowRunDetails(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRunDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRunDetails")
		case "noOfRuns":
			out.Values[i] = ec._WorkflowRunDetails_noOfRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dateStamp":
			out.Values[i] = ec._WorkflowRunDetails_dateStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunStatsResponseImplementors = []string{"WorkflowRunStatsResponse"}

func (ec *executionContext) _WorkflowRunStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRunStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRunStatsResponse")
		case "totalWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_totalWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "succeededWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_succeededWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "failedWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_failedWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runningWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_runningWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "averageResiliencyScore":
			out.Values[i] = ec._WorkflowRunStatsResponse_averageResiliencyScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExperiments":
			out.Values[i] = ec._WorkflowRunStatsResponse_totalExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsPassed":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsPassed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsFailed":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsFailed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsAwaited":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsAwaited(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsStopped":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsStopped(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsNa":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsNa(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "passedPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_passedPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "failedPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_failedPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowRunSucceededPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_workflowRunSucceededPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowRunFailedPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_workflowRunFailedPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunsDataImplementors = []string{"WorkflowRunsData"}

func (ec *executionContext) _WorkflowRunsData(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRunsData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunsDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRunsData")
		case "value":
			out.Values[i] = ec._WorkflowRunsData_value(ctx, field, obj)
		case "workflowRunDetail":
			out.Values[i] = ec._WorkflowRunsData_workflowRunDetail(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowStatImplementors = []string{"WorkflowStat"}

func (ec *executionContext) _WorkflowStat(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowStat) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowStatImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowStat")
		case "schedules":
			out.Values[i] = ec._WorkflowStat_schedules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runs":
			out.Values[i] = ec._WorkflowStat_runs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expRuns":
			out.Values[i] = ec._WorkflowStat_expRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowStatsResponseImplementors = []string{"WorkflowStatsResponse"}

func (ec *executionContext) _WorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowStatsResponse")
		case "date":
			out.Values[i] = ec._WorkflowStatsResponse_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._WorkflowStatsResponse_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowTemplateImplementors = []string{"WorkflowTemplate"}

func (ec *executionContext) _WorkflowTemplate(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowTemplate")
		case "templateID":
			out.Values[i] = ec._WorkflowTemplate_templateID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manifest":
			out.Values[i] = ec._WorkflowTemplate_manifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "templateName":
			out.Values[i] = ec._WorkflowTemplate_templateName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "templateDescription":
			out.Values[i] = ec._WorkflowTemplate_templateDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._WorkflowTemplate_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectName":
			out.Values[i] = ec._WorkflowTemplate_projectName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._WorkflowTemplate_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._WorkflowTemplate_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomWorkflow":
			out.Values[i] = ec._WorkflowTemplate_isCustomWorkflow(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActionPayload2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelActionPayload(ctx context.Context, sel ast.SelectionSet, v model.ActionPayload) graphql.Marshaler {
	return ec._ActionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNActionPayload2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelActionPayload(ctx context.Context, sel ast.SelectionSet, v *model.ActionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ActionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAgentStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAgentStat(ctx context.Context, sel ast.SelectionSet, v model.AgentStat) graphql.Marshaler {
	return ec._AgentStat(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgentStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAgentStat(ctx context.Context, sel ast.SelectionSet, v *model.AgentStat) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AgentStat(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnotation2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotation(ctx context.Context, sel ast.SelectionSet, v model.Annotation) graphql.Marshaler {
	return ec._Annotation(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnotation2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.Annotation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNChaosHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHub(ctx context.Context, sel ast.SelectionSet, v model.ChaosHub) graphql.Marshaler {
	return ec._ChaosHub(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHub(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHub) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosHub(ctx, sel, v)
}

func (ec *executionContext) marshalNChaosHubStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v []*model.ChaosHubStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOChaosHubStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHubStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNChaosWorkFlowRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowRequest(ctx context.Context, v interface{}) (model.ChaosWorkFlowRequest, error) {
	return ec.unmarshalInputChaosWorkFlowRequest(ctx, v)
}

func (ec *executionContext) marshalNChaosWorkFlowResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowResponse(ctx context.Context, sel ast.SelectionSet, v model.ChaosWorkFlowResponse) graphql.Marshaler {
	return ec._ChaosWorkFlowResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosWorkFlowResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowResponse(ctx context.Context, sel ast.SelectionSet, v *model.ChaosWorkFlowResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosWorkFlowResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNChart2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChart(ctx context.Context, sel ast.SelectionSet, v model.Chart) graphql.Marshaler {
	return ec._Chart(ctx, sel, &v)
}

func (ec *executionContext) marshalNChart2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChart(ctx context.Context, sel ast.SelectionSet, v []*model.Chart) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChart2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChart(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChart2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChart(ctx context.Context, sel ast.SelectionSet, v *model.Chart) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Chart(ctx, sel, v)
}

func (ec *executionContext) marshalNCluster2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCluster(ctx context.Context, sel ast.SelectionSet, v model.Cluster) graphql.Marshaler {
	return ec._Cluster(ctx, sel, &v)
}

func (ec *executionContext) marshalNCluster2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCluster(ctx context.Context, sel ast.SelectionSet, v []*model.Cluster) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCluster2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCluster(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCluster2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCluster(ctx context.Context, sel ast.SelectionSet, v *model.Cluster) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Cluster(ctx, sel, v)
}

func (ec *executionContext) marshalNClusterActionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterActionResponse(ctx context.Context, sel ast.SelectionSet, v model.ClusterActionResponse) graphql.Marshaler {
	return ec._ClusterActionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNClusterActionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterActionResponse(ctx context.Context, sel ast.SelectionSet, v *model.ClusterActionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ClusterActionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNClusterEventResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterEventResponse(ctx context.Context, sel ast.SelectionSet, v model.ClusterEventResponse) graphql.Marshaler {
	return ec._ClusterEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNClusterEventResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterEventResponse(ctx context.Context, sel ast.SelectionSet, v *model.ClusterEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ClusterEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx context.Context, v interface{}) (model.ClusterIdentity, error) {
	return ec.unmarshalInputClusterIdentity(ctx, v)
}

func (ec *executionContext) unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx context.Context, v interface{}) (*model.ClusterIdentity, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNClusterIdentity2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelClusterIdentity(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNConfirmClusterRegistrationResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelConfirmClusterRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v model.ConfirmClusterRegistrationResponse) graphql.Marshaler {
	return ec._ConfirmClusterRegistrationResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfirmClusterRegistrationResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelConfirmClusterRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v *model.ConfirmClusterRegistrationResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ConfirmClusterRegistrationResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateChaosHubRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateChaosHubRequest(ctx context.Context, v interface{}) (model.CreateChaosHubRequest, error) {
	return ec.unmarshalInputCreateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNCreateRemoteMyHub2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateRemoteMyHub(ctx context.Context, v interface{}) (model.CreateRemoteMyHub, error) {
	return ec.unmarshalInputCreateRemoteMyHub(ctx, v)
}

func (ec *executionContext) unmarshalNDSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSInput(ctx context.Context, v interface{}) (model.DSInput, error) {
	return ec.unmarshalInputDSInput(ctx, v)
}

func (ec *executionContext) marshalNDSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx context.Context, sel ast.SelectionSet, v model.DSResponse) graphql.Marshaler {
	return ec._DSResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx context.Context, sel ast.SelectionSet, v []*model.DSResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNDSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx context.Context, sel ast.SelectionSet, v *model.DSResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DSResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNDashboardPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDashboardPromResponse(ctx context.Context, sel ast.SelectionSet, v model.DashboardPromResponse) graphql.Marshaler {
	return ec._DashboardPromResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDashboardPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDashboardPromResponse(ctx context.Context, sel ast.SelectionSet, v *model.DashboardPromResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DashboardPromResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDataVars2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDataVars(ctx context.Context, v interface{}) (model.DataVars, error) {
	return ec.unmarshalInputDataVars(ctx, v)
}

func (ec *executionContext) unmarshalNDateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx context.Context, v interface{}) (model.DateRange, error) {
	return ec.unmarshalInputDateRange(ctx, v)
}

func (ec *executionContext) unmarshalNDateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx context.Context, v interface{}) (*model.DateRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNDateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNDeleteDSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDeleteDSInput(ctx context.Context, v interface{}) (model.DeleteDSInput, error) {
	return ec.unmarshalInputDeleteDSInput(ctx, v)
}

func (ec *executionContext) unmarshalNDsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx context.Context, v interface{}) (model.DsDetails, error) {
	return ec.unmarshalInputDsDetails(ctx, v)
}

func (ec *executionContext) unmarshalNDsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx context.Context, v interface{}) (*model.DsDetails, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNDsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNExperimentDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentDetails(ctx context.Context, sel ast.SelectionSet, v model.ExperimentDetails) graphql.Marshaler {
	return ec._ExperimentDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperimentDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentDetails(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentDetails) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ExperimentDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExperimentRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperimentRequest(ctx context.Context, v interface{}) (model.ExperimentRequest, error) {
	return ec.unmarshalInputExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNExperiments2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperiments(ctx context.Context, sel ast.SelectionSet, v model.Experiments) graphql.Marshaler {
	return ec._Experiments(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiments2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperiments(ctx context.Context, sel ast.SelectionSet, v []*model.Experiments) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExperiments2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperiments(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperiments2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelExperiments(ctx context.Context, sel ast.SelectionSet, v *model.Experiments) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiments(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNGitConfig2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelGitConfig(ctx context.Context, v interface{}) (model.GitConfig, error) {
	return ec.unmarshalInputGitConfig(ctx, v)
}

func (ec *executionContext) marshalNGitConfigResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v model.GitConfigResponse) graphql.Marshaler {
	return ec._GitConfigResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitConfigResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v *model.GitConfigResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GitConfigResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNHeatmapDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, v []*model.HeatmapDataResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHeatmapDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHeatmapDataResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNHubType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHubType(ctx context.Context, v interface{}) (model.HubType, error) {
	var res model.HubType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNHubType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHubType(ctx context.Context, sel ast.SelectionSet, v model.HubType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImageRegistryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryInput(ctx context.Context, v interface{}) (model.ImageRegistryInput, error) {
	return ec.unmarshalInputImageRegistryInput(ctx, v)
}

func (ec *executionContext) marshalNImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistryResponse) graphql.Marshaler {
	return ec._ImageRegistryResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImageRegistryResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNKubeGVRRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeGVRRequest(ctx context.Context, v interface{}) (model.KubeGVRRequest, error) {
	return ec.unmarshalInputKubeGVRRequest(ctx, v)
}

func (ec *executionContext) unmarshalNKubeGVRRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeGVRRequest(ctx context.Context, v interface{}) (*model.KubeGVRRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNKubeGVRRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeGVRRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNKubeObjectData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeObjectData(ctx context.Context, v interface{}) (model.KubeObjectData, error) {
	return ec.unmarshalInputKubeObjectData(ctx, v)
}

func (ec *executionContext) unmarshalNKubeObjectRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeObjectRequest(ctx context.Context, v interface{}) (model.KubeObjectRequest, error) {
	return ec.unmarshalInputKubeObjectRequest(ctx, v)
}

func (ec *executionContext) marshalNKubeObjectResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v model.KubeObjectResponse) graphql.Marshaler {
	return ec._KubeObjectResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNKubeObjectResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v *model.KubeObjectResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._KubeObjectResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNLink2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLink(ctx context.Context, sel ast.SelectionSet, v model.Link) graphql.Marshaler {
	return ec._Link(ctx, sel, &v)
}

func (ec *executionContext) marshalNLink2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLink(ctx context.Context, sel ast.SelectionSet, v []*model.Link) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLink2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLink2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLink(ctx context.Context, sel ast.SelectionSet, v *model.Link) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Link(ctx, sel, v)
}

func (ec *executionContext) marshalNListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v model.ListDashboardResponse) graphql.Marshaler {
	return ec._ListDashboardResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListDashboardResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListDashboardResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListWorkflowRunsRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowRunsRequest(ctx context.Context, v interface{}) (model.ListWorkflowRunsRequest, error) {
	return ec.unmarshalInputListWorkflowRunsRequest(ctx, v)
}

func (ec *executionContext) marshalNListWorkflowRunsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowRunsResponse(ctx context.Context, sel ast.SelectionSet, v model.ListWorkflowRunsResponse) graphql.Marshaler {
	return ec._ListWorkflowRunsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListWorkflowRunsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowRunsResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListWorkflowRunsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListWorkflowRunsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListWorkflowsRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowsRequest(ctx context.Context, v interface{}) (model.ListWorkflowsRequest, error) {
	return ec.unmarshalInputListWorkflowsRequest(ctx, v)
}

func (ec *executionContext) marshalNListWorkflowsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowsResponse(ctx context.Context, sel ast.SelectionSet, v model.ListWorkflowsResponse) graphql.Marshaler {
	return ec._ListWorkflowsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListWorkflowsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListWorkflowsResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListWorkflowsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListWorkflowsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMaintainer(ctx context.Context, sel ast.SelectionSet, v model.Maintainer) graphql.Marshaler {
	return ec._Maintainer(ctx, sel, &v)
}

func (ec *executionContext) marshalNMaintainer2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMaintainer(ctx context.Context, sel ast.SelectionSet, v []*model.Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMaintainer(ctx context.Context, sel ast.SelectionSet, v *model.Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) marshalNMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetadata(ctx context.Context, sel ast.SelectionSet, v model.Metadata) graphql.Marshaler {
	return ec._Metadata(ctx, sel, &v)
}

func (ec *executionContext) marshalNMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetadata(ctx context.Context, sel ast.SelectionSet, v *model.Metadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Metadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNewClusterEventRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelNewClusterEventRequest(ctx context.Context, v interface{}) (model.NewClusterEventRequest, error) {
	return ec.unmarshalInputNewClusterEventRequest(ctx, v)
}

func (ec *executionContext) marshalNPackageInformation2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPackageInformation(ctx context.Context, sel ast.SelectionSet, v model.PackageInformation) graphql.Marshaler {
	return ec._PackageInformation(ctx, sel, &v)
}

func (ec *executionContext) marshalNPackageInformation2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPackageInformation(ctx context.Context, sel ast.SelectionSet, v *model.PackageInformation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PackageInformation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroup(ctx context.Context, v interface{}) ([]*model.PanelGroup, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PanelGroup, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNPanelGroupResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroupResponse(ctx context.Context, sel ast.SelectionSet, v []*model.PanelGroupResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPanelGroupResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroupResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNPodLog2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPodLog(ctx context.Context, v interface{}) (model.PodLog, error) {
	return ec.unmarshalInputPodLog(ctx, v)
}

func (ec *executionContext) unmarshalNPodLogRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPodLogRequest(ctx context.Context, v interface{}) (model.PodLogRequest, error) {
	return ec.unmarshalInputPodLogRequest(ctx, v)
}

func (ec *executionContext) marshalNPodLogResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPodLogResponse(ctx context.Context, sel ast.SelectionSet, v model.PodLogResponse) graphql.Marshaler {
	return ec._PodLogResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodLogResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPodLogResponse(ctx context.Context, sel ast.SelectionSet, v *model.PodLogResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PodLogResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPortalDashboardDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPortalDashboardDataResponse(ctx context.Context, sel ast.SelectionSet, v model.PortalDashboardDataResponse) graphql.Marshaler {
	return ec._PortalDashboardDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPortalDashboardDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPortalDashboardDataResponse(ctx context.Context, sel ast.SelectionSet, v []*model.PortalDashboardDataResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPortalDashboardDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPortalDashboardDataResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPortalDashboardDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPortalDashboardDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.PortalDashboardDataResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PortalDashboardDataResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPredefinedWorkflowList2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPredefinedWorkflowList(ctx context.Context, sel ast.SelectionSet, v model.PredefinedWorkflowList) graphql.Marshaler {
	return ec._PredefinedWorkflowList(ctx, sel, &v)
}

func (ec *executionContext) marshalNPredefinedWorkflowList2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPredefinedWorkflowList(ctx context.Context, sel ast.SelectionSet, v []*model.PredefinedWorkflowList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPredefinedWorkflowList2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPredefinedWorkflowList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPredefinedWorkflowList2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPredefinedWorkflowList(ctx context.Context, sel ast.SelectionSet, v *model.PredefinedWorkflowList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PredefinedWorkflowList(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProjectData(ctx context.Context, sel ast.SelectionSet, v []*model.ProjectData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProjectData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProjectData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx context.Context, v interface{}) (model.PromQueryInput, error) {
	return ec.unmarshalInputPromQueryInput(ctx, v)
}

func (ec *executionContext) unmarshalNPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx context.Context, v interface{}) ([]*model.PromQueryInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PromQueryInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx context.Context, v interface{}) (*model.PromQueryInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNPromSeriesListResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesListResponse(ctx context.Context, sel ast.SelectionSet, v model.PromSeriesListResponse) graphql.Marshaler {
	return ec._PromSeriesListResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPromSeriesListResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesListResponse(ctx context.Context, sel ast.SelectionSet, v *model.PromSeriesListResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PromSeriesListResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPromSeriesResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesResponse(ctx context.Context, sel ast.SelectionSet, v model.PromSeriesResponse) graphql.Marshaler {
	return ec._PromSeriesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPromSeriesResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesResponse(ctx context.Context, sel ast.SelectionSet, v *model.PromSeriesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PromSeriesResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPrometheusDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPrometheusDataResponse(ctx context.Context, sel ast.SelectionSet, v model.PrometheusDataResponse) graphql.Marshaler {
	return ec._PrometheusDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPrometheusDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPrometheusDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.PrometheusDataResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PrometheusDataResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNProvider2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProvider(ctx context.Context, sel ast.SelectionSet, v model.Provider) graphql.Marshaler {
	return ec._Provider(ctx, sel, &v)
}

func (ec *executionContext) marshalNProvider2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProvider(ctx context.Context, sel ast.SelectionSet, v *model.Provider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Provider(ctx, sel, v)
}

func (ec *executionContext) unmarshalNQueryMapForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanel(ctx context.Context, v interface{}) (model.QueryMapForPanel, error) {
	return ec.unmarshalInputQueryMapForPanel(ctx, v)
}

func (ec *executionContext) unmarshalNQueryMapForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanel(ctx context.Context, v interface{}) ([]*model.QueryMapForPanel, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.QueryMapForPanel, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNQueryMapForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNQueryMapForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanel(ctx context.Context, v interface{}) (*model.QueryMapForPanel, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNQueryMapForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanel(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNQueryMapForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanelGroup(ctx context.Context, v interface{}) (model.QueryMapForPanelGroup, error) {
	return ec.unmarshalInputQueryMapForPanelGroup(ctx, v)
}

func (ec *executionContext) unmarshalNQueryMapForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanelGroup(ctx context.Context, v interface{}) ([]*model.QueryMapForPanelGroup, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.QueryMapForPanelGroup, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNQueryMapForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanelGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNQueryMapForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanelGroup(ctx context.Context, v interface{}) (*model.QueryMapForPanelGroup, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNQueryMapForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelQueryMapForPanelGroup(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNRegisterClusterRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelRegisterClusterRequest(ctx context.Context, v interface{}) (model.RegisterClusterRequest, error) {
	return ec.unmarshalInputRegisterClusterRequest(ctx, v)
}

func (ec *executionContext) marshalNRegisterClusterResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelRegisterClusterResponse(ctx context.Context, sel ast.SelectionSet, v model.RegisterClusterResponse) graphql.Marshaler {
	return ec._RegisterClusterResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegisterClusterResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelRegisterClusterResponse(ctx context.Context, sel ast.SelectionSet, v *model.RegisterClusterResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RegisterClusterResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSSHKey2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSSHKey(ctx context.Context, sel ast.SelectionSet, v model.SSHKey) graphql.Marshaler {
	return ec._SSHKey(ctx, sel, &v)
}

func (ec *executionContext) marshalNSSHKey2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSSHKey(ctx context.Context, sel ast.SelectionSet, v *model.SSHKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SSHKey(ctx, sel, v)
}

func (ec *executionContext) marshalNServerVersionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v model.ServerVersionResponse) graphql.Marshaler {
	return ec._ServerVersionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNServerVersionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v *model.ServerVersionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ServerVersionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSpec2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSpec(ctx context.Context, sel ast.SelectionSet, v model.Spec) graphql.Marshaler {
	return ec._Spec(ctx, sel, &v)
}

func (ec *executionContext) marshalNSpec2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSpec(ctx context.Context, sel ast.SelectionSet, v *model.Spec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Spec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNTimeFrequency2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTimeFrequency(ctx context.Context, v interface{}) (model.TimeFrequency, error) {
	var res model.TimeFrequency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNTimeFrequency2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTimeFrequency(ctx context.Context, sel ast.SelectionSet, v model.TimeFrequency) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTotalCount2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTotalCount(ctx context.Context, sel ast.SelectionSet, v model.TotalCount) graphql.Marshaler {
	return ec._TotalCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNTotalCount2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTotalCount(ctx context.Context, sel ast.SelectionSet, v *model.TotalCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TotalCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateChaosHubRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdateChaosHubRequest(ctx context.Context, v interface{}) (model.UpdateChaosHubRequest, error) {
	return ec.unmarshalInputUpdateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateDBInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdateDBInput(ctx context.Context, v interface{}) (model.UpdateDBInput, error) {
	return ec.unmarshalInputUpdateDBInput(ctx, v)
}

func (ec *executionContext) unmarshalNUsageDataRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageDataRequest(ctx context.Context, v interface{}) (model.UsageDataRequest, error) {
	return ec.unmarshalInputUsageDataRequest(ctx, v)
}

func (ec *executionContext) marshalNUsageDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageDataResponse(ctx context.Context, sel ast.SelectionSet, v model.UsageDataResponse) graphql.Marshaler {
	return ec._UsageDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUsageDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.UsageDataResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._UsageDataResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUsageSort2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageSort(ctx context.Context, v interface{}) (model.UsageSort, error) {
	var res model.UsageSort
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNUsageSort2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageSort(ctx context.Context, sel ast.SelectionSet, v model.UsageSort) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWeightages2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightages(ctx context.Context, sel ast.SelectionSet, v model.Weightages) graphql.Marshaler {
	return ec._Weightages(ctx, sel, &v)
}

func (ec *executionContext) marshalNWeightages2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightages(ctx context.Context, sel ast.SelectionSet, v []*model.Weightages) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeightages2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWeightages2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightages(ctx context.Context, sel ast.SelectionSet, v *model.Weightages) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Weightages(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightagesInput(ctx context.Context, v interface{}) (model.WeightagesInput, error) {
	return ec.unmarshalInputWeightagesInput(ctx, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightagesInput(ctx context.Context, v interface{}) ([]*model.WeightagesInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.WeightagesInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNWeightagesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightagesInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNWeightagesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightagesInput(ctx context.Context, v interface{}) (*model.WeightagesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNWeightagesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWeightagesInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNWorkflow2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflow(ctx context.Context, sel ast.SelectionSet, v []*model.Workflow) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflow2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflow(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRun) graphql.Marshaler {
	return ec._WorkflowRun(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowRun) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRun) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorkflowRunRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunRequest(ctx context.Context, v interface{}) (model.WorkflowRunRequest, error) {
	return ec.unmarshalInputWorkflowRunRequest(ctx, v)
}

func (ec *executionContext) unmarshalNWorkflowRunStatsRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatsRequest(ctx context.Context, v interface{}) (model.WorkflowRunStatsRequest, error) {
	return ec.unmarshalInputWorkflowRunStatsRequest(ctx, v)
}

func (ec *executionContext) marshalNWorkflowRunStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunStatsResponse) graphql.Marshaler {
	return ec._WorkflowRunStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowRunStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowRunStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkflowRunsData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunsData(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowRunsData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowRunsData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunsData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNWorkflowSortingField2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortingField(ctx context.Context, v interface{}) (model.WorkflowSortingField, error) {
	var res model.WorkflowSortingField
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNWorkflowSortingField2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortingField(ctx context.Context, sel ast.SelectionSet, v model.WorkflowSortingField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorkflowStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStat(ctx context.Context, sel ast.SelectionSet, v model.WorkflowStat) graphql.Marshaler {
	return ec._WorkflowStat(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowStat2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStat(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowStat) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowStat(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkflowStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowStatsResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStatsResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v model.WorkflowTemplate) graphql.Marshaler {
	return ec._WorkflowTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowTemplate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowTemplate(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOAnnotationsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, v model.AnnotationsPromResponse) graphql.Marshaler {
	return ec._AnnotationsPromResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOAnnotationsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, v []*model.AnnotationsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnnotationsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsPromResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAnnotationsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, v *model.AnnotationsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AnnotationsPromResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v model.AnnotationsTimeStampValue) graphql.Marshaler {
	return ec._AnnotationsTimeStampValue(ctx, sel, &v)
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v [][]*model.AnnotationsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnnotationsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v []*model.AnnotationsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnnotationsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v *model.AnnotationsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AnnotationsTimeStampValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalOApplicationMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadata(ctx context.Context, v interface{}) (model.ApplicationMetadata, error) {
	return ec.unmarshalInputApplicationMetadata(ctx, v)
}

func (ec *executionContext) unmarshalOApplicationMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadata(ctx context.Context, v interface{}) ([]*model.ApplicationMetadata, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.ApplicationMetadata, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOApplicationMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadata(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOApplicationMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadata(ctx context.Context, v interface{}) (*model.ApplicationMetadata, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOApplicationMetadata2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadata(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOApplicationMetadataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, v model.ApplicationMetadataResponse) graphql.Marshaler {
	return ec._ApplicationMetadataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOApplicationMetadataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ApplicationMetadataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOApplicationMetadataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadataResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOApplicationMetadataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationMetadataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationMetadataResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx context.Context, v interface{}) (*model.AuthType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAuthType2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelAuthType(ctx context.Context, sel ast.SelectionSet, v *model.AuthType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOChaosHubStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v model.ChaosHubStatus) graphql.Marshaler {
	return ec._ChaosHubStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalOChaosHubStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHubStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChaosHubStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalOChaosWorkFlowRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowRequest(ctx context.Context, v interface{}) (model.ChaosWorkFlowRequest, error) {
	return ec.unmarshalInputChaosWorkFlowRequest(ctx, v)
}

func (ec *executionContext) unmarshalOChaosWorkFlowRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowRequest(ctx context.Context, v interface{}) (*model.ChaosWorkFlowRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChaosWorkFlowRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelChaosWorkFlowRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOCreateDBInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateDBInput(ctx context.Context, v interface{}) (model.CreateDBInput, error) {
	return ec.unmarshalInputCreateDBInput(ctx, v)
}

func (ec *executionContext) unmarshalOCreateDBInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateDBInput(ctx context.Context, v interface{}) (*model.CreateDBInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCreateDBInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelCreateDBInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSInput(ctx context.Context, v interface{}) (model.DSInput, error) {
	return ec.unmarshalInputDSInput(ctx, v)
}

func (ec *executionContext) unmarshalODSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSInput(ctx context.Context, v interface{}) (*model.DSInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODSInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx context.Context, sel ast.SelectionSet, v model.DSResponse) graphql.Marshaler {
	return ec._DSResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalODSResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDSResponse(ctx context.Context, sel ast.SelectionSet, v *model.DSResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DSResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalODateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx context.Context, v interface{}) (model.DateRange, error) {
	return ec.unmarshalInputDateRange(ctx, v)
}

func (ec *executionContext) unmarshalODateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx context.Context, v interface{}) (*model.DateRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODateRange2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDateRange(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx context.Context, v interface{}) (model.DsDetails, error) {
	return ec.unmarshalInputDsDetails(ctx, v)
}

func (ec *executionContext) unmarshalODsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx context.Context, v interface{}) (*model.DsDetails, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODsDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelDsDetails(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) marshalOHeatmapDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, v model.HeatmapDataResponse) graphql.Marshaler {
	return ec._HeatmapDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOHeatmapDataResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelHeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.HeatmapDataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HeatmapDataResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOImageRegistry2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistry(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistry) graphql.Marshaler {
	return ec._ImageRegistry(ctx, sel, &v)
}

func (ec *executionContext) marshalOImageRegistry2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistry(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalOImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageRegistryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelImageRegistryResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) marshalOLabelValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLabelValue(ctx context.Context, sel ast.SelectionSet, v model.LabelValue) graphql.Marshaler {
	return ec._LabelValue(ctx, sel, &v)
}

func (ec *executionContext) marshalOLabelValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLabelValue(ctx context.Context, sel ast.SelectionSet, v []*model.LabelValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLabelValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLabelValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOLabelValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelLabelValue(ctx context.Context, sel ast.SelectionSet, v *model.LabelValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LabelValue(ctx, sel, v)
}

func (ec *executionContext) marshalOListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v model.ListDashboardResponse) graphql.Marshaler {
	return ec._ListDashboardResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ListDashboardResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOListDashboardResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListDashboardResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListDashboardResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricDataForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanel(ctx context.Context, sel ast.SelectionSet, v model.MetricDataForPanel) graphql.Marshaler {
	return ec._MetricDataForPanel(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricDataForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanel(ctx context.Context, sel ast.SelectionSet, v []*model.MetricDataForPanel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricDataForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricDataForPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanel(ctx context.Context, sel ast.SelectionSet, v *model.MetricDataForPanel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricDataForPanel(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricDataForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, v model.MetricDataForPanelGroup) graphql.Marshaler {
	return ec._MetricDataForPanelGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricDataForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, v []*model.MetricDataForPanelGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricDataForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanelGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricDataForPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, v *model.MetricDataForPanelGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricDataForPanelGroup(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsPromResponse(ctx context.Context, sel ast.SelectionSet, v model.MetricsPromResponse) graphql.Marshaler {
	return ec._MetricsPromResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsPromResponse(ctx context.Context, sel ast.SelectionSet, v []*model.MetricsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsPromResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricsPromResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsPromResponse(ctx context.Context, sel ast.SelectionSet, v *model.MetricsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricsPromResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v model.MetricsTimeStampValue) graphql.Marshaler {
	return ec._MetricsTimeStampValue(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v [][]*model.MetricsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v []*model.MetricsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricsTimeStampValue2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v *model.MetricsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricsTimeStampValue(ctx, sel, v)
}

func (ec *executionContext) marshalOOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelOption(ctx context.Context, sel ast.SelectionSet, v model.Option) graphql.Marshaler {
	return ec._Option(ctx, sel, &v)
}

func (ec *executionContext) marshalOOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelOption(ctx context.Context, sel ast.SelectionSet, v []*model.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelOption(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelOption(ctx context.Context, sel ast.SelectionSet, v *model.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Option(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPagination2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPagination(ctx context.Context, v interface{}) (model.Pagination, error) {
	return ec.unmarshalInputPagination(ctx, v)
}

func (ec *executionContext) unmarshalOPagination2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPagination(ctx context.Context, v interface{}) (*model.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPagination2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPagination(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx context.Context, v interface{}) (model.Panel, error) {
	return ec.unmarshalInputPanel(ctx, v)
}

func (ec *executionContext) unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx context.Context, v interface{}) ([]*model.Panel, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Panel, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx context.Context, v interface{}) (*model.Panel, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPanel2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanel(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroup(ctx context.Context, v interface{}) (model.PanelGroup, error) {
	return ec.unmarshalInputPanelGroup(ctx, v)
}

func (ec *executionContext) unmarshalOPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroup(ctx context.Context, v interface{}) (*model.PanelGroup, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPanelGroup2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroup(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPanelGroupResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroupResponse(ctx context.Context, sel ast.SelectionSet, v model.PanelGroupResponse) graphql.Marshaler {
	return ec._PanelGroupResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPanelGroupResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelGroupResponse(ctx context.Context, sel ast.SelectionSet, v *model.PanelGroupResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PanelGroupResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPanelOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelOption(ctx context.Context, v interface{}) (model.PanelOption, error) {
	return ec.unmarshalInputPanelOption(ctx, v)
}

func (ec *executionContext) unmarshalOPanelOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelOption(ctx context.Context, v interface{}) (*model.PanelOption, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPanelOption2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelOption(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPanelOptionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelOptionResponse(ctx context.Context, sel ast.SelectionSet, v model.PanelOptionResponse) graphql.Marshaler {
	return ec._PanelOptionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPanelOptionResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelOptionResponse(ctx context.Context, sel ast.SelectionSet, v *model.PanelOptionResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PanelOptionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOPanelResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelResponse(ctx context.Context, sel ast.SelectionSet, v model.PanelResponse) graphql.Marshaler {
	return ec._PanelResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPanelResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelResponse(ctx context.Context, sel ast.SelectionSet, v []*model.PanelResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPanelResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPanelResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPanelResponse(ctx context.Context, sel ast.SelectionSet, v *model.PanelResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PanelResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProjectData(ctx context.Context, sel ast.SelectionSet, v model.ProjectData) graphql.Marshaler {
	return ec._ProjectData(ctx, sel, &v)
}

func (ec *executionContext) marshalOProjectData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelProjectData(ctx context.Context, sel ast.SelectionSet, v *model.ProjectData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPromQuery2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQuery(ctx context.Context, v interface{}) (model.PromQuery, error) {
	return ec.unmarshalInputPromQuery(ctx, v)
}

func (ec *executionContext) unmarshalOPromQuery2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQuery(ctx context.Context, v interface{}) ([]*model.PromQuery, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PromQuery, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPromQuery2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQuery(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPromQuery2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQuery(ctx context.Context, v interface{}) (*model.PromQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPromQuery2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx context.Context, v interface{}) (model.PromQueryInput, error) {
	return ec.unmarshalInputPromQueryInput(ctx, v)
}

func (ec *executionContext) unmarshalOPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx context.Context, v interface{}) ([]*model.PromQueryInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PromQueryInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx context.Context, v interface{}) (*model.PromQueryInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPromQueryInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPromQueryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryResponse(ctx context.Context, sel ast.SelectionSet, v model.PromQueryResponse) graphql.Marshaler {
	return ec._PromQueryResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPromQueryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryResponse(ctx context.Context, sel ast.SelectionSet, v []*model.PromQueryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPromQueryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPromQueryResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromQueryResponse(ctx context.Context, sel ast.SelectionSet, v *model.PromQueryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PromQueryResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPromSeriesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesInput(ctx context.Context, v interface{}) (model.PromSeriesInput, error) {
	return ec.unmarshalInputPromSeriesInput(ctx, v)
}

func (ec *executionContext) unmarshalOPromSeriesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesInput(ctx context.Context, v interface{}) (*model.PromSeriesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPromSeriesInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPromSeriesInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPrometheusDataRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPrometheusDataRequest(ctx context.Context, v interface{}) (model.PrometheusDataRequest, error) {
	return ec.unmarshalInputPrometheusDataRequest(ctx, v)
}

func (ec *executionContext) unmarshalOPrometheusDataRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPrometheusDataRequest(ctx context.Context, v interface{}) (*model.PrometheusDataRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPrometheusDataRequest2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelPrometheusDataRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOResource2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResource(ctx context.Context, v interface{}) (model.Resource, error) {
	return ec.unmarshalInputResource(ctx, v)
}

func (ec *executionContext) unmarshalOResource2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResource(ctx context.Context, v interface{}) ([]*model.Resource, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Resource, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOResource2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResource(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOResource2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResource(ctx context.Context, v interface{}) (*model.Resource, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOResource2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResource(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOResourceResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResourceResponse(ctx context.Context, sel ast.SelectionSet, v model.ResourceResponse) graphql.Marshaler {
	return ec._ResourceResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOResourceResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResourceResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ResourceResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOResourceResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResourceResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOResourceResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelResourceResponse(ctx context.Context, sel ast.SelectionSet, v *model.ResourceResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourceResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOSubData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSubData(ctx context.Context, sel ast.SelectionSet, v model.SubData) graphql.Marshaler {
	return ec._SubData(ctx, sel, &v)
}

func (ec *executionContext) marshalOSubData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSubData(ctx context.Context, sel ast.SelectionSet, v [][]*model.SubData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSubData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSubData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOSubData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSubData(ctx context.Context, sel ast.SelectionSet, v []*model.SubData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSubData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSubData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOSubData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelSubData(ctx context.Context, sel ast.SelectionSet, v *model.SubData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SubData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTemplateInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTemplateInput(ctx context.Context, v interface{}) (model.TemplateInput, error) {
	return ec.unmarshalInputTemplateInput(ctx, v)
}

func (ec *executionContext) unmarshalOTemplateInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTemplateInput(ctx context.Context, v interface{}) (*model.TemplateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTemplateInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelTemplateInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOToleration2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelToleration(ctx context.Context, v interface{}) (model.Toleration, error) {
	return ec.unmarshalInputToleration(ctx, v)
}

func (ec *executionContext) unmarshalOToleration2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelToleration(ctx context.Context, v interface{}) ([]*model.Toleration, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Toleration, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOToleration2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelToleration(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOToleration2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelToleration(ctx context.Context, v interface{}) (*model.Toleration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOToleration2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelToleration(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUpdatePanelGroupInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdatePanelGroupInput(ctx context.Context, v interface{}) (model.UpdatePanelGroupInput, error) {
	return ec.unmarshalInputUpdatePanelGroupInput(ctx, v)
}

func (ec *executionContext) unmarshalOUpdatePanelGroupInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdatePanelGroupInput(ctx context.Context, v interface{}) ([]*model.UpdatePanelGroupInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.UpdatePanelGroupInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOUpdatePanelGroupInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdatePanelGroupInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpdatePanelGroupInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdatePanelGroupInput(ctx context.Context, v interface{}) (*model.UpdatePanelGroupInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUpdatePanelGroupInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUpdatePanelGroupInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUsageSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageSortInput(ctx context.Context, v interface{}) (model.UsageSortInput, error) {
	return ec.unmarshalInputUsageSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOUsageSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageSortInput(ctx context.Context, v interface{}) (*model.UsageSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUsageSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelUsageSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflow2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflow(ctx context.Context, sel ast.SelectionSet, v model.Workflow) graphql.Marshaler {
	return ec._Workflow(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflow2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflow(ctx context.Context, sel ast.SelectionSet, v *model.Workflow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Workflow(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkflowFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowFilterInput(ctx context.Context, v interface{}) (model.WorkflowFilterInput, error) {
	return ec.unmarshalInputWorkflowFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowFilterInput(ctx context.Context, v interface{}) (*model.WorkflowFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRun) graphql.Marshaler {
	return ec._WorkflowRun(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowRun2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRun(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowRun(ctx, sel, v)
}

func (ec *executionContext) marshalOWorkflowRunDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunDetails(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunDetails) graphql.Marshaler {
	return ec._WorkflowRunDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowRunDetails2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunDetails(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowRunDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkflowRunFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunFilterInput(ctx context.Context, v interface{}) (model.WorkflowRunFilterInput, error) {
	return ec.unmarshalInputWorkflowRunFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowRunFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunFilterInput(ctx context.Context, v interface{}) (*model.WorkflowRunFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowRunFilterInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOWorkflowRunSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunSortInput(ctx context.Context, v interface{}) (model.WorkflowRunSortInput, error) {
	return ec.unmarshalInputWorkflowRunSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowRunSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunSortInput(ctx context.Context, v interface{}) (*model.WorkflowRunSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowRunSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOWorkflowRunStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatus(ctx context.Context, v interface{}) (model.WorkflowRunStatus, error) {
	var res model.WorkflowRunStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOWorkflowRunStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatus(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOWorkflowRunStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatus(ctx context.Context, v interface{}) (*model.WorkflowRunStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowRunStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflowRunStatus2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunStatus(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOWorkflowRunsData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunsData(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunsData) graphql.Marshaler {
	return ec._WorkflowRunsData(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowRunsData2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowRunsData(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunsData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowRunsData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkflowSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortInput(ctx context.Context, v interface{}) (model.WorkflowSortInput, error) {
	return ec.unmarshalInputWorkflowSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortInput(ctx context.Context, v interface{}) (*model.WorkflowSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowSortInput2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflowStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.WorkflowStatsResponse) graphql.Marshaler {
	return ec._WorkflowStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowStatsResponse2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowStatsResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v model.WorkflowTemplate) graphql.Marshaler {
	return ec._WorkflowTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowTemplate2githubcomlitmuschaoslitmuslitmusportalgraphqlservergraphmodelWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowTemplate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowTemplate(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
